<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>HN100 - Readable Contents</title>
        <link>https://hn.algolia.com/api/v1/search_by_date?tags=%28story,poll%29&amp;numericFilters=points%3E100</link>
        <description>Uses Readability to add bodies to the RSS feed</description>
        <lastBuildDate>Sun, 09 Feb 2025 00:30:03 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Jacksonpollock.org (109 pts)]]></title>
            <link>https://jacksonpollock.org/</link>
            <guid>42986320</guid>
            <pubDate>Sat, 08 Feb 2025 21:22:49 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://jacksonpollock.org/">https://jacksonpollock.org/</a>, See on <a href="https://news.ycombinator.com/item?id=42986320">Hacker News</a></p>
&lt;Unparsable&gt;]]></description>
        </item>
        <item>
            <title><![CDATA[Tips for mathematical handwriting (2007) (136 pts)]]></title>
            <link>https://johnkerl.org/doc/ortho/ortho.html</link>
            <guid>42985427</guid>
            <pubDate>Sat, 08 Feb 2025 19:20:10 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://johnkerl.org/doc/ortho/ortho.html">https://johnkerl.org/doc/ortho/ortho.html</a>, See on <a href="https://news.ycombinator.com/item?id=42985427">Hacker News</a></p>
<div id="readability-page-1" class="page">

<center>


John Kerl
<br><tt>kerl.john.r@gmail.com</tt>
<br>Feb. 25, 2007
</center>

<!-- ================================================================ -->
<hr>


<p>Now that you’re majoring in one of the technical disciplines
(engineering, science, or math), you’re going to be spending a
significant amount of time communicating in writing with others.  You may find
that previously unimportant details, such as crossing your <i>z</i>’s,
now become essential — not only so that others can understand you, but
also so that you can avoid mistaking your own 2<sup><i>z</i></sup> for
<i>z</i><sup>2</sup> and so on.  This is especially important if your
handwriting (like mine!) is less than perfect.

</p><p>Before I continue, take a fresh look at our Roman alphabet, the digits, and
the Greek alphabet:

</p><center><img src="https://johnkerl.org/doc/ortho/texortho.jpg"></center>

<p>Notice that these mechanically typeset symbols are all clear and distinct
(except that lowercase omicron and most of the uppercase Greek letters look
like Roman letters — we don’t use these “duplicates”).

</p><p> When we write by hand, though, symbols can become ambiguous —
we’re not machines, and things get a little loopy when we hurry.  In
prose, surrounding letters can disambiguate a questionable letter — e.g.
you can guess that the fourth letter of <i>hou*e</i> has to be an <i>s</i>.
But in mathematical expressions we mix symbols from different alphabets, in
different orders, so context can’t assist us — and when we guess,
we often guess wrong.  So it now becomes very important that each letter be
clearly recognizable on its own merits.

</p><p>Here are samples, followed by the points I consider most important.

</p><center><img src="https://johnkerl.org/doc/ortho/jkortho.jpg"></center>

<p>
<b>Lowercase Roman letters:</b>
</p><ul>

<li>Always make the lowercase <i>l</i> cursive —
otherwise it looks like a 1.
Make sure it’s taller than an <i>e</i>:
<img src="https://johnkerl.org/doc/ortho/letters/jkell.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jk1.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jke.jpg">.
The lowercase <i>l</i> isn’t a good variable name to use (since it can
look like a 1), but lots of people use it and so you’ll be seeing more of
it.

</li><li>Make a point come out of the top of the <i>p</i>, to distinguish it from a
rho:
<img src="https://johnkerl.org/doc/ortho/letters/jkp.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkrho.jpg">.

</li><li>Put a stroke on the <i>q</i>, to avoid confusion with 9 — and not a loop, to avoid confusion with 8:
<img src="https://johnkerl.org/doc/ortho/letters/jkq.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jk9.jpg">.

</li><li>Put a hook at the bottom of the <i>t</i> so it doesn’t look like a
plus sign:
<img src="https://johnkerl.org/doc/ortho/letters/jkt.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkplus.jpg">.

</li><li>Put a tail on the <i>u</i>, so it doesn’t look like a <i>v</i>:
<img src="https://johnkerl.org/doc/ortho/letters/jku.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkv.jpg">.

</li><li>Keep the <i>v</i> and <i>w</i> pointy on the bottom so they don’t
look like nu and omega, respectively:
<img src="https://johnkerl.org/doc/ortho/letters/jkv.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkw.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jknu.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkomega.jpg">.

</li><li>Put a hook on the <i>x</i> to distinguish it from a times sign:
<img src="https://johnkerl.org/doc/ortho/letters/jkx.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jktimes.jpg">.
In 3rd-semester calculus and onward you’ll be using the times sign quite
often.

</li><li>Cross your <i>z</i>’s.  Else they look like 2’s:
<img src="https://johnkerl.org/doc/ortho/letters/jkz.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jk2.jpg">.

</li></ul>

<p>
<b>Uppercase Roman letters:</b>
</p>

<p>
<b>Digits:</b>
</p>

<p>
<b>Lowercase Greek letters:</b>
</p><ul>

<li>Many incoming freshmen aren’t accustomed to Greek letters, and
substitute alphas with <i>a</i>’s, and so on.  The fact is, though,
you’re going to be seeing more and more Greek letters as you go on.  Your
mathematical world is growing — accept it, and learn to use this
beautiful alphabet.

</li><li>Draw the alpha in one easy swoosh.  Be careful it doesn’t look like a
2:
<img src="https://johnkerl.org/doc/ortho/letters/jkalpha.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jk2.jpg">.

</li><li>Put a long tail on the eta and mu to keep them from looking like <i>n</i>
and cursive <i>u</i>, respectively:
<img src="https://johnkerl.org/doc/ortho/letters/jketa.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkmu.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkn.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jku.jpg">.

</li><li>Put a hook on the top of the lambda:
<img src="https://johnkerl.org/doc/ortho/letters/jklambda.jpg">.

</li><li>The nu is a very bad letter — it looks like too many others!
Unfortunately, lots of people use it.  Include the hook on the left, and the
point at the bottom, to keep it from looking like a <i>u</i> or <i>v</i> or
upsilon:
<img src="https://johnkerl.org/doc/ortho/letters/jknu.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jku.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkv.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkupsilon.jpg">.

</li><li>We don’t use omicron — it’s identical to a Roman
<i>o</i>.

</li><li>The upsilon is just as bad as the nu.  Happily, not many people use it.
Make sure it doesn’t look like a <i>u</i>, <i>v</i>, or nu:
<img src="https://johnkerl.org/doc/ortho/letters/jkupsilon.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jku.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkv.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jknu.jpg">.

</li><li>Keep the slash in the phi vertical; keep the slash in the empty-set symbol
slanted:
<img src="https://johnkerl.org/doc/ortho/letters/jkphi.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkemptyset.jpg">.

</li><li>The lower-case chi is tricky, and unfortunately it gets used a lot.  Make
the upward slash far bigger than the downward slash to distinguish this letter
from lowercase <i>x</i> and uppercase <i>X</i>:
<img src="https://johnkerl.org/doc/ortho/letters/jkchi.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkx.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkcapX.jpg">.

</li><li>Keep the omega rounded to distinguish it from <i>w</i>.  This one gets used
a lot in physics courses.
<img src="https://johnkerl.org/doc/ortho/letters/jkomega.jpg">,
<img src="https://johnkerl.org/doc/ortho/letters/jkw.jpg">.

</li></ul>

<p>
<b>Uppercase Greek letters:</b>
</p>

<!-- ================================================================ -->
<!--
<hr>
<p>John Kerl
<br><tt>kerl at math dot arizona dot edu</tt>
<br>Feb. 25, 2007
-->

<!-- ================================================================ -->
<hr>
<p>

<a href="https://johnkerl.org/index.html"><i>← Back</i></a>


</p></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Writing a Simple Windows Driver in Rust (133 pts)]]></title>
            <link>https://scorpiosoftware.net/2025/02/08/writing-a-simple-driver-in-rust/</link>
            <guid>42984457</guid>
            <pubDate>Sat, 08 Feb 2025 17:25:03 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://scorpiosoftware.net/2025/02/08/writing-a-simple-driver-in-rust/">https://scorpiosoftware.net/2025/02/08/writing-a-simple-driver-in-rust/</a>, See on <a href="https://news.ycombinator.com/item?id=42984457">Hacker News</a></p>
<div id="readability-page-1" class="page"><div>
		
<p>The Rust language ecosystem is growing each day, its popularity increasing, and with good reason. It’s the only mainstream language that provides memory and concurrency safety at compile time, with a powerful and rich build system (cargo), and a growing number of packages (crates).</p>



<p>My daily driver is still C++, as most of my work is about low-level system and kernel programming, where the Windows C and COM APIs are easy to consume. Rust is a system programming language, however, which means it plays, or at least can play, in the same playground as C/C++. The main snag is the verbosity required when converting C types to Rust. This “verbosity” can be alleviated with appropriate wrappers and macros. I decided to try writing a simple WDM driver that is not useless – it’s a Rust version of the “Booster” driver I demonstrate in my book (<a href="https://www.amazon.com/Windows-Kernel-Programming-Pavel-Yosifovich/dp/1977593372" target="_blank" rel="noreferrer noopener">Windows Kernel Programming</a>), that allows changing the priority of any thread to any value.</p>



<h2>Getting Started</h2>



<p>To prepare for building drivers, consult <a href="https://github.com/microsoft/windows-drivers-rs" target="_blank" rel="noreferrer noopener">Windows Drivers-rs</a>, but basically you should have a WDK installation (either normal or the <a href="https://learn.microsoft.com/en-us/legal/windows/hardware/enterprise-wdk-license-2022" target="_blank" rel="noreferrer noopener">EWDK</a>). Also, the docs require installing <a href="https://llvm.org/" target="_blank" rel="noreferrer noopener">LLVM</a>, to gain access to the <a href="https://clang.llvm.org/" target="_blank" rel="noreferrer noopener">Clang </a>compiler. I am going to assume you have these installed if you’d like to try the following yourself.</p>



<p>We can start by creating a new Rust library project (as a driver is a technically a DLL loaded into kernel space):</p>





<p>We can open the booster folder in VS Code, and begin are coding. First, there are some preparations to do in order for actual code to compile and link successfully. We need a <strong>build.rs</strong> file to tell cargo to link statically to the CRT. Add a <strong>build.rs</strong> file to the root booster folder, with the following code:</p>


<div><pre title="">fn main() -&gt; Result&lt;(), wdk_build::ConfigError&gt; {
    std::env::set_var("CARGO_CFG_TARGET_FEATURE", "crt-static");
    wdk_build::configure_wdk_binary_build()
}
</pre></div>


<p>(Syntax highlighting is imperfect because the WordPress editor I use does not support syntax highlighting for Rust)</p>



<p>Next, we need to edit <strong>cargo.toml</strong> and add all kinds of dependencies. The following is the minimum I could get away with:</p>


<div><pre title="">[package]
name = "booster"
version = "0.1.0"
edition = "2021"

[package.metadata.wdk.driver-model]
driver-type = "WDM"

[lib]
crate-type = ["cdylib"]
test = false

[build-dependencies]
wdk-build = "0.3.0"

[dependencies]
wdk = "0.3.0"       
wdk-macros = "0.3.0"
wdk-alloc = "0.3.0" 
wdk-panic = "0.3.0" 
wdk-sys = "0.3.0"   

[features]
default = []
nightly = ["wdk/nightly", "wdk-sys/nightly"]

[profile.dev]
panic = "abort"
lto = true

[profile.release]
panic = "abort"
lto = true
</pre></div>


<p>The important parts are the WDK crates dependencies. It’s time to get to the actual code in <strong>lib.rs</strong>. </p>



<h2>The Code</h2>



<p>We start by removing the standard library, as it does not exist in the kernel:</p>





<p>Next, we’ll add a few <code>use</code> statements to make the code less verbose:</p>


<div><pre title="">use core::ffi::c_void;
use core::ptr::null_mut;
use alloc::vec::Vec;
use alloc::{slice, string::String};
use wdk::*;
use wdk_alloc::WdkAllocator;
use wdk_sys::ntddk::*;
use wdk_sys::*;
</pre></div>


<p>The <code>wdk_sys</code> crate provides the low level interop kernel functions. the <code>wdk</code> crate provides higher-level wrappers. <code>alloc::vec::Vec</code> is an interesting one. Since we can’t use the standard library, you would think the types like <code>std::vec::Vec&lt;&gt;</code> are not available, and technically that’s correct. However, <code>Vec</code> is actually defined in a lower level module named <code>alloc::vec</code>, that can be used outside the standard library. This works because the only requirement for <code>Vec</code> is to have a way to allocate and deallocate memory. Rust exposes this aspect through a global allocator object, that anyone can provide. Since we have no standard library, there is no global allocator, so one must be provided. Then, <code>Vec</code> (and <code>String</code>) can work normally:</p>


<div><pre title="">#[global_allocator]
static GLOBAL_ALLOCATOR: WdkAllocator = WdkAllocator;
</pre></div>


<p>This is the global allocator provided by the WDK crates, that use <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exallocatepool2" target="_blank" rel="noreferrer noopener"><code>ExAllocatePool2</code> </a>and <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-exfreepool" target="_blank" rel="noreferrer noopener"><code>ExFreePool</code> </a>to manage allocations, just like would do manually.</p>



<p>Next, we add two <code>extern</code> crates to get the support for the allocator and a panic handler – another thing that must be provided since the standard library is not included. <strong>Cargo.toml</strong> has a setting to abort the driver (crash the system) if any code panics:</p>


<div><pre title="">extern crate wdk_panic;
extern crate alloc;
</pre></div>


<p>Now it’s time to write the actual code. We start with <code>DriverEntry</code>, the entry point to any Windows kernel driver:</p>


<div><pre title="">#[export_name = "DriverEntry"]
pub unsafe extern "system" fn driver_entry(
    driver: &amp;mut DRIVER_OBJECT,
    registry_path: PUNICODE_STRING,
) -&gt; NTSTATUS {
</pre></div>


<p>Those familiar with kernel drivers will recognize the function signature (kind of). The function name is <code>driver_entry</code> to conform to the snake_case Rust naming convention for functions, but since the linker looks for <code>DriverEntry</code>, we decorate the function with the <code>export_name</code> attribute. You could use <code>DriverEntry</code> and just ignore or disable the compiler’s warning, if you prefer.</p>



<p>We can use the familiar <code>println!</code> macro, that was reimplemented by calling <code>DbgPrint</code>, as you would if you were using C/C++. You can still call <code>DbgPrint</code>, mind you, but <code>println!</code> is just easier:</p>


<div><pre title="">println!("DriverEntry from Rust! {:p}", &amp;driver);
let registry_path = unicode_to_string(registry_path);
println!("Registry Path: {}", registry_path);
</pre></div>


<p>Unfortunately, it seems <code>println!</code> does not yet support a <code>UNICODE_STRING</code>, so we can write a function named <code>unicode_to_string</code> to convert a <code>UNICODE_STRING</code> to a normal Rust string:</p>


<div><pre title="">fn unicode_to_string(str: PCUNICODE_STRING) -&gt; String {
    String::from_utf16_lossy(unsafe {
        slice::from_raw_parts((*str).Buffer, (*str).Length as usize / 2)
    })
}
</pre></div>


<p>Back in <code>DriverEntry</code>, our next order of business is to create a device object with the name “\Device\Booster”:</p>


<div><pre title="">let mut dev = null_mut();
let mut dev_name = UNICODE_STRING::default();
string_to_ustring("\\Device\\Booster", &amp;mut dev_name);

let status = IoCreateDevice(
    driver,
    0,
    &amp;mut dev_name,
    FILE_DEVICE_UNKNOWN,
    0,
    0u8,
    &amp;mut dev,
);
</pre></div>


<p>The <code>string_to_ustring</code> function converts a Rust string to a <code>UNICODE_STRING</code>:</p>


<div><pre title="">fn string_to_ustring&lt;'a&gt;(s: &amp;str, uc: &amp;'a mut UNICODE_STRING) -&gt; &amp;'a mut UNICODE_STRING {
    let mut wstring: Vec&lt;_&gt; = s.encode_utf16().collect();
    uc.Length = wstring.len() as u16 * 2;
    uc.MaximumLength = wstring.len() as u16 * 2;
    uc.Buffer = wstring.as_mut_ptr();
    uc
}
</pre></div>


<p>This may look more complex than we would like, but think of this as a function that is written once, and then just used all over the place. In fact, maybe there is such a function already, and just didn’t look hard enough. But it will do for this driver.</p>



<p>If device creation fails, we return a failure status:</p>


<div><pre title="">if !nt_success(status) {
    println!("Error creating device 0x{:X}", status);
    return status;
}
</pre></div>


<p><code>nt_success</code> is similar to the <code>NT_SUCCESS</code> macro provided by the WDK headers.</p>



<p>Next, we’ll create a symbolic link so that a standard <code>CreateFile</code> call could open a handle to our device:</p>


<div><pre title="">let mut sym_name = UNICODE_STRING::default();
string_to_ustring("\\??\\Booster", &amp;mut sym_name);
let status = IoCreateSymbolicLink(&amp;mut sym_name, &amp;mut dev_name);
if !nt_success(status) {
    println!("Error creating symbolic link 0x{:X}", status);
    IoDeleteDevice(dev);
    return status;
}
</pre></div>


<p>All that’s left to do is initialize the device object with support for Buffered I/O (we’ll use <code>IRP_MJ_WRITE</code> for simplicity), set the driver unload routine, and the major functions we intend to support:</p>


<div><pre title="">    (*dev).Flags |= DO_BUFFERED_IO;

    driver.DriverUnload = Some(boost_unload);
    driver.MajorFunction[IRP_MJ_CREATE as usize] = Some(boost_create_close);
    driver.MajorFunction[IRP_MJ_CLOSE as usize] = Some(boost_create_close);
    driver.MajorFunction[IRP_MJ_WRITE as usize] = Some(boost_write);

    STATUS_SUCCESS
}
</pre></div>


<p>Note the use of the Rust <code>Option&lt;&gt;</code> type to indicate the presence of a callback.</p>



<p>The unload routine looks like this:</p>


<div><pre title="">unsafe extern "C" fn boost_unload(driver: *mut DRIVER_OBJECT) {
    let mut sym_name = UNICODE_STRING::default();
    string_to_ustring("\\??\\Booster", &amp;mut sym_name);
    let _ = IoDeleteSymbolicLink(&amp;mut sym_name);
    IoDeleteDevice((*driver).DeviceObject);
}
</pre></div>


<p>We just call <code>IoDeleteSymbolicLink</code> and <code>IoDeleteDevice</code>, just like a normal kernel driver would. </p>



<h2>Handling Requests</h2>



<p>We have three request types to handle – <code>IRP_MJ_CREATE</code>, <code>IRP_MJ_CLOSE</code>, and <code>IRP_MJ_WRITE</code>. Create and close are trivial – just complete the IRP successfully:</p>


<div><pre title="">unsafe extern "C" fn boost_create_close(_device: *mut DEVICE_OBJECT, irp: *mut IRP) -&gt; NTSTATUS {
    (*irp).IoStatus.__bindgen_anon_1.Status = STATUS_SUCCESS;
    (*irp).IoStatus.Information = 0;
    IofCompleteRequest(irp, 0);
    STATUS_SUCCESS
}
</pre></div>


<p>The <code>IoStatus</code> is an <code>IO_STATUS_BLOCK</code> but it’s defined with a <code>union</code> containing <code>Status</code> and <code>Pointer</code>. This seems to be incorrect, as <code>Information</code> should be in a <code>union</code> with <code>Pointer</code> (not <code>Status</code>). Anyway, the code accesses the <code>Status</code> member through the “auto generated” union, and it looks ugly. Definitely something to look into further. But it works.</p>



<p>The real interesting function is the <code>IRP_MJ_WRITE</code> handler, that does the actual thread priority change. First, we’ll declare a structure to represent the request to the driver:</p>


<div><pre title="">#[repr(C)]
struct ThreadData {
    pub thread_id: u32,
    pub priority: i32,
}
</pre></div>


<p>The use of <code>repr(C)</code> is important, to make sure the fields are laid out in memory just as they would with C/C++. This allows non-Rust clients to talk to the driver. In fact, I’ll test the driver with a C++ client I have that used the C++ version of the driver. The driver accepts the thread ID to change and the priority to use. Now we can start with <code>boost_write</code>:</p>


<div><pre title="">unsafe extern "C" fn boost_write(_device: *mut DEVICE_OBJECT, irp: *mut IRP) -&gt; NTSTATUS {
    let data = (*irp).AssociatedIrp.SystemBuffer as *const ThreadData;
</pre></div>


<p>First, we grab the data pointer from the <code>SystemBuffer</code> in the IRP, as we asked for Buffered I/O support. This is a kernel copy of the client’s buffer. Next, we’ll do some checks for errors:</p>


<div><pre title="">let status;
loop {
    if data == null_mut() {
        status = STATUS_INVALID_PARAMETER;
        break;
    }
    if (*data).priority &lt; 1 || (*data).priority &gt; 31 {
        status = STATUS_INVALID_PARAMETER;
        break;
    }
</pre></div>


<p>The <code>loop</code> statement creates an infinite block that can be exited with a <code>break</code>. Once we verified the priority is in range, it’s time to locate the thread object:</p>


<div><pre title="">let mut thread = null_mut();
status = PsLookupThreadByThreadId(((*data).thread_id) as *mut c_void, &amp;mut thread);
if !nt_success(status) {
    break;
}
</pre></div>


<p><code><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-pslookupthreadbythreadid" target="_blank" rel="noreferrer noopener">PsLookupThreadByThreadId</a></code> is the one to use. If it fails, it means the thread ID probably does not exist, and we break. All that’s left to do is set the priority and complete the request with whatever status we have:</p>


<div><pre title="">        KeSetPriorityThread(thread, (*data).priority);
        ObfDereferenceObject(thread as *mut c_void);
        break;
    }
    (*irp).IoStatus.__bindgen_anon_1.Status = status;
    (*irp).IoStatus.Information = 0;
    IofCompleteRequest(irp, 0);
    status
}
</pre></div>


<p>That’s it!</p>



<p>The only remaining thing is to sign the driver. It seems that the crates support signing the driver if an INF or INX files are present, but this driver is not using an INF. So we need to sign it manually before deployment. The following can be used from the root folder of the project:</p>


<div><pre title="">signtool sign /n wdk /fd sha256 target\debug\booster.dll
</pre></div>


<p>The <code>/n wdk</code> uses a WDK test certificate typically created automatically by Visual Studio when building drivers. I just grab the first one in the store that starts with “wdk” and use it.</p>



<p>The silly part is the file extension – it’s a DLL and there currently is no way to change it automatically as part of cargo build. If using an INF/INX, the file extension does change to SYS. In any case, file extensions don’t really mean that much – we can rename it manually, or just leave it as DLL. </p>



<h2>Installing the Driver</h2>



<p>The resulting file can be installed in the “normal” way for a software driver, such as using the <strong>sc.exe</strong> tool (from an elevated command window), on a machine with test signing on. Then <code>sc start</code> can be used to load the driver into the system:</p>


<div><pre title="">sc.exe sc create booster type= kernel binPath= c:\path_to_driver_file
sc.exe start booster
</pre></div>


<h2>Testing the Driver</h2>



<p>I used an existing C++ application that talks to the driver and expects to pass the correct structure. It looks like this:</p>


<div><pre title="">#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

struct ThreadData {
	int ThreadId;
	int Priority;
};

int main(int argc, const char* argv[]) {
	if (argc &lt; 3) {
		printf("Usage: boost &lt;tid&gt; &lt;priority&gt;\n");
		return 0;
	}

	int tid = atoi(argv[1]);
	int priority = atoi(argv[2]);

	HANDLE hDevice = CreateFile(L"\\\\.\\Booster",
		GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, 0,
		nullptr);

	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("Failed in CreateFile: %u\n", GetLastError());
		return 1;
	}

	ThreadData data;
	data.ThreadId = tid;
	data.Priority = priority;
	DWORD ret;
	if (WriteFile(hDevice, &amp;data, sizeof(data),
		&amp;ret, nullptr))
		printf("Success!!\n");
	else
		printf("Error (%u)\n", GetLastError());

	CloseHandle(hDevice);

	return 0;
}
</pre></div>


<p>Here is the result when changing a thread’s priority to 26 (ID 9408):</p>



<figure><img data-attachment-id="2919" data-permalink="https://scorpiosoftware.net/2025/02/08/writing-a-simple-driver-in-rust/image-41/" data-orig-file="https://scorpiosoftware.net/wp-content/uploads/2025/02/image.png" data-orig-size="976,579" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://scorpiosoftware.net/wp-content/uploads/2025/02/image.png?w=300" data-large-file="https://scorpiosoftware.net/wp-content/uploads/2025/02/image.png?w=660" width="976" height="579" src="https://scorpiosoftware.net/wp-content/uploads/2025/02/image.png?w=976" alt=""></figure>



<h2>Conclusion</h2>



<p>Writing kernel drivers in Rust is possible, and I’m sure the support for this will improve quickly. The WDK crates are at version 0.3, which means there is still a way to go. To get the most out of Rust in this space, safe wrappers should be created so that the code is less verbose, does not have <code>unsafe</code> blocks, and enjoys the benefits Rust can provide. Note, that I may have missed some wrappers in this simple implementation.</p>



<p>You can find a couple of more samples for KMDF Rust drivers <a href="https://github.com/microsoft/Windows-rust-driver-samples" target="_blank" rel="noreferrer noopener">here</a>.</p>



<p>The code for this post can be found at <a href="https://github.com/zodiacon/Booster">https://github.com/zodiacon/Booster</a>.</p>




	</div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Show HN: FlashSpace – fast, open-source, macOS Spaces replacement (143 pts)]]></title>
            <link>https://github.com/wojciech-kulik/FlashSpace</link>
            <guid>42984420</guid>
            <pubDate>Sat, 08 Feb 2025 17:19:23 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://github.com/wojciech-kulik/FlashSpace">https://github.com/wojciech-kulik/FlashSpace</a>, See on <a href="https://news.ycombinator.com/item?id=42984420">Hacker News</a></p>
<div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a href="https://github.com/wojciech-kulik/FlashSpace/releases"><img src="https://camo.githubusercontent.com/e6c6c47124a3c9f2cfff3a55803b80533c4271be3cd6ae50effacc5fb56baa26/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f776f6a63696563682d6b756c696b2f466c61736853706163653f636f6c6f723d384132424532" alt="GitHub Release" data-canonical-src="https://img.shields.io/github/v/release/wojciech-kulik/FlashSpace?color=8A2BE2"></a>
<a href="https://formulae.brew.sh/cask/flashspace" rel="nofollow"><img src="https://camo.githubusercontent.com/5b47e91f76e1b2557c38eb45c2b23890308e7e4a8522b311dcbda9323249969f/68747470733a2f2f696d672e736869656c64732e696f2f686f6d65627265772f6361736b2f762f666c6173687370616365" alt="Homebrew Cask Version" data-canonical-src="https://img.shields.io/homebrew/cask/v/flashspace"></a>
<a href="#"><img src="https://camo.githubusercontent.com/15209e50423be67a97aa21bbd132ffc55c2a5752fc43ad1f94e57dfb8b7e8f1f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6d61634f532d31342e302b2d73696c766572" alt="min macOS" data-canonical-src="https://img.shields.io/badge/macOS-14.0+-silver"></a>
<a href="https://github.com/wojciech-kulik/FlashSpace/actions/workflows/xcode-build-check.yml"><img src="https://camo.githubusercontent.com/3bcf4c0f8f2a61040df5a08d5710f9ff1b4bbab4bf480fffcb6fc3dad6cd9349/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f776f6a63696563682d6b756c696b2f466c61736853706163652f78636f64652d6275696c642d636865636b2e796d6c" alt="CI Status" data-canonical-src="https://img.shields.io/github/actions/workflow/status/wojciech-kulik/FlashSpace/xcode-build-check.yml"></a>
<a href="#"><img src="https://camo.githubusercontent.com/8b88167a0ff625ca5c105e93603034c9a72880fdafd173433db4382fedf73953/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f78636f64652d31362e322d626c7565" alt="Supported Xcode" data-canonical-src="https://img.shields.io/badge/xcode-16.2-blue"></a></p>
<p dir="auto"><h2 tabindex="-1" dir="auto">⚡ FlashSpace</h2><a id="user-content--flashspace" aria-label="Permalink: ⚡ FlashSpace" href="#-flashspace"></a></p>
<p dir="auto">FlashSpace is a blazingly-fast virtual workspace manager for macOS, designed to
enhance and replace native macOS Spaces. No more waiting for macOS animations.</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/3128467/410695368-36f4933d-3711-4acf-9171-9137073010d7.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzkwNTQxMDMsIm5iZiI6MTczOTA1MzgwMywicGF0aCI6Ii8zMTI4NDY3LzQxMDY5NTM2OC0zNmY0OTMzZC0zNzExLTRhY2YtOTE3MS05MTM3MDczMDEwZDcucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDIwOCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTAyMDhUMjIzMDAzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NjUwZWJjYzRmN2M4OTVkMjliNWY2NmY1NzMzYWY1MGFmYjRlY2M3MTY3ZjAyYmNjNDA4NmM3ODQ2MjE4ZjY4MiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.nKneogrFNUPyMHwb9-lDzBFZjD3Cqz0CuxwvLVtlN3Y"><img width="797" alt="FlashSpace" src="https://private-user-images.githubusercontent.com/3128467/410695368-36f4933d-3711-4acf-9171-9137073010d7.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzkwNTQxMDMsIm5iZiI6MTczOTA1MzgwMywicGF0aCI6Ii8zMTI4NDY3LzQxMDY5NTM2OC0zNmY0OTMzZC0zNzExLTRhY2YtOTE3MS05MTM3MDczMDEwZDcucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDIwOCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTAyMDhUMjIzMDAzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9NjUwZWJjYzRmN2M4OTVkMjliNWY2NmY1NzMzYWY1MGFmYjRlY2M3MTY3ZjAyYmNjNDA4NmM3ODQ2MjE4ZjY4MiZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.nKneogrFNUPyMHwb9-lDzBFZjD3Cqz0CuxwvLVtlN3Y"></a>
<p dir="auto"><h2 tabindex="-1" dir="auto">⚙️ Installation</h2><a id="user-content-️-installation" aria-label="Permalink: ⚙️ Installation" href="#️-installation"></a></p>
<p dir="auto"><strong>Requirements:</strong> macOS 14.0 or later.</p>
<p dir="auto"><h3 tabindex="-1" dir="auto">Homebrew</h3><a id="user-content-homebrew" aria-label="Permalink: Homebrew" href="#homebrew"></a></p>

<p dir="auto"><h3 tabindex="-1" dir="auto">Download Binary</h3><a id="user-content-download-binary" aria-label="Permalink: Download Binary" href="#download-binary"></a></p>
<p dir="auto">See: <a href="https://github.com/wojciech-kulik/FlashSpace/releases">Releases Page</a>.</p>
<p dir="auto"><h3 tabindex="-1" dir="auto">Build From Source</h3><a id="user-content-build-from-source" aria-label="Permalink: Build From Source" href="#build-from-source"></a></p>
<p dir="auto">See: <a href="#%EF%B8%8F-build-from-source">Build From Source</a>.</p>
<p dir="auto"><h2 tabindex="-1" dir="auto">🎥 Demo</h2><a id="user-content--demo" aria-label="Permalink: 🎥 Demo" href="#-demo"></a></p>
<p dir="auto">The video shows a sample configuration where I use 3 workspaces and switch
between them using hotkeys.</p>
<details open="">
  <summary>
    
    <span aria-label="Video description FlashSpace.mp4">FlashSpace.mp4</span>
    <span></span>
  </summary>

  <video src="https://private-user-images.githubusercontent.com/3128467/411269408-03498386-7c3d-4d9e-8fbd-cd49dea36661.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzkwNTQxMDMsIm5iZiI6MTczOTA1MzgwMywicGF0aCI6Ii8zMTI4NDY3LzQxMTI2OTQwOC0wMzQ5ODM4Ni03YzNkLTRkOWUtOGZiZC1jZDQ5ZGVhMzY2NjEubXA0P1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDIwOCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTAyMDhUMjIzMDAzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ODc2MjZjMmI5MmMxOWJlZjBkZDUyZTI2NjViMTNhMDEyNDliMGM1OWU3OTkxYzMxZmUwMmIzMTYyMjc5Mjc5NyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.cw41Upce0DtEPZV0edTF_tlbUMdifjLn_bNHXVrlfJY" data-canonical-src="https://private-user-images.githubusercontent.com/3128467/411269408-03498386-7c3d-4d9e-8fbd-cd49dea36661.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzkwNTQxMDMsIm5iZiI6MTczOTA1MzgwMywicGF0aCI6Ii8zMTI4NDY3LzQxMTI2OTQwOC0wMzQ5ODM4Ni03YzNkLTRkOWUtOGZiZC1jZDQ5ZGVhMzY2NjEubXA0P1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDIwOCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTAyMDhUMjIzMDAzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9ODc2MjZjMmI5MmMxOWJlZjBkZDUyZTI2NjViMTNhMDEyNDliMGM1OWU3OTkxYzMxZmUwMmIzMTYyMjc5Mjc5NyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.cw41Upce0DtEPZV0edTF_tlbUMdifjLn_bNHXVrlfJY" controls="controls" muted="muted">

  </video>
</details>

<p dir="auto"><h2 tabindex="-1" dir="auto">👉 How it works</h2><a id="user-content--how-it-works" aria-label="Permalink: 👉 How it works" href="#-how-it-works"></a></p>
<p dir="auto">FlashSpace allows to define virtual workspaces and assign apps to them. Each workspace is
also assigned to a specific display. When you switch to a workspace, the assigned apps are
automatically presented and all other apps from the assigned display are hidden.</p>
<p dir="auto">The app allows workspaces to be switched independently on each display.</p>
<p dir="auto"><h2 tabindex="-1" dir="auto">✨ Features</h2><a id="user-content--features" aria-label="Permalink: ✨ Features" href="#-features"></a></p>
<ul>
<li> Blazingly fast workspace switching</li>
<li> Multiple displays support</li>
<li> Activate workspace on app focus</li>
<li> Move apps between workspaces with a hotkey</li>
<li> Floating apps visible across all workspaces</li>
<li> Focus manager - set hotkeys to switch between apps quickly</li>
<li> Cursor manager - auto-center the cursor in the active window</li>
<li> Profiles - quickly switch between different configurations</li>
<li> Configurable Menu Bar icon &amp; text (per workspace)</li>
<li> <a href="https://github.com/FelixKratz/SketchyBar">SketchyBar</a> integration</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">⚖️ Project Values</h2><a id="user-content-️-project-values" aria-label="Permalink: ⚖️ Project Values" href="#️-project-values"></a></p>
<ul dir="auto">
<li><strong>Performance</strong> - The app should be as fast as possible.</li>
<li><strong>Simplicity</strong> - The app should be easy to use and configure.</li>
<li><strong>Reliability</strong> - The app should work without glitches and unexpected behavior.</li>
<li><strong>Invisible</strong> - The app should help, not disturb.</li>
<li><strong>UNIX Philosophy</strong> - The app should do one thing and do it well - manage workspaces.</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">💬 How to use</h2><a id="user-content--how-to-use" aria-label="Permalink: 💬 How to use" href="#-how-to-use"></a></p>
<ol dir="auto">
<li>Create a workspace.</li>
<li>Assign apps to the workspace.</li>
<li>Assign the workspace to a display.</li>
<li>Define a hotkey to switch to the workspace.</li>
<li>Save the workspace.</li>
</ol>
<p dir="auto">Now you can switch to the workspace using the configured hotkey.</p>
<p dir="auto"><h2 tabindex="-1" dir="auto">🪟 Focus Manager</h2><a id="user-content--focus-manager" aria-label="Permalink: 🪟 Focus Manager" href="#-focus-manager"></a></p>
<p dir="auto">FlashSpace enables fast switching of focus between windows. Use hotkeys to
shift focus in any desired direction. It also allows you to jump between
displays.</p>
<details open="">
  <summary>
    
    <span aria-label="Video description FocusManager.mp4">FocusManager.mp4</span>
    <span></span>
  </summary>

  <video src="https://private-user-images.githubusercontent.com/3128467/411269421-9bc22b19-7cd7-48f8-a679-0adf4adc3aef.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzkwNTQxMDMsIm5iZiI6MTczOTA1MzgwMywicGF0aCI6Ii8zMTI4NDY3LzQxMTI2OTQyMS05YmMyMmIxOS03Y2Q3LTQ4ZjgtYTY3OS0wYWRmNGFkYzNhZWYubXA0P1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDIwOCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTAyMDhUMjIzMDAzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9YWI1MWVhNzUxYTI5OGQyZWEzZDFhOGE5YTQxZGZmNzBmMjMxMGZhZGJjODBmNjc4OGQ4MmMzNjdlZDRiNmJiMyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.B8byTdySIp8drz6WdeKZxW05RKmiwaJOebw3XQXJt3E" data-canonical-src="https://private-user-images.githubusercontent.com/3128467/411269421-9bc22b19-7cd7-48f8-a679-0adf4adc3aef.mp4?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MzkwNTQxMDMsIm5iZiI6MTczOTA1MzgwMywicGF0aCI6Ii8zMTI4NDY3LzQxMTI2OTQyMS05YmMyMmIxOS03Y2Q3LTQ4ZjgtYTY3OS0wYWRmNGFkYzNhZWYubXA0P1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDIwOCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTAyMDhUMjIzMDAzWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9YWI1MWVhNzUxYTI5OGQyZWEzZDFhOGE5YTQxZGZmNzBmMjMxMGZhZGJjODBmNjc4OGQ4MmMzNjdlZDRiNmJiMyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.B8byTdySIp8drz6WdeKZxW05RKmiwaJOebw3XQXJt3E" controls="controls" muted="muted">

  </video>
</details>

<p dir="auto"><h2 tabindex="-1" dir="auto">📝 Notes</h2><a id="user-content--notes" aria-label="Permalink: 📝 Notes" href="#-notes"></a></p>
<p dir="auto">FlashSpace doesn't manage windows, so if you switch to a workspace and call
another app that is not assigned to the workspace, it will be shown on top of
the workspace apps.</p>
<p dir="auto">I consider this as a desired behavior because it allows you to quickly access other
apps without glitches or switching between workspaces.</p>
<p dir="auto">This is a common issue with tiling window managers that they often cause glitches
when a small pop-up window is shown or some unexpected app is opened.</p>
<p dir="auto">If you want to hide the new app, you can simply use the hotkey again.</p>
<p dir="auto"><h2 tabindex="-1" dir="auto">🖥️ SketchyBar Integration</h2><a id="user-content-️-sketchybar-integration" aria-label="Permalink: 🖥️ SketchyBar Integration" href="#️-sketchybar-integration"></a></p>
<p dir="auto">FlashSpace can be integrated with <a href="https://github.com/FelixKratz/SketchyBar">SketchyBar</a> and other tools. The app runs a
configurable script when the workspace is changed.</p>
<p dir="auto">You can enable the integration in the app settings.</p>
<details>
  <summary>Configuration Example</summary>
<p dir="auto"><h3 tabindex="-1" dir="auto">Only Active Workspace</h3><a id="user-content-only-active-workspace" aria-label="Permalink: Only Active Workspace" href="#only-active-workspace"></a></p>
<p dir="auto"><h5 tabindex="-1" dir="auto"><code>sketchybarrc</code></h5><a id="user-content-sketchybarrc" aria-label="Permalink: sketchybarrc" href="#sketchybarrc"></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="sketchybar --add item flashspace left \
  --set flashspace \
  background.color=0x22ffffff \
  background.corner_radius=5 \
  label.padding_left=5 \
  label.padding_right=5 \
  script=&quot;$CONFIG_DIR/plugins/flashspace.sh&quot; \
  --add event flashspace_workspace_change \
  --subscribe flashspace flashspace_workspace_change"><pre>sketchybar --add item flashspace left \
  --set flashspace \
  background.color=0x22ffffff \
  background.corner_radius=5 \
  label.padding_left=5 \
  label.padding_right=5 \
  script=<span><span>"</span><span>$CONFIG_DIR</span>/plugins/flashspace.sh<span>"</span></span> \
  --add event flashspace_workspace_change \
  --subscribe flashspace flashspace_workspace_change</pre></div>
<p dir="auto"><h5 tabindex="-1" dir="auto"><code>plugins/flashspace.sh</code></h5><a id="user-content-pluginsflashspacesh" aria-label="Permalink: plugins/flashspace.sh" href="#pluginsflashspacesh"></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="#!/bin/bash

sketchybar --set $NAME label=&quot;$WORKSPACE - $DISPLAY&quot;"><pre><span><span>#!</span>/bin/bash</span>

sketchybar --set <span>$NAME</span> label=<span><span>"</span><span>$WORKSPACE</span> - <span>$DISPLAY</span><span>"</span></span></pre></div>
<p dir="auto"><h3 tabindex="-1" dir="auto">All Workspaces</h3><a id="user-content-all-workspaces" aria-label="Permalink: All Workspaces" href="#all-workspaces"></a></p>
<p dir="auto"><h5 tabindex="-1" dir="auto"><code>sketchybarrc</code></h5><a id="user-content-sketchybarrc-1" aria-label="Permalink: sketchybarrc" href="#sketchybarrc-1"></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="sketchybar --add event flashspace_workspace_change

SID=1
SELECTED_PROFILE_ID=$(jq -r &quot;.selectedProfileId&quot; ~/.config/flashspace/profiles.json)
WORKSPACES=$(jq -r --arg id &quot;$SELECTED_PROFILE_ID&quot; 'first(.profiles[] | select(.id == $id)) | .workspaces[].name' ~/.config/flashspace/profiles.json)

for workspace in $WORKSPACES; do
  sketchybar --add item flashspace.$SID left \
    --subscribe flashspace.$SID flashspace_workspace_change \
    --set flashspace.$SID \
    background.color=0x22ffffff \
    background.corner_radius=5 \
    background.padding_left=5 \
    label.padding_left=5 \
    label.padding_right=5 \
    label=&quot;$workspace&quot; \
    script=&quot;$CONFIG_DIR/plugins/flashspace.sh $workspace&quot;

  SID=$((SID + 1))
done"><pre>sketchybar --add event flashspace_workspace_change

SID=1
SELECTED_PROFILE_ID=<span><span>$(</span>jq -r <span><span>"</span>.selectedProfileId<span>"</span></span> <span>~</span>/.config/flashspace/profiles.json<span>)</span></span>
WORKSPACES=<span><span>$(</span>jq -r --arg id <span><span>"</span><span>$SELECTED_PROFILE_ID</span><span>"</span></span> <span><span>'</span>first(.profiles[] | select(.id == $id)) | .workspaces[].name<span>'</span></span> <span>~</span>/.config/flashspace/profiles.json<span>)</span></span>

<span>for</span> <span>workspace</span> <span>in</span> <span>$WORKSPACES</span><span>;</span> <span>do</span>
  sketchybar --add item flashspace.<span>$SID</span> left \
    --subscribe flashspace.<span>$SID</span> flashspace_workspace_change \
    --set flashspace.<span>$SID</span> \
    background.color=0x22ffffff \
    background.corner_radius=5 \
    background.padding_left=5 \
    label.padding_left=5 \
    label.padding_right=5 \
    label=<span><span>"</span><span>$workspace</span><span>"</span></span> \
    script=<span><span>"</span><span>$CONFIG_DIR</span>/plugins/flashspace.sh <span>$workspace</span><span>"</span></span>

  SID=<span><span>$((</span>SID <span>+</span> <span>1</span><span>))</span></span>
<span>done</span></pre></div>
<p dir="auto"><h5 tabindex="-1" dir="auto"><code>plugins/flashspace.sh</code></h5><a id="user-content-pluginsflashspacesh-1" aria-label="Permalink: plugins/flashspace.sh" href="#pluginsflashspacesh-1"></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="#!/bin/bash

if [ &quot;$1&quot; = &quot;$WORKSPACE&quot; ]; then
  sketchybar --set $NAME label.color=0xffff0000
else
  sketchybar --set $NAME label.color=0xffffffff
fi"><pre><span><span>#!</span>/bin/bash</span>

<span>if</span> [ <span><span>"</span><span>$1</span><span>"</span></span> <span>=</span> <span><span>"</span><span>$WORKSPACE</span><span>"</span></span> ]<span>;</span> <span>then</span>
  sketchybar --set <span>$NAME</span> label.color=0xffff0000
<span>else</span>
  sketchybar --set <span>$NAME</span> label.color=0xffffffff
<span>fi</span></pre></div>
</details>
<p dir="auto"><h2 tabindex="-1" dir="auto">🛠️ Build From Source</h2><a id="user-content-️-build-from-source" aria-label="Permalink: 🛠️ Build From Source" href="#️-build-from-source"></a></p>
<p dir="auto">FlashSpace uses <a href="https://github.com/yonaskolb/XcodeGen">XcodeGen</a> to generate the Xcode project from the <code>project.yml</code>
file.</p>
<ol dir="auto">
<li>Clone the repository.</li>
<li>Navigate to the project directory.</li>
<li>Run <code>brew bundle</code> to install dependencies.</li>
<li>Run <code>xcodegen generate</code>.</li>
<li>Open <code>FlashSpace.xcodeproj</code> in Xcode.</li>
<li>Click on the <code>FlashSpace</code> target, click on the <code>Signing &amp; Capabilities</code> tab,
and select your team.</li>
<li>Build &amp; run the app.</li>
</ol>
<p dir="auto">Remember to run <code>xcodegen generate</code> every time you change branch or pull changes.</p>
<p dir="auto">If you want to generate the project with configured signing, you can run:</p>
<div dir="auto" data-snippet-clipboard-copy-content="XCODE_DEVELOPMENT_TEAM=YOUR_TEAM_ID xcodegen generate"><pre>XCODE_DEVELOPMENT_TEAM=YOUR_TEAM_ID xcodegen generate</pre></div>
<p dir="auto">You can also set this variable globally in your shell.</p>
<p dir="auto"><h2 tabindex="-1" dir="auto">💛&nbsp;&nbsp;Sponsors</h2><a id="user-content-sponsors" aria-label="Permalink: 💛&nbsp;&nbsp;Sponsors" href="#sponsors"></a></p>
<p dir="auto">Big thanks to all the sponsors who support this project 🍻!</p>
<p dir="auto"><h3 tabindex="-1" dir="auto">Monthly Sponsors</h3><a id="user-content-monthly-sponsors" aria-label="Permalink: Monthly Sponsors" href="#monthly-sponsors"></a></p>
<p dir="auto"><a href="https://github.com/bjrmatos"><img src="https://avatars.githubusercontent.com/u/4262050" width="40" height="40" alt="@bjrmatos" title="bjrmatos"></a>
<a href="https://github.com/notlus"><img src="https://avatars.githubusercontent.com/u/828989" width="40" height="40" alt="@notlus" title="notlus"></a></p>
<p dir="auto"><h3 tabindex="-1" dir="auto">One Time Sponsors</h3><a id="user-content-one-time-sponsors" aria-label="Permalink: One Time Sponsors" href="#one-time-sponsors"></a></p>
<p dir="auto"><a href="https://github.com/danscheer"><img src="https://avatars.githubusercontent.com/u/56642865" width="40" height="40" alt="@danscheer" title="danscheer"></a></p>

</article></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Carbon is not a programming language (sort of) (113 pts)]]></title>
            <link>https://herecomesthemoon.net/2025/02/carbon-is-not-a-language/</link>
            <guid>42983733</guid>
            <pubDate>Sat, 08 Feb 2025 15:51:06 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://herecomesthemoon.net/2025/02/carbon-is-not-a-language/">https://herecomesthemoon.net/2025/02/carbon-is-not-a-language/</a>, See on <a href="https://news.ycombinator.com/item?id=42983733">Hacker News</a></p>
<div id="readability-page-1" class="page"><div>
      <article>
        <div id="content">
            <div>
              <figure data-imgstate="dither">
                <img alt="A rat. For reasons. The subtitle is a quote from Bjarne Stroustrup. Suffice to say, he was not thinking of Carbon when he uttered these words. At least since this quote is already thirty (30!!!) years old." data-dither="/2025/02/carbon-is-not-a-language/images/dithers/carbon-rat_dithered.png" data-original="https://herecomesthemoon.net/2025/02/carbon-is-not-a-language/images/carbon-rat_hu2175167256744885269.webp" loading="lazy" src="https://herecomesthemoon.net/2025/02/carbon-is-not-a-language/images/dithers/carbon-rat_dithered.png">
                <div>
                  <figcaption>
                    <span>
                      A rat. For reasons. The subtitle is a quote from Bjarne Stroustrup. Suffice to say, he was not
                      thinking of Carbon when he uttered these words. At least since this quote is already thirty
                      (30!!!) years old.
                    </span>
                    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                      <rect height="24.28" width="24.28" x="13.51" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="37.93" y="37.86"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="13.58"></rect>
                      <rect height="24.28" width="24.28" x="13.51" y="62.14"></rect>
                      <rect height="24.28" width="24.28" x="62.21" y="62.14"></rect>
                    </svg>
                    <p><span> Toggle original/dithered image </span>
                    </p>
                  </figcaption>
                </div>
              </figure>
            </div>
            <p>
              In case you’ve not heard of it, <strong>Carbon</strong> is Google’s experimental
              <a href="https://github.com/carbon-language/carbon-lang" target="_blank">open-source</a> “C++-successor
              language”. As a very rough first approximation, think Objective-C/Swift, Java/Kotlin, C/C++, C++/Carbon.
              It is also frequently mentioned in the same breath as Herb Sutter’s Cppfront and Sean Baxter’s Circle (and
              Rust, surprise surprise).
            </p>
            <p>
              Like with any ‘successor language’, the overall goal includes (at the bare minimum) near-seamless
              interoperability, as well as <em>significant</em> improvements over the original language.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>
              (Otherwise it can hardly be called a successor, duh.)
            </p>
            <p>
              If you’ve clicked on the article, you’re probably waiting for me to admit that I’m lying, and to tell you
              that (in fact) Carbon <em>is</em> a programming language.
            </p>
            <p>
              And yes, it’s true! Carbon is a programming language. (Or rather, it’s <em>aspiring</em> to be a
              programming language. Carbon is an experimental project and hasn’t hit its 0.1 release milestone yet. The
              Carbon developers are very transparent about this.)
            </p>
            <p>
              But in my humble opinion, thinking of Carbon as a ‘programming language’ is kind of missing the point. Let
              me tell you how I think about Carbon, and why I think that it’s more interesting than most people give it
              credit for:
            </p>
            <blockquote>
              <p>
                Carbon is a concentrated experimental effort to develop tooling that will facilitate automated
                large-scale long-term migrations of existing C++ code to a modern, well-annotated programming language
                with a modern, transparent process of evolution and governance model.
              </p>
            </blockquote>
            <p>
              The entirety of Carbon (the language, as well as the project) is built around making this goal possible.
              (Disclaimer, I don’t speak for Carbon, take my words with a grain of salt.)
            </p>
            <h2 id="why">Why?</h2>
            <p>In this post, I want to convince you of the following points:</p>
            <ol>
              <li>
                Carbon is a project to investigate the possibility of a large-scale reduction of C++ technical debt via
                automated code migration.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>
              </li>
              <li>
                Many so-called ‘successor languages’ are <em>nothing like this</em>. They don’t make
                <em>automated code migration</em> an explicit goal, and generally build a layer of abstraction on top of
                or rely on their host language.
              </li>
              <li>
                All of this is downstream of Google’s disagreements with the C++ Standard Committee. In fact, while all
                of this is about reducing technical debt, it’s also about reducing the organizational costs involved in
                having to coordinate migrations and language evolution with the committee.
              </li>
              <li>Developing a new programming language is probably necessary to achieve the goals of the project.</li>
            </ol>
            <p>
              I’d like to bring special attention to the point about governance: This isn’t just a technical issue. It’s
              a governance issue. It’s a “We just straight-up disagree on the future direction of the C++ programming
              language.” sort of issue. I already went over these cultural disagreements in
              <a href="https://herecomesthemoon.net/2024/11/two-factions-of-cpp/" target="_blank">a previous post</a>.
            </p>
            <p>
              (The astute reader will note that you can evolve and govern your own programming language however you
              want, without needing to deal with WG21 (aka the C++ Standard Committee, aka the authority that decides
              what C++ <em>is</em><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.))
            </p>
            <p>
              At this point I’d <em>love</em> to reach for the Herb Sutter “We must minimize the need to change existing
              code.” quote<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> again,
              but I’ll instead just state the obvious:
            </p>
            <p>
              A large-scale migration to a different programming language is <em>the opposite</em> paradigm. As far as
              changes to existing code go, it’s uncompromising. It’s an approach that’s only going to work for a subset
              of people, and in fact,
              <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md#legacy-compiled-libraries-without-source-code-or-ability-to-rebuild" target="_blank">Carbon’s goal document</a>
              lists “We consider it a non-goal to support legacy code for which the source code is no longer available”.
            </p>
            <p>
              In other words, the language is not for everyone. That’s fine! I am still very interested in it. I care
              about Carbon since I believe that it’s trying to solve the hardest problem C++ is currently facing.
            </p>
            <p>
              This isn’t any <em>single</em> technical issue (there are many, many of those), no, and it’s not even a
              broad concern such as memory safety.
            </p>
            <p>
              It’s the problem of C++ slowly calcifying and struggling to modernize. It’s about ABI, about dozens of
              tools but no agreed upon standards, and it’s about backwards compatibility. It’s about allowing existing
              C++ code to <em>evolve</em>, modernize and change, in spite of decades of technical debt, multiple
              implementations, and many different users with different expectations and requirements.
            </p>
            <p>This is, in other words, an <em>incredibly hard problem</em>, and a <em>long-term project</em>.</p>
            <p>
              If you believe that certain multi-million line C++ codebases are still going to exist in twenty years,
              <em>then you should understand the business case for Carbon</em>.
            </p>
            <h3 id="a-short-lesson-in-history">A short lesson in history</h3>
            <p>
              Let’s briefly summarize the backstory for those who haven’t kept track. You could (very roughly) say that
              Google is developing Carbon due to conflicts with WG21, and disagreements about the future of the C++
              language.
            </p>
            <p>
              What matters is that Google contributed to WG21 for many years, and that it has a vested interest in the
              future of the language, due to owning many, <em>many</em> million lines of C++ code. It’s hard to
              overstate how critical C++ is for Google’s infrastructure, and for modern technology in general.
            </p>
            <p>
              The short summary is that Google’s developers (not just Google’s, mind you) disagreed with other parts of
              the committee about the
              <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2137r0.html" target="_blank">future direction of the C++ language</a>. There are a lot of reasons for this, and
              <a href="https://cor3ntin.github.io/posts/abi/" target="_blank">a lot of ink</a> has been spilled on the
              topic. Eventually, after trying to work with WG21 for many years, Google basically threw in the towel.
              (You cannot blame them. They tried hard, and the WG21 process is notoriously slow and frustrating.)
            </p>
            <p>
              At this point, a lot of people might think that the core disagreement between Google and WG21 was about
              ‘memory safety’, or something like that.
            </p>
            <p>It wasn’t!</p>
            <p>
              The current memory safety hype is a pretty big deal for C++, but the ball was already rolling several
              years ago. All of this started with concerns about C++’s complexity<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>
              and <em>performance</em>.<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>
              It turns out that fixing certain issues would require backwards incompatible changes (bad!). Coordinating
              this across the entire C++ ecosystem would be more or less impossible.
            </p>
            <p>
              I’ll not get into the details and instead point at Chandler Carruth’s
              <a href="https://youtu.be/rHIkrotSwcc?t=1599" target="_blank">‘There are no zero-cost abstractions’</a>
              for an example: It pins down how first of all, <code>std::unique_ptr</code> has a runtime overhead, and
              second of all, how fixing this would require an ABI-break and a language change.
            </p>
            <p>
              (That doesn’t mean Google doesn’t care about memory safety, of course. They do. But memory safety isn’t
              what started the whole conflict, even though it’s currently carrying the torch. That’s why memory safety
              is still relevant to all of this, especially since making C++ memory safe without compromising the vision
              of the standard committee looks more or less impossible.)
            </p>
            <h2 id="migration--language-evolution">Migration &amp; Language Evolution</h2>
            <p>
              First of all, that Carbon has <em>automated code migration</em> as one of its goals should be clear. The
              Carbon people are
              <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code" target="_blank">very explicit about this</a>. It’s also a common theme in
              <a href="https://youtu.be/omrY53kbVoA?t=634" target="_blank">their talks</a>.
            </p>
            <p>
              This is, first and foremost, about moving <em>away</em> from the “We mustn’t break existing code, so we
              had to squeeze in this new feature/syntax in some awkward way <em>somehow</em>.” approach to language
              evolution. (<code>co_await</code> and the (proposed) reflection operator (<code>^^</code>) are sending
              their regards.<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>)
            </p>
            <p>
              This approach to language evolution kind of sucks. It’s not like the committee doesn’t
              <em>understand</em> the problem, or doesn’t <em>want</em> to evolve the language. The committee is not
              evil, and it’s not your enemy. C++ is just incredibly hard to evolve for all sorts of reasons, which would
              honestly justify an article on their own (ABI, multiple implementations and the committee process, no
              unified ecosystem, no editions or epochs system, no unified migration tooling, widespread dynamic linking,
              etc.)
            </p>
            <p>Carbon’s goal is to move away from that.</p>
            <p>
              How? Via automated tooling, a well-defined process of language evolution with clear guarantees, etc.
              Carbon is still highly experimental, so the details are still WIP. If I had to guess, I’d say they’re
              planning to follow in the footsteps of other modern languages. As an example, consider how Rust manages:
            </p>
            <ul>
              <li>
                Have a new ’edition’ every three years or so. Each edition is allowed to make certain breaking changes,
                but modules from separate editions can be compiled and linked together.
              </li>
              <li>
                Ship automated migration tooling with the language, which allows an automatic migration of code to the
                new edition whenever possible.
              </li>
              <li>
                If you want to eg. introduce a new keyword, you <em>reserve</em> it one edition ahead of time.
                <a href="https://doc.rust-lang.org/book/appendix-01-keywords.html#raw-identifiers" target="_blank">Raw Identifier syntax</a>
                allows migration and use of old code that still uses this keyword as an identifier.
              </li>
            </ul>
            <p>In contrast to this, I don’t think there’s any feasible roadmap to get C++ to this state.</p>
            <p>It’s only possible with an ecosystem split, and that’s exactly the point.</p>
            <p>
              Let me reiterate this. If there’s one thing you take from this article, it’s this here: The
              <em>point of Carbon</em> is to make it possible to take existing C++ code and to put it onto a path
              towards a modern, well-defined process for future evolution and changes.
            </p>
            <p>
              This is the point. If you want to be cynical, it’s about cutting the dependency on the standard committee,
              and it’s about allowing any forwards-looking, backwards-incompatible changes <em>at all</em>, without
              having to worry about someone else’s ancient binaries from the 80s.
            </p>
            <h2 id="c-c-cpp2">C, C++, Cpp2</h2>
            <p>
              I just want to make clear that I believe that Carbon is radically different from
              <a href="https://hsutter.github.io/cppfront/" target="_blank">Cpp2</a> (ie. Herb Sutter’s experimental
              project to evolve C++).
            </p>
            <p>
              The major difference is that Cpp2 tries to leverage the existing C++ language to its full extent, while
              Carbon tries to minimize its dependency on C++ wherever possible.
            </p>
            <p>
              Cpp2 takes the same approach C++ originally did: It transpiles its own code to the host language, and is
              thus deeply and intrinsically linked to it. It reuses the C++ standard library with all of its problems,
              it aims to maintain the C++ ecosystem instead of splitting it.
            </p>
            <p>
              Perhaps most importantly, Cpp2 also cannot go <em>lower</em> than C++: It cannot directly interface with
              the compiler, since it’s written to be used by “any standard-compliant C++20 compiler”.
            </p>
            <p>
              It should be obvious that it’s basically impossible for Cpp2 to make meaningful reductions to C++’s
              technical debt. Yes, it can be “C++, except with better defaults and syntax.”, but that’s all it can
              feasibly be as long as full backwards compatibility is an explicit goal. Reducing C++’s technical debt on
              a deeper level is <em>completely out of scope</em> for Cpp2.
            </p>
            <p>
              It <em>can</em> reduce the number of ways there are to initialize objects by simplifying syntax. It
              <em>cannot</em> make any changes that would require an ABI-break, it cannot add null-safety to the
              language (eg. <code>unique_ptr</code> can still be null, <code>variant</code> can still be valueless), and
              it can’t prevent your code from blowing up in exciting ways due to lifetime issues.<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>
              Carbon has the advantage that it <em>can</em> make these changes. (eg. Carbon is planning to move away
              from exceptions, in favor of treating errors as values.)
            </p>
            <p>
              Just to be clear, this is fine! I am not saying Cpp2 is bad, and I’m curious to see how the project
              develops. I am just highlighting that Carbon and Cpp2 are <em>completely different projects</em> with
              completely different scopes and goals.
            </p>
            <p>
              It is written by Herb Sutter, someone who very clearly <em>loves</em> C++ as it is, and who wants to make
              it easier to use. It’s about having a new syntax, and making it <em>trivial</em> to apply best practices
              to your C++ code.
            </p>
            <p>
              This is a great idea, and a much less invasive proposal than Carbon. Carbon isn’t that. Carbon is about
              <em>reworking the language from the ground up</em>. It’s about building a <em>new</em> language that can
              support almost all of the same semantics, but is still critically different. It’s about reworking the
              fundamentals, and building stronger abstractions.
            </p>
            <p>
              So in short, Cpp2 works <em>with</em> C++, and Carbon is trying to <em>recreate</em> a better C++ from
              scratch, while cutting its dependency on C++ almost completely.
            </p>
            <h2 id="technical-feasibility">Technical feasibility</h2>
            <p>
              Is Carbon feasible? I’ll be honest, I have no clue. C++ code is <em>really complicated</em><sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> and this project is
              (more or less) unprecedented. (Which is, again, why I am interested in it.)
            </p>
            <p>The reasons why I believe it <em>might</em> be technically feasible at all are simple:</p>
            <ol>
              <li>
                Carbon doesn’t attempt to do the impossible: The goal is a tool-assisted migration of idiomatic code,
                not a fully automated migration of <em>all</em> code. (What does ‘idiomatic’ mean? Who knows. Probably
                something like ‘well-annotated and easy to handle for static analyzers’. Figuring out how to draw the
                boundary of which code can be migrated is part of the project.)
              </li>
              <li>
                Carbon is capable of leveraging its underlying tooling to do a <em>lot</em> of the hard work. For
                example, resolving C++ templates and function calls is handled by Clang and LLVM. This should not be
                much of a surprise. Clang can be used as a library, and this is exactly what you’d expect it to excel
                at. (Swift is
                <a href="https://www.swift.org/documentation/cxx-interop/status/" target="_blank">already doing this for its C++ interop</a>.)
              </li>
              <li>
                Carbon already demonstrated that its chosen abstractions are capable of supporting some pretty “fun” C++
                features.
              </li>
            </ol>
            <p>Let me quickly substantiate some of that.</p>
            <h3 id="testing">Testing</h3>
            <p>
              So, here’s the thing. Carbon can
              <em>convert your C++ to Carbon and then run it against the old test suite</em>. (Or that’s the plan, at
              least.)
            </p>
            <p>(You do have a test suite, right?)</p>
            <p>
              If the code compiles and all tests pass, this should give you confidence in the resulting code
              proportional to your confidence in your own test suite. (This is especially helpful for changes
              <em>past</em> the initial automated migration, even if it’s just clean-up work.)
            </p>
            <p>This approach is <em>really nice</em> for all sorts of reasons.</p>
            <p>
              First of all, it means that Carbon can leverage
              <em>existing C++ test suites to test its own migration and interop capabilities</em>. This is great.
            </p>
            <p>
              Second of all, it puts <em>some</em> burden on the user and sets a minimal bar for what Carbon means with
              ‘migration of idiomatic C++’: You should <em>probably</em> have some tests in your code. If you critically
              depend on something, then you should have a test for it.
            </p>
            <h3 id="generalization-and-unification-of-c-features">Generalization and unification of C++ features</h3>
            <p>
              So.
              <a href="https://en.cppreference.com/w/cpp/language/operator_member_access" target="_blank">Member access operators</a>. This example is shamelessly lifted from
              <a href="https://youtu.be/8SGMy9ENGz8?t=1862" target="_blank">‘How Designing Carbon C++ Interop Taught me About C++ Variadics &amp; Bound Members’</a>:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;string&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>class</span> <span>Foo</span> {
</span></span><span><span>  <span>public</span><span>:</span> std<span>::</span>string a;
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>  std<span>::</span>string Foo<span>::*</span> pm <span>=</span> <span>&amp;</span>Foo<span>::</span>a; <span>// defines a "pointer" to the member of Foo
</span></span></span><span><span><span></span>
</span></span><span><span>  Foo foo{};                       <span>// define foo of type Foo
</span></span></span><span><span><span></span>
</span></span><span><span>  std<span>::</span>string _ <span>=</span> foo.<span>*</span>pm;         <span>// access field a of foo
</span></span></span><span><span><span></span>}
</span></span></code></pre>
            </div>
            <p>
              If you have no idea what you’re looking at: This is legal C++. Calling <code>pm</code> a ‘pointer’ is a
              stretch, in practice it is just an <em>offset</em> relative to the location of an object of this class in
              memory.
            </p>
            <p>
              Two funfacts: First, this can also be used to refer to methods. Second, this value can be null, and it’s
              null-value is <code>-1</code>, since <code>0</code> would point to an actual field.
            </p>
            <p>Fun, isn’t it?</p>
            <p>
              When I see a feature like this, my first question would be whether Carbon is even capable of
              <em>modeling</em> this specific type of behavior, and it turns out that, yes, they have thought about
              this.
            </p>
            <p>
              Carbon is building <em>literally everything</em> on top of <code>interfaces</code> (which can broadly be
              understood as C++0x Concepts or Rust traits).
            </p>
            <p>
              There’s a simple reason for that: Carbon wants to support <em>definition-site</em> checked generics
              (roughly, you’ll know that a generic function can be instantiated without having to look into the body of
              the function. This is not the case for templates.) As a consequence, <em>every possible thing</em> which
              you can “do” with a value needs to be implemented as an interface, so that you can specify that an
              incoming value fulfills this constraint.
            </p>
            <p>
              Consequently, <em>member access pointers</em> are implemented via a so-called
              <code>BindToValue</code> interface, which (as far as I can tell) generalizes expressions of the form
              <code>x.y</code>, whether <code>y</code> is a field, a static member function, a method, a member access
              pointer, or who knows what else. Any <code>y</code> which implements <code>BindToValue(X)</code> (where
              <code>X</code> is the class of <code>x</code>) can be used as <code>x.y</code>.
            </p>
            <p>
              The pattern of unifying abstractions as interfaces gets used a lot: It turns out that deep within Carbon,
              function calls are implemented as a synthesized type which implements some <code>Call</code> interface.
              This is used to unify functions, methods, lambdas, etc. Every single thing in Carbon which you can “call”
              is just some value implementing the <code>Call</code> interface.
            </p>
            <p>
              Sorry, I’m basically just rehashing parts of Chandler Carruth’s (highly technical) talk here. For the full
              picture, please just go and watch it. He’s a great speaker, and I don’t trust myself to get every
              technical detail right.
            </p>
            <p>
              The point is, if you’re wondering what the Carbon people are working on, then it’s this kind of stuff.
              They’re building <em>foundations</em> which are general enough to to make all sorts of gnarly C++
              semantics (eg. member access pointers) work, but have a <em>much</em> simpler underlying model. (eg. it
              unifies everything that can be called, <em>and</em> gives you the ‘concept’/interface for free).
            </p>
            <p>
              Is this going to work for the rest of the language? Who knows! C++ is complicated, probably too
              complicated to manage. That’s the whole reason why Carbon even exists.
            </p>
            <h3 id="digression-why-not-rust-why-not-c">Digression: Why not Rust™? Why not C++?</h3>
            <p>
              Rust is really just too different for an automated conversion of C++ code to Rust code to be feasible,
              it’s as simple as that. I even
              <a href="https://herecomesthemoon.net/2025/01/type-inference-in-rust-and-cpp/" target="_blank">wrote an article</a>
              getting into the differences in type inference alone.
            </p>
            <p>
              You have no class inheritance, no templates, no specialization, no ad-hoc function overloads, no implicit
              conversions, and there’s still the whole deal with the borrow checker. Any conversion of modern
              general-purpose C++ code to Rust basically amounts to a rewrite, which is just not something you can do
              with classic automation tooling.
            </p>
            <p>
              Carbon has the luxury of being able to support both templates <em>and</em> checked generics (ie. something
              like Rust traits or C++0x concepts), and a way to migrate between them.
            </p>
            <p>
              As for a C++-to-more-modern-C++-migration, it just doesn’t solve the question of language evolution.
              You’re still heavily limited by what you can do, unless you also commit to a proper fork of C++ and
              possibly Clang.
            </p>
            <p>
              Which…might be viable, but makes it much harder to implement clean abstractions from the get-go. It also
              doesn’t help that a fork runs a pretty severe risk of being ‘usable’ right from the get-go (meaning that
              people will want to use it, and the boundary between C++ and Carbon will be muddier).
            </p>
            <h2 id="governance">Governance</h2>
            <p>
              As I said, Carbon is a moonshot project to allow modern C++ codebases to evolve. (They might stop being
              called “C++” in the process, but that’s probably fine. The only constant in life is change, or something
              like that.)
            </p>
            <p>
              The north star goal is, of course, that of a gradual but mostly automated migration of existing C++ code
              to Carbon code, followed by <em>additional</em> migrations to fix and improve this code using Carbon’s
              modern, more powerful semantics (eg. null safety).
            </p>
            <p>
              From this angle, and with the historical background in mind, let’s address the elephant in the room<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup>
              and take a stab at describing how some people feel about Carbon, by rephrasing my interpretation of its
              goals in the most cynical way possible. I’m deeply sorry to anyone who’s working on Carbon, since this is
              going to feel like I’m twisting a proverbial knife:
            </p>
            <blockquote>
              <p>
                Carbon’s primary goal is a large-scale migration of Google’s enormous pile of (highly specific,
                exception-less, Abseil and Protobuf-using, Clang-based, Bazel-built) C++ technical debt into a modern
                language capable of supporting Google’s needs, and
                <em>over whose governance Google is capable of exerting a significant amount of control.</em>
              </p>
            </blockquote>
            <p>
              There we go.<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup> Do
              you see the elephant yet?
            </p>
            <p>
              It’s pretty hard to miss since I highlighted it. (Sorry, I know that it’s the second time I made that
              joke.)
            </p>
            <p>
              This is about the least charitable way to phrase it, of course. I’m bringing this up for the obvious
              reasons: Carbon is spearheaded by a big tech company, and people have various concerns.
            </p>
            <p>
              These include the concern that Google trying to ’take control’ of C++ via a divide-and-conquer approach,
              that Carbon will favor Google’s style of C++ at the expense of others, and the classic sentiment that
              Carbon will eventually be abandoned and dropped (potentially hanging early adopters out in the dry).
            </p>
            <p>
              As I already gestured at before, all of this is about <em>trust</em>, and by extension about governance.
            </p>
            <p>
              As long as we’re willing to say that Carbon is about reducing the reliance on the C++ Standard Committee,
              it’s pretty clear that that governance-shaped hole has to be filled <em>somehow</em>, and that someone (or
              some group of people) has to decide the future direction of the language.
            </p>
            <p>
              I’ll be honest, I can make no guarantees here. I am not working on Carbon<sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup>, and the dynamics here are far beyond my scope.
            </p>
            <p>
              I can point out that Carbon is an Apache-licensed open source project,
              <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/CONTRIBUTING.md" target="_blank">open for contributors right now</a>, and that it has an explicit “The intent is that […] Carbon remains a community-driven project, avoiding
              situations where any single organization controls Carbon’s direction.”
              <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/faq.md#how-does-carbon-make-decisions" target="_blank">disclaimer</a>
              in its FAQ, but that’s not going to convince you if you’re worried about bad intentions.
            </p>
            <p>
              So. What I <em>can</em> tell you is that I believe that putting governance of the language into the hands
              of the open-source community is critical for Carbon’s long-term success, and that Carbon’s developers
              understand this.
            </p>
            <p>
              Whether Carbon will find widespread adoption depends on whether <em>established corporations</em> trust
              Carbon’s stewards to handle the language with enough responsibility that migrating their own C++ code to
              Carbon seems like a safe offer.
            </p>
            <p>
              This sort of trust is hard to establish as long as there’s a single owner, <em>especially</em> if that
              owner is Google.
            </p>
            <p>
              Second: That Carbon finds any public adoption at all is also pretty important <em>even if</em> the primary
              goal was just to use it purely within Google. This might come as a surprise, but it’s pretty simple:
              People who’re expected to use Carbon first need to learn Carbon. This is <em>significantly</em> easier
              when Google can rely on a broad ecosystem of tutorials, libraries and discussion boards outside of its
              intranet.
            </p>
            <p>
              So in other words, for Carbon to become successful, it’s critical that there’s a public community, and
              that enterprise users of C++ <em>trust</em> Carbon.
            </p>
            <p>These are huge incentives to push the language towards independent community ownership.</p>
            <p>
              Both of these points (trust by enterprise users and need for a public community) were
              <em>much less important</em> for <a href="https://go.dev/" target="_blank">Go</a> (which was also
              spearheaded by Google), primarily due to Go’s simplicity, the fact that there was far less competition in
              the programming language space when Go released, and the fact that it was a language for greenfield
              projects. (That is, it didn’t require convincing ancient C++ coders to perform a massive migration and
              rework their tool chain.)
            </p>
            <p>
              My understanding is that
              <a href="https://news.ycombinator.com/item?id=32153320" target="_blank">Carbon’s leads understand all of this</a>, and want the project to be community driven. For now, that’s more than good enough for me. For a
              project this early in its life-cycle, it’s nice to see that they’re thinking about this at all, and have
              made an explicit commitment to community ownership.
            </p>
            <h2 id="conclusion-there-is-no-free-lunch">Conclusion: There is no free lunch.</h2>
            <p>
              The prospect of building a <em>successor</em> to C++—arguably single most important programming language
              currently in existence—sounds like it should be doomed to fail.
            </p>
            <p>
              I’ll repeat what I said before, and what should be common knowledge: C++ is an incredibly complex
              programming language. It’s under-annotated, has multiple implementations (governed by a 2000+ page ISO
              Standard document), carries four decades of technical baggage, is full of undefined behavior, and has a
              frequently abused Turing-complete quasi-code-generation meta-programming language built into it.
            </p>
            <p>
              All of that should make it near impossible to succeed C++. Complexity is in fact a form of job security.
              So why am I still relatively confident in Carbon’s potential?
            </p>
            <p>Simple, it’s mainly since the priorities look correct to me. Carbon understands that</p>
            <ol>
              <li>
                C++’s inability to evolve, modernize, deprecate, migrate and standardize is <em>the</em> critical issue
                which the language is facing today.<sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup>
              </li>
              <li>
                You cannot improve on this without making concessions. This goes both ways: There is old C++ code which
                you will not be able to support. At the same time, there are C++ features which you <em>have</em> to
                support, whether you want to or not.
              </li>
              <li>
                This is a herculean task that requires a massive initial investment (a whole new programming language),
                and a complete rethinking of tooling, communication, software engineering and language development
                practices.
              </li>
            </ol>
            <p>
              The inability to evolve is an issue for people who’re just starting to learn C++, and who stumble into
              every single footgun that hasn’t been taken care of over the past thirty years.
            </p>
            <p>
              It’s an issue for people who care for high-quality code, readability or memory safety, and see no viable
              path towards getting their C++ codebase into that state.
            </p>
            <p>
              It’s an issue for <em>committee and compiler contributors</em>, who need to carefully consider how a new
              feature will interact with <em>literally everything else</em> the language already supports.
            </p>
            <p>
              You might disagree with that assessment. It might not be an issue <em>for you personally</em>. That’s
              fine. C++ (for a given version, anyway) will stay exactly as it is. It’s not going to go away anytime
              soon, and that’s a good thing. People depend on that. Critical infrastructure depends on that.
            </p>
            <p>
              As for myself, I am incredibly glad to see that <em>someone</em> is trying to take this bull by the horns,
              and willing to face this charging billion lines-of-code mountain of complexity and technical debt head-on.
            </p>
            <p>
              At last but not at least just since it would be <em>really freaking cool</em> if we (humanity, as a whole)
              could actually pull it off, and don’t need to pass tales warning people about the dangers of using
              <code>std::vector&lt;bool&gt;</code> across the generations.
            </p>
            <p>
              It might take a while, but that’s fine. This is a long-term project. It <em>has</em> to be a long-term
              project to make this work. Once you start thinking about it from that perspective, everything makes a lot
              more sense.
            </p>
            <p>
              Remember, those millions of lines of C++ code are not going to go away anytime soon. They’ll still be
              there in a few decades. It’s either a large-scale migration (in some form or another), or nothing.
            </p>
            <p>
              In the meantime, if you’re remotely interested, I’ll reiterate that I highly recommend Carbon’s talks, eg.
              <a href="https://youtu.be/bBvLmDJrzvI" target="_blank">this one</a>.
            </p>
            <h3 id="addendum">Addendum</h3>
            <p>
              Writing this took significantly longer than expected. The total number of footnotes written and deleted is
              about forty.
            </p>
            <p>Let me know if you got something out of it—It means a lot to me.</p>
            <p>
              Questions, suggestions, comments, writing advice, reading recommendations, music suggestions, pictures of
              pets and basically anything else you can think of are all welcome via my contact e-mail at the bottom of
              the page.
            </p>
          </div>
        
      </article>
    </div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[The Deck: An open-source cross-platform multiplayer card game engine in Flutter (201 pts)]]></title>
            <link>https://github.com/xajik/thedeck</link>
            <guid>42983699</guid>
            <pubDate>Sat, 08 Feb 2025 15:47:36 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://github.com/xajik/thedeck">https://github.com/xajik/thedeck</a>, See on <a href="https://news.ycombinator.com/item?id=42983699">Hacker News</a></p>
<div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/xajik/thedeck/blob/main/demo/icon.png"><img src="https://github.com/xajik/thedeck/raw/main/demo/icon.png" alt="alt text"></a></p> 
<span>
    <p dir="auto"><h2 tabindex="-1" dir="auto"> The Deck</h2><a id="user-content--the-deck" aria-label="Permalink:  The Deck" href="#-the-deck"></a></p>
</span>
<p dir="auto"><b>🕹️ Mobile multiplayer offline card games aggregator 🚀</b>
<b>👨‍💻 Written 💯 in Dart and Flutter 🔨</b></p>
<p dir="auto"><i>The inspiration for “The Deck” came from a situation many of us have experienced. Imagine gathering with friends for a game night, only to realize that nobody has the necessary cards. Frustrating, right? This dilemma sparked the idea of leveraging technology to create a solution.</i></p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/xajik/thedeck/blob/main/demo/6.jpg"><img src="https://github.com/xajik/thedeck/raw/main/demo/6.jpg" alt="alt text"></a>
</p>
<p dir="auto">The primary goal of “The Deck” is to provide a user-friendly and cooperative digital game environment for playing classic games that were usually played with cards on paper. One of the standout features of “The Deck” is its unique ability to assign one device as the “table” (a.k.a. deck). By placing this device in the middle of the group, all players can witness the real-time state of the cards. This adds a new level of immersion making it a truly captivating experience.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/xajik/thedeck/blob/main/demo/2.jpg"><img src="https://github.com/xajik/thedeck/raw/main/demo/2.jpg" alt="alt text"></a>
</p>
<p dir="auto"><h2 tabindex="-1" dir="auto">Read more</h2><a id="user-content-read-more" aria-label="Permalink: Read more" href="#read-more"></a></p>
<ul dir="auto">
<li>
<p dir="auto"><b> ⚙️ How it works 👀: </b></p>
<ul dir="auto">
<li><a href="https://igorsteblii.com/thedeck/" rel="nofollow">Game Night Just Got a Digital Upgrade: The Deck</a></li>
<li><a href="https://dev.to/ilbets/game-night-just-got-a-digital-upgrade-the-deck-67p" rel="nofollow">Dev.to</a></li>
<li><a href="https://medium.com/@igorsteblii/game-night-just-got-a-digital-upgrade-the-deck-unique-cooperative-game-simulator-98e9db13c0f6" rel="nofollow">Medium</a></li>
<li>PlantUML diagrams here - <a href="https://github.com/xajik/thedeck/blob/main/documentation">/documentation</a></li>
</ul>
</li>
<li>
<p dir="auto"><a href="https://getthedeck.com/" rel="nofollow">getthedeck.com</a></p>
</li>
<li>
<p dir="auto"><a href="https://www.producthunt.com/products/the-deck#the-deck" rel="nofollow">ProductHunt</a></p>
</li>
<li>
<p dir="auto">🍎 <a href="https://apps.apple.com/us/app/the-deck-play/id6448377728" rel="nofollow">AppStore</a></p>
</li>
<li>
<p dir="auto">🤖 <a href="https://play.google.com/store/apps/details?id=com.thedeck.app" rel="nofollow">PlayStore</a></p>
<ul dir="auto">
<li><a href="https://play.google.com/apps/testing/com.thedeck.app" rel="nofollow">PlayStore Web</a></li>
</ul>
</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">Contribute</h2><a id="user-content-contribute" aria-label="Permalink: Contribute" href="#contribute"></a></p>
<p dir="auto">Contribution is welcome 🤝</p>
<p dir="auto"><b>If you contributed and build a new Game, ping me if you wish it to be released on the store markets.</b>
<a href="mailto:me@getthedeck.com">me@getthedeck.com</a></p>
<p dir="auto"><h2 tabindex="-1" dir="auto">Flutter</h2><a id="user-content-flutter" aria-label="Permalink: Flutter" href="#flutter"></a></p>
<p dir="auto"><h2 tabindex="-1" dir="auto">Setup</h2><a id="user-content-setup" aria-label="Permalink: Setup" href="#setup"></a></p>
<p dir="auto"><a href="https://fvm.app/docs/guides/faq/" rel="nofollow">Use FVM to manage Flutter SDK version</a></p>
<ul dir="auto">
<li>install <code>fvm</code> with <code>brew</code></li>
<li>Setup Flutter version from pubspec <code>fvm use x.y.z</code>
<ul dir="auto">
<li>Read version here: <a href="https://github.com/xajik/thedeck/blob/main/.fvmrc">fvmrc</a></li>
</ul>
</li>
<li>run with <code>fvm flutter run</code></li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">MR / Pull Request</h2><a id="user-content-mr--pull-request" aria-label="Permalink: MR / Pull Request" href="#mr--pull-request"></a></p>
<p dir="auto">Naming convention, start commit description with:</p>
<ul dir="auto">
<li>(FEAT) - feature</li>
<li>(FIX) - bug fix</li>
<li>(CHORE) - refactoring, updating dependencies, etc</li>
<li>(TEST) - tests</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">Release</h2><a id="user-content-release" aria-label="Permalink: Release" href="#release"></a></p>
<p dir="auto"><h3 tabindex="-1" dir="auto">Android</h3><a id="user-content-android" aria-label="Permalink: Android" href="#android"></a></p>
<ul dir="auto">
<li>For App Store release ⭐️
<ul dir="auto">
<li>fvm flutter build appbundle --release</li>
</ul>
</li>
<li>Fat APK with all ABI
<ul dir="auto">
<li>fvm flutter build apk --release</li>
<li>Upload file to Play store</li>
</ul>
</li>
<li>For split-abi APK testing
<ul dir="auto">
<li>fvm flutter build apk --release  --split-per-abi</li>
</ul>
</li>
</ul>
<p dir="auto"><h3 tabindex="-1" dir="auto">iOS</h3><a id="user-content-ios" aria-label="Permalink: iOS" href="#ios"></a></p>
<ul dir="auto">
<li>Archive for App store upload ⭐️
<ul dir="auto">
<li>fvm flutter build ipa --release</li>
<li>open file with Xcode, validate and upload</li>
</ul>
</li>
<li>IPA file to drag &amp; drop into iphone:
<ul dir="auto">
<li>fvm flutter build ipa --release  --export-options-plist="/Users/igor.steblii/Projects/foundation_tone/ft_fe/build/ios/archive/Runner.xcarchive/Info.plist"</li>
</ul>
</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">Common errors</h2><a id="user-content-common-errors" aria-label="Permalink: Common errors" href="#common-errors"></a></p>
<ul dir="auto">
<li>
<p dir="auto">In case VS code fail with missing Cocoapods</p>
</li>
<li>
<ul dir="auto">
<li>fvm flutter clean + fvm flutter pub get + Reload VSCode</li>
</ul>
</li>
<li>
<p dir="auto">For <code>normalize': Unicode Normalization not appropriate for ASCII-8BIT (Encoding::CompatibilityError)</code></p>
</li>
<li>
<p dir="auto">Run: <code>export LC_ALL=en_US.UTF-8</code></p>
</li>
<li>
<p dir="auto">for wrong locale <code>export LANG="en_US.UTF-8</code></p>
</li>
<li>
<p dir="auto">Run <code>locale</code> if there is any <code>C</code>, then run <code>export LC_ALL=en_US.UTF-8</code></p>
</li>
<li>
<p dir="auto">For <code>flutterfire</code> script fails with <code>"unhandle JSON exception"</code></p>
</li>
<li>
<p dir="auto">Download json/plist form Firebase and update in respective folders (<a data-error-text="Failed to load title" data-id="1091786202" data-permission-text="Title is private" data-url="https://github.com/invertase/flutterfire_cli/issues/30" data-hovercard-type="issue" data-hovercard-url="/invertase/flutterfire_cli/issues/30/hovercard" href="https://github.com/invertase/flutterfire_cli/issues/30">invertase/flutterfire_cli#30</a>)</p>
</li>
<li>
<p dir="auto">iOS Device require permission to connect to local network, which cannot be access from code. To emulate access query local IP address</p>
</li>
<li>
<p dir="auto">Another way is to add permission to <code>Info.plist</code> to ask on app start:</p>
</li>
<li>
<ul dir="auto">
<li>NSLocalNetworkUsageDescription</li>
</ul>
</li>
<li>
<ul dir="auto">
<li>Access to the local network required to create and connect to game rooms</li>
</ul>
</li>
<li>
<p dir="auto">For <code>Error when reading 'lib/objectbox.g.dart': No such file or directory</code></p>
</li>
<li>
<ul dir="auto">
<li>Run: <code>fvm flutter pub run build_runner watch --delete-conflicting-outputs</code></li>
</ul>
</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">Tools</h2><a id="user-content-tools" aria-label="Permalink: Tools" href="#tools"></a></p>
<p dir="auto">To generate a new Redux template see <a href="https://github.com/xajik/thedeck/blob/main/scripts">scripts</a></p>
<p dir="auto"><h2 tabindex="-1" dir="auto">License</h2><a id="user-content-license" aria-label="Permalink: License" href="#license"></a></p>
<p dir="auto">This project is licensed under the terms of the MIT license.</p>
</article></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[We are destroying software (442 pts)]]></title>
            <link>https://antirez.com/news/145</link>
            <guid>42983275</guid>
            <pubDate>Sat, 08 Feb 2025 14:48:25 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://antirez.com/news/145">https://antirez.com/news/145</a>, See on <a href="https://news.ycombinator.com/item?id=42983275">Hacker News</a></p>
<div id="readability-page-1" class="page"><div id="content">
<section id="newslist"><article data-news-id="145"><h2><a href="https://antirez.com/news/145">We are destroying software</a></h2></article></section><topcomment><article data-comment-id="145-" id="145-"><span><span><a href="https://antirez.com/user/antirez">antirez</a></span> 3 hours ago. 15699 views.  </span><pre>We are destroying software by no longer taking complexity into account when adding features or optimizing some dimension.

We are destroying software with complex build systems.

We are destroying software with an absurd chain of dependencies, making everything bloated and fragile.

We are destroying software telling new programmers: “Don’t reinvent the wheel!”. But, reinventing the wheel is how you learn how things work, and is the first step to make new, different wheels.

We are destroying software by no longer caring about backward APIs compatibility.

We are destroying software pushing for rewrites of things that work.

We are destroying software by jumping on every new language, paradigm, and framework.

We are destroying software by always underestimating how hard it is to work with existing complex libraries VS creating our stuff.

We are destroying software by always thinking that the de-facto standard for XYZ is better than what we can do, tailored specifically for our use case.

We are destroying software claiming that code comments are useless.

We are destroying software mistaking it for a purely engineering discipline.

We are destroying software by making systems that no longer scale down: simple things should be simple to accomplish, in any system.

We are destroying software trying to produce code as fast as possible, not as well designed as possible.

We are destroying software, and what will be left will no longer give us the joy of hacking.</pre></article></topcomment>


<p><a href="https://disqus.com/">blog comments powered by <span>Disqus</span></a>

</p></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[A tale of several distros joining forces for a common goal: reproducible builds (109 pts)]]></title>
            <link>https://video.fosdem.org/2025/h1302/fosdem-2025-6479-a-tale-of-several-distros-joining-forces-for-a-common-goal-reproducible-builds.av1.webm</link>
            <guid>42982270</guid>
            <pubDate>Sat, 08 Feb 2025 11:38:33 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://video.fosdem.org/2025/h1302/fosdem-2025-6479-a-tale-of-several-distros-joining-forces-for-a-common-goal-reproducible-builds.av1.webm">https://video.fosdem.org/2025/h1302/fosdem-2025-6479-a-tale-of-several-distros-joining-forces-for-a-common-goal-reproducible-builds.av1.webm</a>, See on <a href="https://news.ycombinator.com/item?id=42982270">Hacker News</a></p>
&lt;Not HTML&gt;]]></description>
        </item>
        <item>
            <title><![CDATA[Generating Voronoi Diagrams Using Fortune's Algorithm (With Odin) (153 pts)]]></title>
            <link>https://redpenguin101.github.io/html/posts/2025_01_21_voronoi.html</link>
            <guid>42982015</guid>
            <pubDate>Sat, 08 Feb 2025 10:41:17 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://redpenguin101.github.io/html/posts/2025_01_21_voronoi.html">https://redpenguin101.github.io/html/posts/2025_01_21_voronoi.html</a>, See on <a href="https://news.ycombinator.com/item?id=42982015">Hacker News</a></p>
Couldn't get https://redpenguin101.github.io/html/posts/2025_01_21_voronoi.html: Error: timeout of 10000ms exceeded]]></description>
        </item>
        <item>
            <title><![CDATA[LINUX is obsolete (1992) (123 pts)]]></title>
            <link>https://groups.google.com/g/comp.os.minix/c/wlhw16QWltI</link>
            <guid>42980283</guid>
            <pubDate>Sat, 08 Feb 2025 04:05:28 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://groups.google.com/g/comp.os.minix/c/wlhw16QWltI">https://groups.google.com/g/comp.os.minix/c/wlhw16QWltI</a>, See on <a href="https://news.ycombinator.com/item?id=42980283">Hacker News</a></p>
<div id="readability-page-1" class="page"><div role="list" aria-label="LINUX is obsolete"><div tabindex="0" jscontroller="ywEdOe" data-doc-id="XdksCA1TR_QJ" data-subject="LINUX is obsolete" data-is-first="true" data-author="Andy Tanenbaum" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i4">Andy Tanenbaum</h3></p><p><span>unread,</span></p><div><p><span>Jan 29, 1992, 1:12:50 PM</span><span>1/29/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i4" role="region"><p>I was in the U.S. for a couple of weeks, so I haven't commented much on<br>LINUX (not that I would have said much had I been around), but for what <br>it is worth, I have a couple of comments now.</p><p>As most of you know, for me MINIX is a hobby, something that I do in the<br>evening when I get bored writing books and there are no major wars,<br>revolutions, or senate hearings being televised live on CNN.  My real<br>job is a professor and researcher in the area of operating systems.</p><p>As a result of my occupation, I think I know a bit about where operating<br>are going in the next decade or so.  Two aspects stand out:</p><p>1. MICROKERNEL VS MONOLITHIC SYSTEM<br>   Most older operating systems are monolithic, that is, the whole operating<br>   system is a single a.out file that runs in 'kernel mode.'  This binary<br>   contains the process management, memory management, file system and the<br>   rest. Examples of such systems are UNIX, MS-DOS, VMS, MVS, OS/360, <br>   MULTICS, and many more.</p><p>   The alternative is a microkernel-based system, in which most of the OS<br>   runs as separate processes, mostly outside the kernel.  They communicate<br>   by message passing.  The kernel's job is to handle the message passing,<br>   interrupt handling, low-level process management, and possibly the I/O.<br>   Examples of this design are the RC4000, Amoeba, Chorus, Mach, and the<br>   not-yet-released Windows/NT.</p><p>   While I could go into a long story here about the relative merits of the<br>   two designs, suffice it to say that among the people who actually design<br>   operating systems, the debate is essentially over.  Microkernels have won.<br>   The only real argument for monolithic systems was performance, and there<br>   is now enough evidence showing that microkernel systems can be just as<br>   fast as monolithic systems (e.g., Rick Rashid has published papers comparing<br>   Mach 3.0 to monolithic systems) that it is now all over but the shoutin`.</p><p>   MINIX is a microkernel-based system.  The file system and memory management<br>   are separate processes, running outside the kernel.  The I/O drivers are<br>   also separate processes (in the kernel, but only because the brain-dead<br>   nature of the Intel CPUs makes that difficult to do otherwise).  LINUX is<br>   a monolithic style system.  This is a giant step back into the 1970s.<br>   That is like taking an existing, working C program and rewriting it in<br>   BASIC.  To me, writing a monolithic system in 1991 is a truly poor idea.</p><p><br>2. PORTABILITY<br>   Once upon a time there was the 4004 CPU.  When it grew up it became an<br>   8008.  Then it underwent plastic surgery and became the 8080.  It begat<br>   the 8086, which begat the 8088, which begat the 80286, which begat the<br>   80386, which begat the 80486, and so on unto the N-th generation.  In<br>   the meantime, RISC chips happened, and some of them are running at over<br>   100 MIPS.  Speeds of 200 MIPS and more are likely in the coming years.<br>   These things are not going to suddenly vanish.  What is going to happen<br>   is that they will gradually take over from the 80x86 line.  They will<br>   run old MS-DOS programs by interpreting the 80386 in software.  (I even<br>   wrote my own IBM PC simulator in C, which you can get by FTP from<br>   <a href="http://ftp.cs.vu.nl/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://ftp.cs.vu.nl&amp;source=gmail&amp;ust=1739122202386000&amp;usg=AOvVaw2Nn9bI9ui3gH56E1zXdWLa">ftp.cs.vu.nl</a> =  192.31.231.42 in dir minix/simulator.)  I think it is a<br>   gross error to design an OS for any specific architecture, since that is<br>   not going to be around all that long.</p><p>   MINIX was designed to be reasonably portable, and has been ported from the<br>   Intel line to the 680x0 (Atari, Amiga, Macintosh), SPARC, and NS32016.<br>   LINUX is tied fairly closely to the 80x86.  Not the way to go.</p><p>Don`t get me wrong, I am not unhappy with LINUX.  It will get all the people<br>who want to turn MINIX in BSD UNIX off my back.  But in all honesty, I would<br>suggest that people who want a **MODERN** "free" OS look around for a <br>microkernel-based, portable OS, like maybe GNU or something like that.</p><p><br>Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>)</p><p><br>P.S. Just as a random aside, Amoeba has a UNIX emulator (running in user<br>space), but it is far from complete.  If there are any people who would<br>like to work on that, please let me know.  To run Amoeba you need a few 386s,<br>one of which needs 16M, and all of which need the WD Ethernet card.<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="mfm89Emv8aIJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="David Megginson" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i8">David Megginson</h3></p><p><span>unread,</span></p><div><p><span>Jan 29, 1992, 3:12:12 PM</span><span>1/29/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i8" role="region"><p>I would like to at least look at LINUX, but I cannot, since I run<br>a 68000-based machine. In any case, it is nice having the kernel<br>independent, since patches like the multi-threaded FS patch don't<br>have to exist in a different version for each CPU.</p><p>I second everything AST said, except that I would like to see<br>the kernel _more_ independent from everything else. Why does the<br>Intel architecture _not_ allow drivers to be independent programs?</p><p>I also don't like the fact that the kernel, mm and fs share the<br>same configuration files. Since they _are_ independent, they should<br>have more of a sense of independence.</p><p><br>David</p><p>#################################################################<br>David Megginson                  <a href="" data-email-masked="" rel="nofollow">meg...@epas.utoronto.ca</a><br>Centre for Medieval Studies      <a href="" data-email-masked="" rel="nofollow">da...@doe.utoronto.ca</a><br>University of Toronto            39 Queen's Park Cr. E.<br>#################################################################</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="VoNyBgh_Xo4J" data-subject="LINUX is obsolete" data-is-first="false" data-author="Andy Tanenbaum" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i12">Andy Tanenbaum</h3></p><p><span>unread,</span></p><div><p><span>Jan 29, 1992, 7:03:01 PM</span><span>1/29/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i12" role="region"><p>The drivers have to read and write the device registers in I/O space, and<br>this cannot be done in user mode on the 286 and 386. If it were possible<br>to do I/O in a protected way in user space, all the I/O tasks could have<br>been user programs, like FS and MM.</p><p>Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>)<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="UOlvH5JY-uEJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Kevin Brown" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i16">Kevin Brown</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 2:36:43 AM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i16" role="region"><p>Of course, there are some things that are best left to the kernel, be it<br>micro or monolithic.  Like things that require playing with the process'<br>stack, e.g. signal handling.  Like memory allocation.  Things like that.</p><p>The microkernel design is probably a win, all in all, over a monolithic<br>design, but it depends on what you put in the kernel and what you leave<br>out.</p><div><p>&gt;   MINIX is a microkernel-based system.  The file system and memory management<br>&gt;   are separate processes, running outside the kernel.  The I/O drivers are<br>&gt;   also separate processes (in the kernel, but only because the brain-dead<br>&gt;   nature of the Intel CPUs makes that difficult to do otherwise).  </p></div><p>Minix is a microkernel design, of sorts.  The problem is that it gives special<br>priveleges to mm and fs, when there shouldn't be any (at least for fs).  It<br>also fails to integrate most of the functionality of mm in the kernel itself,<br>and this makes things like signal handling and memory allocation *really*<br>ugly.  If you did these things in the kernel itself, then signal handling<br>would be as simple as setting a virtual interrupt vector and causing the<br>signalled process to receive that interrupt (with the complication that<br>system calls might have to be terminated.  Which means that a message would<br>have to be sent to every process that is servicing the process' system call,<br>if any.  It's considerations like these that make the monolithic kernel<br>design appealing).</p><p>The *entire* system call interface in Minix needs to be rethought.  As it<br>stands right now, the file system is not just a file system, it's also a<br>system-call server.  That functionality needs to be separated out in order<br>to facilitate a multiple file system architecture.  Message passing is<br>probably the right way to go about making the call and waiting for it, but<br>the message should go to a system call server, not the file system itself.</p><p>In order to handle all the special caveats of the Unix API, you end up writing<br>a monolithic "kernel" even if you're using a microkernel base.  You end up<br>with something called a "server", and an example is the BSD server that runs<br>under Mach.</p><p>And, in any case, the message-passing in Minix needs to be completely redone.<br>As it is, it's a kludge.  I've been giving this some thought, but I haven't<br>had time to do anything with what I've thought of so far.  Suffice it to say<br>that the proper way to do message-passing is probably with message ports<br>(both public and private), with the various visible parts of the operating<br>system having public message ports.  Chances are, that ends up being the<br>system call server only, though this will, of course, depend on the goals<br>of the design.</p><div><p>&gt;   LINUX is<br>&gt;   a monolithic style system.  This is a giant step back into the 1970s.<br>&gt;   That is like taking an existing, working C program and rewriting it in<br>&gt;   BASIC.  To me, writing a monolithic system in 1991 is a truly poor idea.</p></div><p>Depends on the design criteria, as you should know.  If your goal is to<br>design a Unix workalike that is relatively simple and relatively small,<br>then a monolithic design is probably the right approach for the job, because<br>unless you're designing for really backwards hardware, the problems of<br>things like interrupted system calls, memory allocation within the kernel<br>(so you don't have to statically allocate *everything* in your OS), signal<br>handling, etc. all go away (or are at least minimized) if you use a<br>monolithic design.  If you want the ability to bring up and take down<br>file systems, add and remove device drivers, etc., all at runtime, then<br>a microkernel approach is the right solution.</p><p>Frankly, I happen to like the idea of removable device drivers and such,<br>so I tend to favor the microkernel approach as a general rule.</p><div><p>&gt;2. PORTABILITY<br>&gt;   Once upon a time there was the 4004 CPU.  When it grew up it became an<br>&gt;   8008.  Then it underwent plastic surgery and became the 8080.  It begat<br>&gt;   the 8086, which begat the 8088, which begat the 80286, which begat the<br>&gt;   80386, which begat the 80486, and so on unto the N-th generation.  In<br>&gt;   the meantime, RISC chips happened, and some of them are running at over<br>&gt;   100 MIPS.  Speeds of 200 MIPS and more are likely in the coming years.<br>&gt;   These things are not going to suddenly vanish.  What is going to happen<br>&gt;   is that they will gradually take over from the 80x86 line.  They will<br>&gt;   run old MS-DOS programs by interpreting the 80386 in software.  (I even<br>&gt;   wrote my own IBM PC simulator in C, which you can get by FTP from<br>&gt;   <a href="http://ftp.cs.vu.nl/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://ftp.cs.vu.nl&amp;source=gmail&amp;ust=1739122202391000&amp;usg=AOvVaw1n0Kz5b5RhUhrmVJHKdq53">ftp.cs.vu.nl</a> =  192.31.231.42 in dir minix/simulator.)  I think it is a<br>&gt;   gross error to design an OS for any specific architecture, since that is<br>&gt;   not going to be around all that long.</p></div><p>Again, look at the design criteria.  If portability isn't an issue, then<br>why worry about it?  While LINUX suffers from lack of portability, portability<br>was obviously never much of a consideration for its author, who explicitly<br>stated that it was written as an exercise in learning about the 386<br>architecture.</p><p>And, in any case, while MINIX is portable in the sense that most of the code<br>can be ported to other platforms, it *still* suffers from the limitations of<br>the original target machine that drove the walk down the design decision tree.<br>The message passing is a kludge because the 8088 is slow.  The kernel doesn't<br>do memory allocation (thus not allowing FS and the drivers to get away with<br>using a malloc library or some such, and thus causing everyone to have to<br>statically allocate everything), probably due to some other limitation of<br>the 8088.  The very idea of using "clicks" is obviously the result of the<br>segmented architecture of the 8088.  The file system size is too limited<br>(theoretically fixed in 1.6, but now you have *two* file system formats to<br>contend with.  If having the file system as a separate process is such a<br>big win, then why don't we have two file system servers, eh?  Why simply<br>extend the existing Minix file system instead of implementing BSD's FFS<br>or some other high-performance file system?  It's not that I'm greedy<br>or anything... :-).</p><div><p>&gt;   MINIX was designed to be reasonably portable, and has been ported from the<br>&gt;   Intel line to the 680x0 (Atari, Amiga, Macintosh), SPARC, and NS32016.<br>&gt;   LINUX is tied fairly closely to the 80x86.  Not the way to go.</p></div><p>All in all, I tend to agree.</p><div><p>&gt;Don`t get me wrong, I am not unhappy with LINUX.  It will get all the people<br>&gt;who want to turn MINIX in BSD UNIX off my back.  But in all honesty, I would<br>&gt;suggest that people who want a **MODERN** "free" OS look around for a <br>&gt;microkernel-based, portable OS, like maybe GNU or something like that.</p></div><p>Yeah, right.  Point me someplace where I can get a free "modern" OS and I'll<br>gladly investigate.  But the GNU OS is currently vaporware, and as far as I'm<br>concerned it will be for a LOOOOONG time to come.</p><p>Any other players?  BSD 4.4 is a monolithic architecture, so by your<br>definition it's out.  Mach is free, but the BSD server isn't (AT&amp;T code,<br>you know), and in any case, isn't the BSD server something you'd consider<br>to be a monolithic design???</p><p>Really.  Why do you think LINUX is as popular as it is?  The answer is<br>simple, of course: because it's the *only* free Unix workalike OS in<br>existence.  BSD doesn't qualify (yet).  Minix doesn't qualify.  XINU<br>isn't even in the running.  GNU's OS is vaporware, and probably will<br>be for a long time, so *by definition* it's not in the running.  Any<br>other players?  I haven't heard of any...</p><p>&gt;Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>)</p><p>Minix is an excellent piece of work.  A good starting point for anyone who<br>wants to learn about operating systems.  But it needs rewriting to make it<br>truly elegant and functional.  As it is, there are too many kludges and<br>hacks (e.g., the message passing).</p><p>				Kevin Brown<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="P8isWhZ8PJ8J" data-subject="LINUX is obsolete" data-is-first="false" data-author="Linus Benedict Torvalds" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i20">Linus Benedict Torvalds</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 12:14:26 AM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i20" role="region"><p>Well, with a subject like this, I'm afraid I'll have to reply. <br>Apologies to minix-users who have heard enough about linux anyway.  I'd<br>like to be able to just "ignore the bait", but ...  Time for some<br>serious flamefesting!</p><p>&gt;I was in the U.S. for a couple of weeks, so I haven't commented much on<br>&gt;LINUX (not that I would have said much had I been around), but for what <br>&gt;it is worth, I have a couple of comments now.<br>&gt;<br>&gt;As most of you know, for me MINIX is a hobby, something that I do in the<br>&gt;evening when I get bored writing books and there are no major wars,<br>&gt;revolutions, or senate hearings being televised live on CNN.  My real<br>&gt;job is a professor and researcher in the area of operating systems.</p><p>You use this as an excuse for the limitations of minix? Sorry, but you<br>loose: I've got more excuses than you have, and linux still beats the<br>pants of minix in almost all areas.  Not to mention the fact that most<br>of the good code for PC minix seems to have been written by Bruce Evans. </p><p>Re 1: you doing minix as a hobby - look at who makes money off minix,<br>and who gives linux out for free.  Then talk about hobbies.  Make minix<br>freely available, and one of my biggest gripes with it will disappear. <br>Linux has very much been a hobby (but a serious one: the best type) for<br>me: I get no money for it, and it's not even part of any of my studies<br>in the university.  I've done it all on my own time, and on my own<br>machine. </p><p>Re 2: your job is being a professor and researcher: That's one hell of a<br>good excuse for some of the brain-damages of minix. I can only hope (and<br>assume) that Amoeba doesn't suck like minix does.</p><div><p>&gt;1. MICROKERNEL VS MONOLITHIC SYSTEM</p></div><p>True, linux is monolithic, and I agree that microkernels are nicer. With<br>a less argumentative subject, I'd probably have agreed with most of what<br>you said. From a theoretical (and aesthetical) standpoint linux looses.<br>If the GNU kernel had been ready last spring, I'd not have bothered to<br>even start my project: the fact is that it wasn't and still isn't. Linux<br>wins heavily on points of being available now.</p><p>&gt;   MINIX is a microkernel-based system. [deleted, but not so that you<br>&gt; miss the point ]  LINUX is a monolithic style system.</p><p>If this was the only criterion for the "goodness" of a kernel, you'd be<br>right.  What you don't mention is that minix doesn't do the micro-kernel<br>thing very well, and has problems with real multitasking (in the<br>kernel).  If I had made an OS that had problems with a multithreading<br>filesystem, I wouldn't be so fast to condemn others: in fact, I'd do my<br>damndest to make others forget about the fiasco.</p><p>[ yes, I know there are multithreading hacks for minix, but they are<br>hacks, and bruce evans tells me there are lots of race conditions ]</p><p>&gt;2. PORTABILITY</p><p>"Portability is for people who cannot write new programs"<br>		-me, right now (with tongue in cheek)</p><p>The fact is that linux is more portable than minix.  What? I hear you<br>say.  It's true - but not in the sense that ast means: I made linux as<br>conformant to standards as I knew how (without having any POSIX standard<br>in front of me).  Porting things to linux is generally /much/ easier<br>than porting them to minix.</p><p>I agree that portability is a good thing: but only where it actually has<br>some meaning.  There is no idea in trying to make an operating system<br>overly portable: adhering to a portable API is good enough.  The very<br>/idea/ of an operating system is to use the hardware features, and hide<br>them behind a layer of high-level calls.  That is exactly what linux<br>does: it just uses a bigger subset of the 386 features than other<br>kernels seem to do.  Of course this makes the kernel proper unportable,<br>but it also makes for a /much/ simpler design.  An acceptable trade-off,<br>and one that made linux possible in the first place.</p><p>I also agree that linux takes the non-portability to an extreme: I got<br>my 386 last January, and linux was partly a project to teach me about<br>it.  Many things should have been done more portably if it would have<br>been a real project.  I'm not making overly many excuses about it<br>though: it was a design decision, and last april when I started the<br>thing, I didn't think anybody would actually want to use it.  I'm happy<br>to report I was wrong, and as my source is freely available, anybody is<br>free to try to port it, even though it won't be easy. </p><p>		Linus</p><p>PS. I apologise for sometimes sounding too harsh: minix is nice enough<br>if you have nothing else. Amoeba might be nice if you have 5-10 spare<br>386's lying around, but I certainly don't. I don't usually get into<br>flames, but I'm touchy when it comes to linux :)<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="AowmIAEy96wJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Louie" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i24">Louie</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 3:55:22 AM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i24" role="region"><p>&gt;But in all honesty, I would<br>&gt;suggest that people who want a **MODERN** "free" OS look around for a <br>&gt;microkernel-based, portable OS, like maybe GNU or something like that.</p><p>There are really no other alternatives other than Linux for people like<br>me who want a "free" OS.  Considering that the majority of people who<br>would use a "free" OS use the 386, portability is really not all that<br>big of a concern.  If I had a Sparc I would use Solaris.  </p><p>As it stands, I installed Linux with gcc, emacs 18.57, kermit and all of the <br>GNU utilities without any trouble at all.  No need to apply patches. I<br>just followed the installation instructions.  I can't get an OS like<br>this *anywhere* for the price to do my Computer Science homework. And<br>it seems like network support and then X-Windows will be ported to Linux<br>well before Minix.  This is something that would be really useful. In my<br>opinion, portability of standard Unix software is important also.</p><p>I know that the design using a monolithic system is not as good as the<br>microkernel.  But for the short term future (And I know I won't/can't<br>be uprading from my 386), Linux suits me perfectly.</p><p>Philip Wu<br><a href="" data-email-masked="" rel="nofollow">p...@unixg.ubc.ca</a><br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="ak8iSmpK8FQJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Jim Burns" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i28">Jim Burns</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 4:39:48 AM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i28" role="region"><p>&gt; The drivers have to read and write the device registers in I/O space, and<br>&gt; this cannot be done in user mode on the 286 and 386. If it were possible<br>&gt; to do I/O in a protected way in user space, all the I/O tasks could have<br>&gt; been user programs, like FS and MM.</p><p>The standard way of doing that is to trap on i/o space protection<br>violations, and emulate the i/o for the user.<br>-- <br>BURNS,JIM (returned student)<br>Georgia Institute of Technology, 30178 Georgia Tech Station,<br>Atlanta Georgia, 30332            | Internet: <a href="" data-email-masked="" rel="nofollow">gt0...@prism.gatech.edu</a><br>uucp:	  ...!{decvax,hplabs,ncar,purdue,rutgers}!gatech!prism!gt0178a<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="9e4-cnhKXGIJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Andy Tanenbaum" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i32">Andy Tanenbaum</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 2:44:34 PM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i32" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Jan29.2...@klaava.Helsinki.FI</a>&gt; <a href="" data-email-masked="" rel="nofollow">torv...@klaava.Helsinki.FI</a> (Linus Benedict Torvalds) writes:<br>&gt;You use this [being a professor] as an excuse for the limitations of minix? <br>The limitations of MINIX relate at least partly to my being a professor:<br>An explicit design goal was to make it run on cheap hardware so students<br>could afford it.  In particular, for years it ran on a regular 4.77 MHZ PC<br>with no hard disk.  You could do everything here including modify and recompile<br>the system.  Just for the record, as of about 1 year ago, there were two<br>versions, one for the PC (360K diskettes) and one for the 286/386 (1.2M).<br>The PC version was outselling the 286/386 version by 2 to 1.  I don't have<br>figures, but my guess is that the fraction of the 60 million existing PCs that<br>are 386/486 machines as opposed to 8088/286/680x0 etc is small.  Among students<br>it is even smaller. Making software free, but only for folks with enough money<br>to buy first class hardware is an interesting concept.<br>Of course 5 years from now that will be different, but 5 years from now <br>everyone will be running free GNU on their 200 MIPS, 64M SPARCstation-5.</p><p>&gt;Re 2: your job is being a professor and researcher: That's one hell of a<br>&gt;good excuse for some of the brain-damages of minix. I can only hope (and<br>&gt;assume) that Amoeba doesn't suck like minix does.<br></p><p>Amoeba was not designed to run on an 8088 with no hard disk.</p><div><p><br>&gt;If this was the only criterion for the "goodness" of a kernel, you'd be<br>&gt;right.  What you don't mention is that minix doesn't do the micro-kernel<br>&gt;thing very well, and has problems with real multitasking (in the<br>&gt;kernel).  If I had made an OS that had problems with a multithreading<br>&gt;filesystem, I wouldn't be so fast to condemn others: in fact, I'd do my<br>&gt;damndest to make others forget about the fiasco.<br></p></div><p>A multithreaded file system is only a performance hack.  When there is only<br>one job active, the normal case on a small PC, it buys you nothing and adds<br>complexity to the code.  On machines fast enough to support multiple users,<br>you probably have enough buffer cache to insure a hit cache hit rate, in<br>which case multithreading also buys you nothing.  It is only a win when there<br>are multiple processes actually doing real disk I/O.  Whether it is worth<br>making the system more complicated for this case is at least debatable.</p><p>I still maintain the point that designing a monolithic kernel in 1991 is<br>a fundamental error.  Be thankful you are not my student.  You would not<br>get a high grade for such a design :-)</p><div><p><br>&gt;The fact is that linux is more portable than minix.  What? I hear you<br>&gt;say.  It's true - but not in the sense that ast means: I made linux as<br>&gt;conformant to standards as I knew how (without having any POSIX standard<br>&gt;in front of me).  Porting things to linux is generally /much/ easier<br>&gt;than porting them to minix.<br></p></div><p>MINIX was designed before POSIX, and is now being (slowly) POSIXized as <br>everyone who follows this newsgroup knows.  Everyone agrees that user-level <br>standards are a good idea.  As an aside, I congratulate you for being able <br>to write a POSIX-conformant system without having the POSIX standard in front <br>of you. I find it difficult enough after studying the standard at great length.</p><p>My point is that writing a new operating system that is closely tied to any<br>particular piece of hardware, especially a weird one like the Intel line,<br>is basically wrong.  An OS itself should be easily portable to new hardware<br>platforms.  When OS/360 was written in assembler for the IBM 360<br>25 years ago, they probably could be excused.  When MS-DOS was written<br>specifically for the 8088 ten years ago, this was less than brilliant, as<br>IBM and Microsoft now only too painfully realize. Writing a new OS only for the<br>386 in 1991 gets you your second 'F' for this term.  But if you do real well<br>on the final exam, you can still pass the course.</p><p><br>Prof. Andrew S. Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>)<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="SCSRnegn-0QJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="David Feustel" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i36">David Feustel</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 7:57:28 PM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i36" role="region"><p><a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a> (Andy Tanenbaum) writes:</p><p><br>&gt;I still maintain the point that designing a monolithic kernel in 1991 is<br>&gt;a fundamental error.  Be thankful you are not my student.  You would not<br>&gt;get a high grade for such a design :-)</p><p>That's ok. Einstein got lousy grades in math and physics.<br>-- <br>David Feustel N9MYI, 1930 Curdes Ave, Fort Wayne, IN 46805. <a href="tel:(219)%20482-9631" value="+12194829631" target="_blank" rel="nofollow">(219)482-9631</a><br><a href="" data-email-masked="" rel="nofollow">feu...@netcom.com</a> <br>=== NBC News: GE's Advertising And Public Relations Agency ===<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="er7fg9bWV1oJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="David Megginson" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i40">David Megginson</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 8:58:50 PM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i40" role="region"><p>In article &lt;1992Jan30.1857...@netcom.COM&gt; feu...@netcom.COM (David Feustel) writes:<br>&gt;<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a> (Andy Tanenbaum) writes:<br>&gt;<br>&gt;<br>&gt;&gt;I still maintain the point that designing a monolithic kernel in 1991 is<br>&gt;&gt;a fundamental error.  Be thankful you are not my student.  You would not<br>&gt;&gt;get a high grade for such a design :-)<br>&gt;<br>&gt;That's ok. Einstein got lousy grades in math and physics.</p><p>And Dan Quayle got low grades in political science. I think that there<br>are more Dan Quayles than Einsteins out there... ;-)</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="4jfSNgZ0AKcJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Randy Burns" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i44">Randy Burns</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 9:33:07 PM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i44" role="region"><p>&gt;Of course 5 years from now that will be different, but 5 years from now <br>&gt;everyone will be running free GNU on their 200 MIPS, 64M SPARCstation-5.<br></p><p>Well, I for one would _love_ to see this happen.</p><div><p>&gt;&gt;The fact is that linux is more portable than minix.  What? I hear you<br>&gt;&gt;say.  It's true - but not in the sense that ast means: I made linux as<br>&gt;&gt;conformant to standards as I knew how (without having any POSIX standard<br>&gt;&gt;in front of me).  Porting things to linux is generally /much/ easier<br>&gt;&gt;than porting them to minix.<br></p></div><p>........</p><div><p><br>&gt;My point is that writing a new operating system that is closely tied to any<br>&gt;particular piece of hardware, especially a weird one like the Intel line,<br>&gt;is basically wrong. <br></p></div><p>First off, the parts of Linux tuned most finely to the 80x86 are the Kernel<br>and the devices. My own sense is that even if Linux is simply a stopgap<br>measure to let us all run GNU software, it is still worthwhile to have a<br>a finely tuned kernel for the most numerous architecture presently in <br>existance.</p><div><p>&gt; An OS itself should be easily portable to new hardware<br>&gt;platforms. <br></p></div><p>Well, the only part of Linux that isn't portable is the kernel and drivers.<br>Compare to the compilers, utilities, windowing system etc. this is really<br>a small part of the effort. Since Linux has a large degree of call<br>compatibility with portable OS's I wouldn't complain. I'm personally <br>very grateful to have an OS that makes it more likely that some of us will <br>be able to take advantage of the software that has come out of Berkeley,<br>FSF, CMU etc. It may well be that in 2-3 years when ultra cheap BSD<br>variants and Hurd proliferate, that Linux will be obsolete. Still, right<br>now Linux greatly reduces the cost of using tools like gcc, bison, bash<br>which are useful in the development of  such an OS.<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="tHp9VExAcmMJ" data-subject="Apologies (was Re: LINUX is obsolete)" data-is-first="false" data-author="Linus Benedict Torvalds" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i48">Linus Benedict Torvalds</h3></p><p><span>unread,</span></p><div><p><span>Jan 30, 1992, 4:38:16 PM</span><span>1/30/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i48" role="region"><p>And reply I did, with complete abandon, and no thought for good taste<br>and netiquette.  Apologies to ast, and thanks to John Nall for a friendy<br>"that's not how it's done"-letter.  I over-reacted, and am now composing<br>a (much less acerbic) personal letter to ast.  Hope nobody was turned<br>away from linux due to it being (a) possibly obsolete (I still think<br>that's not the case, although some of the criticisms are valid) and (b)<br>written by a hothead :-)</p><p>		Linus "my first, and hopefully last flamefest" Torvalds<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="g6ic7ojOeEgJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="David Feustel" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i52">David Feustel</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 12:15:05 AM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i52" role="region"><p><a href="" data-email-masked="" rel="nofollow">meg...@epas.utoronto.ca</a> (David Megginson) writes:</p><p>&gt;In article &lt;1992Jan30.1857...@netcom.COM&gt; feu...@netcom.COM (David Feustel) writes:<br>&gt;&gt;<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a> (Andy Tanenbaum) writes:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;I still maintain the point that designing a monolithic kernel in 1991 is<br>&gt;&gt;&gt;a fundamental error.  Be thankful you are not my student.  You would not<br>&gt;&gt;&gt;get a high grade for such a design :-)<br>&gt;&gt;<br>&gt;&gt;That's ok. Einstein got lousy grades in math and physics.</p><div><p>&gt;And Dan Quayle got low grades in political science. I think that there<br>&gt;are more Dan Quayles than Einsteins out there... ;-)</p></div><p>But the Existence of Linux suggests that we may have more of an<br>Einstein than a Quail here.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="yLXnDYcthOYJ" data-subject="posixiation (was Re: LINUX is obsolete)" data-is-first="false" data-author="Geoff Collyer" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i56">Geoff Collyer</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 2:13:00 AM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i56" role="region"><p>Andy Tanenbaum:</p><div><p>&gt;MINIX was designed before POSIX, and is now being (slowly) POSIXized as <br>&gt;everyone who follows this newsgroup knows.</p></div><p>May I recommend the use of the verb "posixiate" (by analogy with<br>asphyxiate) instead of "posixize"?  Similarly, I prefer "ansitise"<br>(converse and anagram of "sanitise") to "ansify".<br>-- <br>Geoff Collyer		<a href="http://world.std.com/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://world.std.com&amp;source=gmail&amp;ust=1739122202400000&amp;usg=AOvVaw1LuH77SnUnjfk-9a_ICh9G">world.std.com</a>!geoff, <a href="http://uunet.uu.net/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://uunet.uu.net&amp;source=gmail&amp;ust=1739122202400000&amp;usg=AOvVaw2iZY4pP0uSjJ9jBFCxkQqN">uunet.uu.net</a>!geoff<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="tMxOW0pZaz8J" data-subject="LINUX is obsolete" data-is-first="false" data-author="Kevin Brown" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i60">Kevin Brown</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 8:43:47 AM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i60" role="region"><p>Sorry, but I just can't resist this thread...:-)</p><p>&gt;In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Jan29.2...@klaava.Helsinki.FI</a>&gt; <a href="" data-email-masked="" rel="nofollow">torv...@klaava.Helsinki.FI</a> (Linus Benedict Torvalds) writes:<br>&gt;&gt;You use this [being a professor] as an excuse for the limitations of minix? <br>&gt;The limitations of MINIX relate at least partly to my being a professor:<br>&gt;An explicit design goal was to make it run on cheap hardware so students<br>&gt;could afford it.  In particular, for years it ran on a regular 4.77 MHZ PC<br>&gt;with no hard disk.  </p><p>And an explicit design goal of Linux was to take advantage of the special<br>features of the 386 architecture.  So what exactly is your point?  Different<br>design goals get you different designs.  You ought to know that.</p><div><p>&gt;You could do everything here including modify and recompile<br>&gt;the system.  Just for the record, as of about 1 year ago, there were two<br>&gt;versions, one for the PC (360K diskettes) and one for the 286/386 (1.2M).<br>&gt;The PC version was outselling the 286/386 version by 2 to 1.  I don't have<br>&gt;figures, but my guess is that the fraction of the 60 million existing PCs that<br>&gt;are 386/486 machines as opposed to 8088/286/680x0 etc is small.  Among students<br>&gt;it is even smaller. </p></div><p>I find it very interesting that you claim here that Minix was designed<br>primarily for cheap hardware (in particular, the IBM PC/XT with no hard<br>disk) and yet elsewhere have also mentioned the virtues of being portable<br>across hardware platforms.  Well, if you insist on designing the thing<br>with the lowest common denominator as your basis, that's fine, but of<br>course the end result will be less than pretty unless designed *very*<br>carefully.</p><div><p>&gt;Making software free, but only for folks with enough money<br>&gt;to buy first class hardware is an interesting concept.</p></div><p>Except that Linux was designed more for the purposes of the designer than<br>anything else.  If I were writing an OS, I'd design it to suit myself, too.<br>It's just that Linus was nice enough to share his code with the rest of us.</p><div><p>&gt;Of course 5 years from now that will be different, but 5 years from now <br>&gt;everyone will be running free GNU on their 200 MIPS, 64M SPARCstation-5.</p></div><p>Maybe.  But by then, the 386/486 will probably be where the PC is now:<br>everyone will have one and they'll be dirt cheap.  The timing will be<br>about right.  In which case Linux will fit right in, wouldn't you say?</p><div><p>&gt;&gt;Re 2: your job is being a professor and researcher: That's one hell of a<br>&gt;&gt;good excuse for some of the brain-damages of minix. I can only hope (and<br>&gt;&gt;assume) that Amoeba doesn't suck like minix does.<br>&gt;Amoeba was not designed to run on an 8088 with no hard disk.</p></div><p>Here's a question for you: as a general rule, when you go to design an<br>operating system, do you design it for specific capabilities and then run<br>it on whatever hardware will do the job, or do you design it with the<br>hardware as a target and fit the capabilities to the hardware?  With respect<br>to Minix, it seems you did the latter, but I don't know whether or not you<br>did that with Amoeba.</p><div><p>&gt;&gt;If this was the only criterion for the "goodness" of a kernel, you'd be<br>&gt;&gt;right.  What you don't mention is that minix doesn't do the micro-kernel<br>&gt;&gt;thing very well, and has problems with real multitasking (in the<br>&gt;&gt;kernel).  If I had made an OS that had problems with a multithreading<br>&gt;&gt;filesystem, I wouldn't be so fast to condemn others: in fact, I'd do my<br>&gt;&gt;damndest to make others forget about the fiasco.<br>&gt;A multithreaded file system is only a performance hack.  </p></div><p>Bull.  A multithreaded file system has a completely different design than<br>a single-threaded file system and has different design criteria than a<br>single-threaded file system.</p><div><p>&gt;When there is only one job active, the normal case on a small PC, it buys<br>&gt;you nothing and adds complexity to the code.  </p></div><p>If there is only going to be one job active anyway then *why bother with<br>multitasking at all*????</p><p>If you're going to implement multitasking, then don't do a halfway job<br>of it.  On the other hand, if you're going to assume that there will be<br>only one job active anyway, then don't bother with multitasking (after<br>all, it *does* complicate things :-).</p><div><p>&gt;On machines fast enough to<br>&gt;support multiple users, you probably have enough buffer cache to insure a<br>&gt;hit cache hit rate, in which case multithreading also buys you nothing.  </p></div><p>Maybe.  Multiple users means multiple things being done simultaneously.  I<br>wouldn't bet on the buffer cache buying you so much that multithreading<br>makes no difference.  It's one thing if the users are doing something<br>simple, like editing a file.  It's another thing if they're compiling,<br>reading news, or other things that touch lots of different files.</p><div><p>&gt;It is only a win when there are multiple processes actually doing real disk<br>&gt;I/O.  </p></div><p>Which happens a *lot* when you're running multiple users.  Or when you're<br>a machine hooked up to the net and handling news traffic.</p><div><p>&gt;Whether it is worth making the system more complicated for this case is<br>&gt;at least debatable.</p></div><p>Oh, come on.  How tough is it to implement a multi-threaded file system?<br>All you need is a decent *buffered* (preferably infinitely so)<br>message-passing system and a way to save your current state when you send<br>out a request to the device driver(s) to perform some work (and obviously<br>some way to restore that state).  Minix has the second via the setjmp()/<br>longjmp() mechanism, but lacks the former in a serious way.</p><div><p>&gt;I still maintain the point that designing a monolithic kernel in 1991 is<br>&gt;a fundamental error.  </p></div><p>Not if you're trying to implement the system call semantics of Unix in a<br>reasonably simple and elegant way.</p><div><p>&gt;Be thankful you are not my student.  You would not<br>&gt;get a high grade for such a design :-)</p></div><p>Why not?  What's this big thing against monolithic kernels?  There are<br>certain classes of problems for which a monolithic kernel is a more<br>appropriate design than a microkernel architecture.  I think implementing<br>Unix semantics with a minimum of fuss is one such problem.</p><p>Unless you can suggest an elegant way to terminate a system call upon<br>receipt of a signal from within a microkernel OS?</p><div><p>&gt;&gt;The fact is that linux is more portable than minix.  What? I hear you<br>&gt;&gt;say.  It's true - but not in the sense that ast means: I made linux as<br>&gt;&gt;conformant to standards as I knew how (without having any POSIX standard<br>&gt;&gt;in front of me).  Porting things to linux is generally /much/ easier<br>&gt;&gt;than porting them to minix.<br>&gt;MINIX was designed before POSIX, and is now being (slowly) POSIXized as <br>&gt;everyone who follows this newsgroup knows.  Everyone agrees that user-level <br>&gt;standards are a good idea.  As an aside, I congratulate you for being able <br>&gt;to write a POSIX-conformant system without having the POSIX standard in front <br>&gt;of you. I find it difficult enough after studying the standard at great length.<br>&gt;<br>&gt;My point is that writing a new operating system that is closely tied to any<br>&gt;particular piece of hardware, especially a weird one like the Intel line,<br>&gt;is basically wrong.  </p></div><p>Weird as the Intel line may be, it's *the* most popular line, by several<br>times.  So it's not like it's *that* big a loss.  And Intel hardware is<br>at least relatively cheap to come by, regardless of what your students<br>might tell you (why do you think they all own PCs?)...</p><div><p>&gt;An OS itself should be easily portable to new hardware<br>&gt;platforms.  </p></div><p>As long as you don't sacrifice too much in the way of performance or<br>architectural elegance in order to gain this.  Unfortunately, that's<br>*exactly* what happened with Minix: in attempting to implement it on<br>hardware of the lowest caliber, you ended up having to make design<br>decisions with respect to the architecture and implementation that have<br>made vintage Minix unusable as anything more than a personal toy operating<br>system.  For example: why didn't you implement a system call server as<br>a layer between the file system and user programs?  My guess: you didn't<br>have enough memory on the target machine to do it.</p><p>Put another way: you hit your original goal right on target, and are to<br>be applauded for that.  But in doing so, you missed a lot of other<br>targets that wouldn't have been hard to hit as well, with some<br>consideration of them.  I think.  But I wasn't there when you were making<br>the decisions, so it's real hard for me to say for sure.  I'm speaking<br>from hindsight, but you had the tough problem of figuring out what to do<br>without such benefit.</p><p>Now, *modified* Minix is usable.  Add a bigger buffer cache.  Modify it<br>so that it can take advantage of 386 protected mode.  Fix the tty driver<br>so that it will give you multiple consoles.  Fix the rs232 driver to deal<br>with DCD/DTR and do the right thing when carrier goes away.  Fix the pipes<br>so that read and write requests don't fail just because they happen to be<br>bigger than the size of a physical pipe.  Add shared text segments so you<br>maximize the use of your RAM.  Fix the scheduler so that it deals with<br>character I/O bound processes in a reasonable way.</p><div><p>&gt;When OS/360 was written in assembler for the IBM 360<br>&gt;25 years ago, they probably could be excused.  When MS-DOS was written<br>&gt;specifically for the 8088 ten years ago, this was less than brilliant, as<br>&gt;IBM and Microsoft now only too painfully realize. </p></div><p>Yeah, right.  Just what hardware do you think they'd like to port DOS to,<br>anyway?  I can't think of any.  I don't think IBM or Microsoft are<br>regretting *that* particular aspect of DOS.  Rather, they're probably<br>regretting the fact that it was written for the address space provided<br>by the 8088.</p><p>MS-DOS isn't less than brilliant because it was written for one machine<br>architecture.  It's less than brilliant because it doesn't do anything<br>well, *regardless* of its portability or lack thereof.</p><div><p><br>&gt;Writing a new OS only for the<br>&gt;386 in 1991 gets you your second 'F' for this term.  But if you do real well<br>&gt;on the final exam, you can still pass the course.</p></div><p>He made his code freely redistributable.  *You* didn't even do that.  Just<br>for that move alone, he scores points in my book.  Of course, the<br>distribution technology available to him is much better than what was<br>available when you did Minix, so it's hard to fault you for that...</p><p>But I must admit, Minix is still one hell of a bargain, and I would never<br>hesitate to recommend it to anyone who wants to learn something about Unix<br>and operating systems in general.  As a working operating system (i.e.,<br>one intended for a multi-user environment), however, I'd hesitate to<br>recommend it, except that there really aren't any good alternatives<br>(except Linux, of course, at least tentatively.  I can't say for sure,<br>since I haven't checked out Linux yet), since it doesn't have the performance<br>capabilities that a working operating system needs.</p><p><br>				Kevin Brown</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="PsAJDusEG6wJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Linus Benedict Torvalds" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i64">Linus Benedict Torvalds</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 11:33:23 AM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i64" role="region"><p>&gt;The limitations of MINIX relate at least partly to my being a professor:<br>&gt;An explicit design goal was to make it run on cheap hardware so students<br>&gt;could afford it.</p><p>All right: a real technical point, and one that made some of my comments<br>inexcusable.  But at the same time you shoot yourself in the foot a bit:<br>now you admit that some of the errors of minix were that it was too<br>portable: including machines that weren't really designed to run unix. <br>That assumption lead to the fact that minix now cannot easily be<br>extended to have things like paging, even for machines that would<br>support it.  Yes, minix is portable, but you can rewrite that as<br>"doesn't use any features", and still be right.</p><div><p>&gt;A multithreaded file system is only a performance hack.</p></div><p>Not true.  It's a performance hack /on a microkernel/, but it's an<br>automatic feature when you write a monolithic kernel - one area where<br>microkernels don't work too well (as I pointed out in my personal mail<br>to ast).  When writing a unix the "obsolete" way, you automatically get<br>a multithreaded kernel: every process does it's own job, and you don't<br>have to make ugly things like message queues to make it work<br>efficiently. </p><p>Besides, there are people who would consider "only a performance hack"<br>vital: unless you have a cray-3, I'd guess everybody gets tired of<br>waiting on the computer all the time. I know I did with minix (and yes,<br>I do with linux too, but it's /much/ better).</p><div><p>&gt;I still maintain the point that designing a monolithic kernel in 1991 is<br>&gt;a fundamental error.  Be thankful you are not my student.  You would not<br>&gt;get a high grade for such a design :-)</p></div><p>Well, I probably won't get too good grades even without you: I had an<br>argument (completely unrelated - not even pertaining to OS's) with the<br>person here at the university that teaches OS design.  I wonder when<br>I'll learn :)</p><div><p>&gt;My point is that writing a new operating system that is closely tied to any<br>&gt;particular piece of hardware, especially a weird one like the Intel line,<br>&gt;is basically wrong.</p></div><p>But /my/ point is that the operating system /isn't/ tied to any<br>processor line: UNIX runs on most real processors in existence.  Yes,<br>the /implementation/ is hardware-specific, but there's a HUGE<br>difference.  You mention OS/360 and MS-DOG as examples of bad designs<br>as they were hardware-dependent, and I agree.  But there's a big<br>difference between these and linux: linux API is portable (not due to my<br>clever design, but due to the fact that I decided to go for a fairly-<br>well-thought-out and tested OS: unix.)</p><p>If you write programs for linux today, you shouldn't have too many<br>surprises when you just recompile them for Hurd in the 21st century.  As<br>has been noted (not only by me), the linux kernel is a miniscule part of<br>a complete system: Full sources for linux currently runs to about 200kB<br>compressed - full sources to a somewhat complete developement system is<br>at least 10MB compressed (and easily much, much more). And all of that<br>source is portable, except for this tiny kernel that you can (provably:<br>I did it) re-write totally from scratch in less than a year without<br>having /any/ prior knowledge.</p><p>In fact the /whole/ linux kernel is much smaller than the 386-dependent<br>things in mach: i386.tar.Z for the current version of mach is well over<br>800kB compressed (823391 bytes according to <a href="http://nic.funet.fi/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://nic.funet.fi&amp;source=gmail&amp;ust=1739122202406000&amp;usg=AOvVaw3uapzGqnY2EYAssLIzg8iq">nic.funet.fi</a>).  Admittedly,<br>mach is "somewhat" bigger and has more features, but that should still<br>tell you something. </p><p>		Linus<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="1U_2QQNIukwJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="-Pete French." jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i68">-Pete French.</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 10:49:37 AM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i68" role="region"><p>in article &lt;<a href="" data-email-masked="" rel="nofollow">1992Jan30....@epas.toronto.edu</a>&gt;, <a href="" data-email-masked="" rel="nofollow">meg...@epas.utoronto.ca</a> (David Megginson) says:<br>&gt; Nntp-Posting-Host: <a href="http://epas.utoronto.ca/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://epas.utoronto.ca&amp;source=gmail&amp;ust=1739122202407000&amp;usg=AOvVaw09yJGNlwr3DseSjYL2wriy">epas.utoronto.ca</a></p><div><p>&gt; <br>&gt; In article &lt;1992Jan30.1857...@netcom.COM&gt; feu...@netcom.COM (David Feustel) writes:<br>&gt;&gt;<br>&gt;&gt;That's ok. Einstein got lousy grades in math and physics.<br>&gt; <br>&gt; And Dan Quayle got low grades in political science. I think that there<br>&gt; are more Dan Quayles than Einsteins out there... ;-)</p></div><p>What a horrible thought !</p><p>But on the points about microkernel v monolithic, isnt this partly an<br>artifact of the language being used ? MINIX may well be designed as a<br>microkernel system, but in the end you still end up with a large<br>monolithic chunk of binary data that gets loaded in as "the OS". Isnt it<br>written as separate programs simply because C does not support the idea<br>of multiple processes within a single piece of monolithic code. Is there<br>any real difference between a microkernel written as several pieces of C<br>and a monolithic kernel written in something like OCCAM ? I would have<br>thought that in this case the monolithic design would be a better one<br>than the micorkernel style since with the advantage of inbuilt<br>language concurrency the kernel could be made even more modular than the<br>MINIX one is.</p><p>Anyone for MINOX :-)</p><p>-bat.<br>-- <br>-Pete French. (the -bat. )         / <br>Adaptive Systems Engineering      /  <br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="eS0LjiryjoIJ" data-subject="ast's comments on OS's [was Re: LINUX is obsolete]" data-is-first="false" data-author="Jyrki Kuoppala" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i72">Jyrki Kuoppala</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 1:07:46 PM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i72" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">12...@star.cs.vu.nl</a>&gt;, ast@cs (Andy Tanenbaum) writes:<br>&gt;who want to turn MINIX in BSD UNIX off my back.  But in all honesty, I would<br>&gt;suggest that people who want a **MODERN** "free" OS look around for a <br>&gt;microkernel-based, portable OS, like maybe GNU or something like that.</p><p>I hear bsd 4.4 might also become free and appear in the near future<br>for the 386, also someone's supposed to be working on bsd 4.4 on top<br>of the Mach microkernel, and then there's of course GNU.  Currently of<br>course for many people Linux is the OS to use because it's here now,<br>is free and works.</p><div><p>&gt;P.S. Just as a random aside, Amoeba has a UNIX emulator (running in user<br>&gt;space), but it is far from complete.  If there are any people who would<br>&gt;like to work on that, please let me know.  To run Amoeba you need a few 386s,<br>&gt;one of which needs 16M, and all of which need the WD Ethernet card.</p></div><p>A note here, the sources I've seen seem to imply that Amoeba will not<br>be free as in you won't be able to use it, copy it, enhance it, share<br>it etc. without paying $$ and/or asking permission from someone.</p><p>//Jyrki<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="hN66iNTFKQMJ" data-subject="Apologies (was Re: LINUX is obsolete)" data-is-first="false" data-author="Ari Lemmke" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i76">Ari Lemmke</h3></p><p><span>unread,</span></p><div><p><span>Feb 1, 1992, 12:38:50 AM</span><span>2/1/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i76" role="region"><p>:   And reply I did, with complete abandon, and no thought for good taste<br>:   and netiquette.  Apologies to ast, and thanks to John Nall for a friendy<br>:   "that's not how it's done"-letter.  I over-reacted, and am now composing</p><p>	I didn't and still don't see anything wrong to FOLLOUP, if<br>	I'm getting *bashed* on the net. Linus' article was clear<br>	and not against 'good taste' (what ever that is).</p><p>	Linus doesn't have anything to apologise, not even on<br>	comp.os.minix.</p><p>:		   Linus "my first, and hopefully last flamefest" Torvalds</p><p>	arl		// has nothing to do what I'm thinking about<br>			// Minix or Linux.<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="euCA2UUMBHYJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Douglas Graham" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i80">Douglas Graham</h3></p><p><span>unread,</span></p><div><p><span>Feb 1, 1992, 1:26:30 AM</span><span>2/1/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i80" role="region"><p>&gt;   While I could go into a long story here about the relative merits of the<br>&gt;   two designs, suffice it to say that among the people who actually design<br>&gt;   operating systems, the debate is essentially over.  Microkernels have won.</p><p>Can you recommend any (unbiased) literature that points out the strengths<br>and weaknesses of the two approaches?  I'm sure that there is something<br>to be said for the microkernel approach, but I wonder how closely<br>Minix resembles the other systems that use it.  Sure, Minix uses lots<br>of tasks and messages, but there must be more to a microkernel architecture<br>than that.  I suspect that the Minix code is not split optimally into tasks.</p><div><p>&gt;   The only real argument for monolithic systems was performance, and there<br>&gt;   is now enough evidence showing that microkernel systems can be just as<br>&gt;   fast as monolithic systems (e.g., Rick Rashid has published papers comparing<br>&gt;   Mach 3.0 to monolithic systems) that it is now all over but the shoutin`.</p></div><p>My main complaint with Minix is not it's performance.  It is that adding<br>features is a royal pain -- something that I presume a microkernel<br>architecure is supposed to alleviate.</p><div><p>&gt;   MINIX is a microkernel-based system.</p></div><p>Is there a consensus on this?</p><div><p>&gt;   LINUX is<br>&gt;   a monolithic style system.  This is a giant step back into the 1970s.<br>&gt;   That is like taking an existing, working C program and rewriting it in<br>&gt;   BASIC.  To me, writing a monolithic system in 1991 is a truly poor idea.</p></div><p>This is a fine assertion, but I've yet to see any rationale for it.<br>Linux is only about 12000 lines of code I think.  I don't see how<br>splitting that into tasks and blasting messages around would improve it.</p><div><p>&gt;Don`t get me wrong, I am not unhappy with LINUX.  It will get all the people<br>&gt;who want to turn MINIX in BSD UNIX off my back.  But in all honesty, I would<br>&gt;suggest that people who want a **MODERN** "free" OS look around for a <br>&gt;microkernel-based, portable OS, like maybe GNU or something like that.</p></div><p>Well, there are no other choices that I'm aware of at the moment.  But<br>when GNU OS comes out, I'll very likely jump ship again.  I sense that<br>you *are* somewhat unhappy about Linux (and that surprises me somewhat).<br>I would guess that the reason so many people embraced it, is because it<br>offers more features.  Your approach to people requesting features in<br>Minix, has generally been to tell them that they didn't really want that<br>feature anyway.  I submit that the exodus in the direction of Linux<br>proves you wrong.</p><p>Disclaimer:  I had nothing to do with Linux development.  I just find<br>             it an easier system to understand than Minix.<br>--<br>Doug Graham         <a href="" data-email-masked="" rel="nofollow">dgr...@bnr.ca</a>         My opinions are my own.<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="2GV6euGK_N0J" data-subject="LINUX is obsolete" data-is-first="false" data-author="Charles Hedrick" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i84">Charles Hedrick</h3></p><p><span>unread,</span></p><div><p><span>Feb 1, 1992, 1:27:04 AM</span><span>2/1/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i84" role="region"><p>The history of software shows that availability wins out over<br>technical quality every time.  That's Linux' major advantage.  It's a<br>small 386-based system that's fairly compatible with generic Unix, and<br>is freely available.  I dropped out of the Minix community a couple of<br>years ago when it became clear that (1) Minix was not going to take<br>advantage of anything beyond the 8086 anytime in the near future, and<br>(2) the licensing -- while amazingly friendly -- still made it hard<br>for people who were interested in producing a 386 version.  Several<br>people apparently did nice work for the 386.  But all they could<br>distribute were diffs.  This made bringing up a 386 system a job that<br>isn't practical for a new user, and in fact I wasn't sure I wanted to<br>do it.  </p><p>I apologize if things have changed in the last couple of years.  If<br>it's now possible to get a 386 version in a form that's ready to run,<br>the community has developed a way to share Minix source, and bringing<br>up normal Unix programs has become easier in the interim, then I'm<br>willing to reconsider Minix.  I do like its design.</p><p>It's possible that Linux will be overtaken by Gnu or a free BSD.<br>However, if the Gnu OS follows the example of all other Gnu software,<br>it will require a system with 128MB of memory and a 1GB disk to use.<br>There will still be room for a small system.  My ideal OS would be 4.4<br>BSD.  But 4.4's release date has a history of extreme slippage.  With<br>most of their staff moving to BSDI, it's hard to believe that this<br>situation is going to be improved.  For my own personal use, the BSDI<br>system will probably be great.  But even their very attractive pricing<br>is likely to be too much for most of our students, and even though<br>users can get source from them, the fact that some of it is<br>proprietary will again mean that you can't just put altered code out<br>for public FTP.  At any rate, Linux exists, and the rest of these<br>alternatives are vapor.<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="JKtu6BbqpTEJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Theodore Y. Ts'o" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i88">Theodore Y. Ts'o</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 10:40:23 PM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i88" role="region"><p>&gt;From: <a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a> (Andy Tanenbaum)</p><p>&gt;<a href="http://ftp.cs.vu.nl/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://ftp.cs.vu.nl&amp;source=gmail&amp;ust=1739122202412000&amp;usg=AOvVaw2rxcE04RxqmEmHvgTKotyi">ftp.cs.vu.nl</a> =  192.31.231.42 in dir minix/simulator.)  I think it is a<br>&gt;gross error to design an OS for any specific architecture, since that is<br>&gt;not going to be around all that long.</p><p>It's not your fault for believing that Linux is tied to the 80386<br>architecture, since many Linux supporters (including Linus himself) have<br>made the this statement.  However, the amount of 80386-specific code is<br>probably not much more than what is in a Minix implementation, and there<br>is certainly a lot less 80386 specific code in Linux than here is<br>Vax-specific code in BSD 4.3.</p><p>Granted, the port to other architectures hasn't been done yet.  But if I<br>were going to bring up a Unix-like system on a new architecture, I'd<br>probably start with Linux rather than Minix, simply because I want to<br>have some control over what I can do with the resulting system when I'm<br>done with it.  Yes, I'd have to rewrite large portions of the VM and<br>device driver layers --- but I'd have to do that with any other OS.<br>Maybe it would be a little bit harder than it would to port Minix to the<br>new architecture; but this would probably be only true for the first<br>architecture that we ported Linux to.</p><div><p>&gt;While I could go into a long story here about the relative merits of the<br>&gt;two designs, suffice it to say that among the people who actually design<br>&gt;operating systems, the debate is essentially over.  Microkernels have won.<br>&gt;The only real argument for monolithic systems was performance, and there<br>&gt;is now enough evidence showing that microkernel systems can be just as<br>&gt;fast as monolithic systems (e.g., Rick Rashid has published papers comparing<br>&gt;Mach 3.0 to monolithic systems) that it is now all over but the shoutin`.</p></div><p>This is not necessarily the case; I think you're painting a much more<br>black and white view of the universe than necessarily exists.  I refer<br>you to such papers as Brent Welsh's (<a href="" data-email-masked="" rel="nofollow">we...@parc.xerox.com</a>) "The<br>Filsystem Belongs in the Kernel" paper, where in he argues that the<br>filesystem is a mature enough abstraction that it should live in the<br>kernel, not outside of it as it would in a strict microkernel design.</p><p>There also several people who have been concerned about the speed of<br>OSF/1 Mach when compared with monolithic systems; in particular, the<br>nubmer of context switches required to handle network traffic, and<br>networked filesystems in particular.</p><p>I am aware of the benefits of a micro kernel approach.  However, the<br>fact remains that Linux is here, and GNU isn't --- and people have been<br>working on Hurd for a lot longer than Linus has been working on Linux.<br>Minix doesn't count because it's not free.  :-)  </p><p>I suspect that the balance of micro kernels versus monolithic kernels<br>depend on what you're doing.  If you're interested in doing research, it<br>is obviously much easier to rip out and replace modules in a micro<br>kernel, and since only researchers write papers about operating systems,<br>ipso facto micro kernels must be the right approach.  However, I do know<br>a lot of people who are not researchers, but who are rather practical<br>kernel programmers, who have a lot of concerns over the cost of copying<br>and the cost of context switches which are incurred in a micro kernel.</p><p>By the way, I don't buy your arguments that you don't need a<br>multi-threaded filesystem on a single user system.  Once you bring up a<br>windowing system, and have a compile going in one window, a news reader<br>in another window, and UUCP/C News going in the background, you want<br>good filesystem performance, even on a single-user system.  Maybe to a<br>theorist it's an unnecessary optimization and a (to use your words)<br>"performance hack", but I'm interested in a Real operating system ---<br>not a research toy.<br>=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=<br>Theodore Ts'o				bloom-beacon!mit-athena!tytso<br>308 High St., Medford, MA 02155		<a href="" data-email-masked="" rel="nofollow">ty...@athena.mit.edu</a><br>   Everybody's playing the game, but nobody's rules are the same!</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="mnFNFXSKkQEJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="j...@jshark.rn.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i92">j...@jshark.rn.com</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 1:55:21 PM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i92" role="region"><p>&gt;In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Jan29.1...@epas.toronto.edu</a>&gt; <a href="" data-email-masked="" rel="nofollow">meg...@epas.utoronto.ca</a> (David Megginson) writes:<br>&gt;&gt;<br>&gt;&gt;Why does the<br>&gt;&gt;Intel architecture _not_ allow drivers to be independent programs?<br>&gt;<br>&gt;The drivers have to read and write the device registers in I/O space, and<br>&gt;this cannot be done in user mode on the 286 and 386. If it were possible<br>&gt;to do I/O in a protected way in user space,</p><p>[[We must be talking about protected mode]] *THIS IS UNTRUE*</p><p>The Intel architecture supports independent tasks, each of which can be<br>given a "i/o privilege level". The convenient approach, used by iRMX(?), is<br>to "build" a load image ("root" device driver, kernel, MM and FS). Once<br>booted, these could be replaced by loadable tasks from disc (or network...)<br>and given a suitable privilege level.</p><p>The '386 additionally allows each task to have an "i/o permissions bitmap"<br>which specifies exactly which ports can be used.<br>(See "80386 Programmers Reference Manual", chapter 8)</p><div><p>&gt;                                            all the I/O tasks could have<br>&gt;been user programs, like FS and MM.</p></div><p>Do you really mean "user programs" and not "separate tasks" ??</p><p>Separate tasks, possibly privileged, I'll agree with.</p><p>User level programs may be ok for teaching operating system principles, or on<br>toy computers :-)  But a "production" system?  Not on my machines!</p><p>&gt;Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>)</p><p>joe.<br>-- <br><a href="" data-email-masked="" rel="nofollow">j...@jshark.rn.com</a><br>uunet!nstar!jshark!joe<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="0N9YlDqsQcAJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="j...@jshark.rn.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i96">j...@jshark.rn.com</h3></p><p><span>unread,</span></p><div><p><span>Jan 31, 1992, 2:21:44 PM</span><span>1/31/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i96" role="region"><p>&gt;   MINIX was designed to be reasonably portable, and has been ported from the<br>&gt;   Intel line to the 680x0 (Atari, Amiga, Macintosh), SPARC, and NS32016.<br>&gt;   LINUX is tied fairly closely to the 80x86.  Not the way to go.</p><p>If you looked at the source instead of believing the author, you'd realise<br>this is not true!</p><p>He's replaced 'fubyte' by a routine which explicitly uses a segment register<br>- but that could be easily changed. Similarly, apart from a couple of places<br>which assume the '386 MMU, a couple of macros to hide the exact page sizes<br>etc would make porting trivial. Using '386 TSS's makes the code simpler,<br>but the VAX and WE32000 have similar structures.</p><p>As he's already admitted, a bit of planning would have the the system<br>neater, but merely putting '386 assembler around isn't a crime!</p><p>And with all due respect:<br>  - the Book didn't make an issue of portability (apart from a few<br>    "#ifdef M8088"s)<br>  - by the time it was released, Minix had come to depend on several<br>    8086 "features" that caused uproar from the 68000 users.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="nVk_FwrUX0kJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Will Rose" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i100">Will Rose</h3></p><p><span>unread,</span></p><div><p><span>Feb 1, 1992, 1:16:12 PM</span><span>2/1/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i100" role="region"><p>I've used Minix quite a bit on a PC XT, from version 1.2 onwards, and<br>a couple of points seem worth making.  Firstly that I ordered version<br>1.1 from Prentice Hall, and am devoutly thankful that they delayed my<br>order until 1.2 was available.  The first version of something as<br>complicated as an OS is only for the dedicated, and that goes for Linux<br>too I should think.</p><p>Secondly Minix has evolved to a reliable OS on its original PC platform,<br>but is still getting there on eg. the Mac; these things do take time.</p><p>Thirdly even (standard) PC 1.5 Minix won't run a lot of current Unix<br>software.  Partly this is a matter of the hardware being too limited,<br>and partly a matter of Minix being too limited in eg: the tty driver.<br>(And even this tty driver took a lot of sorting out in the early days).</p><p>Fourthly, I bought my XT four years ago - the motherboard was $110,<br>and memory (falling in price) was $7.00 per 256KB chip.  Last autumn<br>I bought my wife an XT to replace her CP/M word-processor - the m/b<br>was $50, and memory was $1.50 a chip.  This week I replaced a dead<br>286 board for a friend - the drop-in 16MHz 386SX was $140, and memory<br>was $40 for 9 x 1MB...  If I actually wanted an OS to use today, I<br>think I'd go with Linux; but if I wanted to learn about OS's, I think<br>I'd use Minix.  It looks as if they both do what they were designed<br>to do.</p><p>Will<br><a href="" data-email-masked="" rel="nofollow">c...@pnet01.cts.com</a><br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="HKRPLyXSr6MJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="n.h.chandler" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i104">n.h.chandler</h3></p><p><span>unread,</span></p><div><p><span>Feb 2, 1992, 2:38:51 AM</span><span>2/2/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i104" role="region"><p>I have been following the Minix/Linux discussion.  How<br>can I get a copy of Linux?</p><p>Neville H. Chandler<br>cbnewsj!<a href="" data-email-masked="" rel="nofollow">n...@att.com</a><br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="6myOFI3RgLMJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Drew Eckhardt" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i108">Drew Eckhardt</h3></p><p><span>unread,</span></p><div><p><span>Feb 2, 1992, 1:17:44 PM</span><span>2/2/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i108" role="region"><p>Every 386 TSS has an iopermission bitmap.  If the CPL is of a lower priveledge<br>level than IOPL, the io permissions bitmap is consulted, allowing protection<br>on a port by port basis.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="x1_asEbpIncJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Allan Duncan" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i112">Allan Duncan</h3></p><p><span>unread,</span></p><div><p><span>Feb 2, 1992, 11:06:26 PM</span><span>2/2/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i112" role="region"><p>From article &lt;<a href="" data-email-masked="" rel="nofollow">1992Jan30....@menudo.uh.edu</a>&gt;, by <a href="" data-email-masked="" rel="nofollow">ke...@nuchat.sccsi.com</a> (Kevin Brown):</p><div><p> &gt; The *entire* system call interface in Minix needs to be rethought.  As it<br>&gt; stands right now, the file system is not just a file system, it's also a<br>&gt; system-call server.  That functionality needs to be separated out in order<br>&gt; to facilitate a multiple file system architecture.  Message passing is<br>&gt; probably the right way to go about making the call and waiting for it, but<br>&gt; the message should go to a system call server, not the file system itself.<br>&gt; <br>&gt; In order to handle all the special caveats of the Unix API, you end up writing<br>&gt; a monolithic "kernel" even if you're using a microkernel base.  You end up<br>&gt; with something called a "server", and an example is the BSD server that runs<br>&gt; under Mach.<br>&gt; <br>&gt; And, in any case, the message-passing in Minix needs to be completely redone.<br>&gt; As it is, it's a kludge.  I've been giving this some thought, but I haven't<br>&gt; had time to do anything with what I've thought of so far.  Suffice it to say<br>&gt; that the proper way to do message-passing is probably with message ports<br>&gt; (both public and private), with the various visible parts of the operating<br>&gt; system having public message ports.  Chances are, that ends up being the<br>&gt; system call server only, though this will, of course, depend on the goals<br>&gt; of the design.</p></div><p>It gets to sound more and more like Tripos and the Amiga :-)</p><p>Allan Duncan	ACSnet	 adu...@trl.oz<br>(+613) 541 6708	Internet <a href="" data-email-masked="" rel="nofollow">adu...@trl.oz.au</a><br>		UUCP	 {uunet,hplabs,ukc}!munnari!<a href="http://trl.oz.au/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://trl.oz.au&amp;source=gmail&amp;ust=1739122202417000&amp;usg=AOvVaw0aitcDqmeNv3qMVgq3PZbB">trl.oz.au</a>!aduncan<br>Telecom Research Labs, PO Box 249, Clayton, Victoria, 3168, Australia.<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="MYRbhmwzIzYJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="j...@jshark.rn.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i116">j...@jshark.rn.com</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 12:59:12 AM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i116" role="region"><p>&gt;I was in the U.S. for a couple of weeks, so I haven't commented much on<br>&gt;LINUX (not that I would have said much had I been around), but for what <br>&gt;it is worth, I have a couple of comments now.</p><p>Maybe keepng quiet would have been best.</p><div><p>&gt;1. MICROKERNEL VS MONOLITHIC SYSTEM<br>&gt;<br></p></div><div><p>&gt;   While I could go into a long story here about the relative merits of the<br>&gt;   two designs, suffice it to say that among the people who actually design<br>&gt;   operating systems, the debate is essentially over.</p></div><p>No, MS-DOS won. Sad, but there you are. 60 million: Next</p><p>It would be churlish to point out that MS-DOS has loadable device drivers<br>and that VMS is now (basically)a set of loadable service modules and drivers.</p><p>"Microkernel" was the buzz-word of last year, so Minix is a microkernel.<br>"Object-oriented" is this years, so Minix is object-oriented - right?</p><p><br>joe.<br> ----<br><a href="" data-email-masked="" rel="nofollow">j...@jshark.rn.com</a><br>uunet!nstar!jshark!joe</p><p>I'm a mutated .sig virus, I got this from Henry Spencer's:<br>"As a user, I'll take speed over features anyday" - A Tanenbaum<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="NohopA70nesJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Kevin Brown" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i120">Kevin Brown</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 6:12:58 AM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i120" role="region"><p>It has been brought to my attention that my last posting was exceedingly<br>harsh.  Having reread it, I'm inclined to agree.</p><p>Dr. Tanenbaum claims that the microkernel architecture is the way to go.<br>He has a great deal more experience with operating systems than I have.<br>It's an understatement that it's likely that there's some substance to<br>his statement.  :-)</p><p>Many of the things I said in my previous posting were more a result of my<br>philosophical viewpoint on operating systems and programming in general<br>than experience.  And the particular viewpoint I hold that's relevent to<br>the discussion says that the method of implementation chosen depends on<br>the design goals, and that there is no "wrong" or "right" way to do things<br>that is independent of such goals.  Thus, my statement that a monolithic<br>kernel follows from some design goals, e.g. ease of implementation of the<br>semantics of the Unix API.  In particular, the ease of implementing things<br>like signal handling, premature system call termination, etc.  At least,<br>that's the conclusion I come to when I think about the problem.</p><p>My experience with Minix says that there are a number of things that should<br>not go in a user process, things that are better left in the kernel.  Things<br>like memory allocation (which requires global knowledge of the hardware,<br>something that a user process should, IMHO, not have) and signal handling <br>(which requires building stack frames).</p><p>чіSo from my point of view, the architecture of Minix is not ideal.  While<br>it may win in that it's a "microkernel" architecture, the division of<br>functionality is not entirely to my liking.  As is undoubtedly plainly<br>obvious by now.  :-)</p><p>Despite that, Minix is quite usable in many ways as a personal operating<br>system, i.e. one where there is usually only one person logged into the<br>system.  If I gave the impression that I thought it was unusable in general,<br>then I apologize for that.</p><p>However, as a *multiuser* operating system, ютi.e. an operating system designed<br>to efficiently meet the needs of multiple users simultaneously while also<br>performing batch operations, Minix is lacking, as far as I'm concerned.  <br>The main reason, of course, is the single-threaded file system (hereafter,<br>STFS).  Now, Dr. Tanenbaum may feel that a multi-threaded file system <br>(hereafter, MTFS) is merely a performance hack.  Perhaps he's right. <br>Perhaps the architecture of a MTFS is sufficiently similar to that of a<br>STFS that his assessment is correct.  My vision of a MTFS may differ<br>significantly from his, and this would explain why he and I seem to have<br>a difference of opinion on this matter.  Regardless of whether or not a<br>MTFS is a "performance hack", for a *multiuser* operating system, I think<br>there are a lot of good arguments that say that a MTFS is a *necessary*<br>"performance hack".  Provided, of course, that one does not have infinite<br>buffer cache resources.  :-)</p><p>There are other things I feel Minix lacks as well.  The ability to allocate<br>memory in the kernel is one (such an ability would allow any user process,<br>e.g. device drivers and the file system, to allocate memory dynamically.<br>This is useful for doing things like resizing the buffer cache on the fly,<br>etc.  The ability to pass arbitrarily sized messages, optionally via shared<br>memory, is another (such an ability might be limited by constraints like<br>page size and such).</p><p><br>However much Minix may be lacking from my standpoint, it is nevertheless<br>a very useful and welcome enhancement to my system.  In spite of the<br>impression that I may have given everyone in my last posting, there will<br>always be a soft spot in my heart for it, if only because it's the first<br>decent operating system I've had on my system that I've had source to.<br>I don't have to tell you people how incredibly useful it is to have source.<br>You already know.</p><p>It is very important to me to have source code to the things I run.  It<br>bothers me a great deal to run things that I don't have source to.  Even<br>the C compiler.  And the less expensive the source is, the better.  This<br>is why Dr. Tanenbaum's statements about Linux touched a raw nerve with me:<br>Linux comes with source *and* it's free.  And it's available right now.</p><p>Someone, either here on this newsgroup or over on alt.os.linux, made a<br>very valid observation: the cost of a 16 MHz 386SX system is about $140<br>more than a comparably equipped (in terms of RAM size, display technology,<br>hard drive space, etc.) 8088 system.  Minix is $169.  In economic terms,<br>Linux wins if you have to buy Minix.</p><p>Where Minix wins (or is at least even :-) is when you can get it for free<br>via the educational distribution clause of the license agreement.  However,<br>Minix will run even better on a 16 MHz 386SX than on an 8088.  If I were<br>a student, I'd get the 386SX unless I simply didn't have a choice.  Then<br>I'd get whichever operating system I could get for the least cost.  If I<br>could get both for free, then I'd get both.  :-)</p><p><br>Given the reasons Linus wrote Linux, I think it's hard for anyone to fault<br>him for writing it the way he did.  And he was extremely nice in making<br>his code freely available to the rest of the world.  It's not something he<br>had to do.  In my book, that makes him almost beyond reproach.</p><p><br>Dr. Tanenbaum didn't make Minix free.  His goals were different.  Minix<br>is a teaching aid above all else (unless Dr. Tanenbaum has changed his<br>views about Minix :-).  That means that he must be concerned with the<br>most efficient way to get Minix to the student population.  At the time<br>Minix was released, Prentice-Hall was a good solution, and has been for<br>some time.  However, I must wonder whether or not this is still the case.<br>Dr. Tanenbaum: do you still feel that free distribution of Minix via the<br>net is not the best way to distribute Minix?</p><p><br>Which wins?  Minix or Linux?  Depends on how you measure them...</p><p><br>				Kevin Brown</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="WgotGesYaqwJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="peter da silva" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i124">peter da silva</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 5:22:32 PM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i124" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Jan31....@ohm.york.ac.uk</a>&gt; <a href="" data-email-masked="" rel="nofollow">pe...@ohm.york.ac.uk</a> (-Pete French.) writes:<br>&gt; But on the points about microkernel v monolithic, isnt this partly an<br>&gt; artifact of the language being used ?</p><p>I doubt it.</p><p>  [isn't MINIX]</p><div><p><br>&gt; written as separate programs simply because C does not support the idea<br>&gt; of multiple processes within a single piece of monolithic code.</p></div><p>C doesn't support formatted I/O either, but it can be implemented quite<br>effectively in C. So can concurrent processes. I've done it, in fact.<br>The resulting code is 90% portable (the 10% being the code that handles<br>the context switch).<br>-- <br>-- Peter da Silva,  Ferranti International Controls Corporation<br>-- Sugar Land, TX  77487-5012;  <a href="tel:(713)%20274-5180" value="+17132745180" target="_blank" rel="nofollow">+1 713 274 5180</a><br>-- "Have you hugged your wolf today?"<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="EkNZTd0VAJwJ" data-subject="What good does this war do? (Re: LINUX is obsolete)" data-is-first="false" data-author="peter da silva" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i128">peter da silva</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 5:37:24 PM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i128" role="region"><p>Will you quit flaming each other?</p><p>I mean, linux is designed to provide a reasonably high performance environment<br>on a hardware platform crippled by years of backwards-compatible kludges. Minix<br>is designed as a teaching tool. Neither is that good at doing the other's job,<br>and why should they? The fact that Minix runs out of steam quickly (and it<br>does) isn't a problem in its chosen mileau. It's sure better than the TOY<br>operating system. The fact that Linux isn't transportable beyond the 386/AT<br>platform isn't a problem when there are millions of them out there (and quite<br>cheap: you can get a 386/SX for well under $1000).</p><p>A monolithic kernel is easy enough to build that it's worth doing it if it gets<br>a system out the door early. Think of it as a performance hack for programmer<br>time. The API is portable. You can replace the kernel with a microkernel<br>design (and MINIX isn't the be-all and end-all of microkernel designs either:<br>even for low end PCs... look at AmigaOS) without disturbing the applications.<br>That's the whole point of a portable API in the first place.</p><p>Microkernels are definitely a better design for many tasks. I takes more<br>work to make them efficient, so a simpler design that doesn't take advantage<br>of the microkernel in any real way is worth doing for pedagogical reasons.<br>Think of it as a performance hack for student time. The design is still good<br>and when you can get an API to the microkernel interface you can get VERY<br>impressive performance (thousands of context switches per second on an 8<br>MHz 68000).</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="eJ4V_hBY-QQJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="peter da silva" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i132">peter da silva</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 6:40:06 PM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i132" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb01.0...@bmerh2.bnr.ca</a>&gt; <a href="" data-email-masked="" rel="nofollow">dgr...@bmers30.bnr.ca</a> (Douglas Graham) writes:<br>&gt; Minix resembles the other systems that use it.  Sure, Minix uses lots<br>&gt; of tasks and messages, but there must be more to a microkernel architecture<br>&gt; than that.  I suspect that the Minix code is not split optimally into tasks.</p><p>Definitely. Minix shows you how a microkernel works, but it sure doesn't show<br>you why you would use one.</p><p>A couple of years ago I brought this up with Andy, and his response indicated<br>that he was himself not convinced of the superiority of the microkernel design<br>at the time. He said (as near as I can recall... this is a paraphrase) that a<br>message passing design was inherently slower than a monolithic one... which was<br>news to me: I had (and still have) a PC that was MUCH more responsive than any<br>UNIX box I ever touched using a message-passing design.</p><div><p>&gt; &gt;   MINIX is a microkernel-based system.</p></div><div><p>&gt; Is there a consensus on this?</p></div><p>Yes, it's not a well-factored one, and there's no API to the microkernel<br>interface, but it's a microkernel design.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="icnz_9HLyzAJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Richard Tobin" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i136">Richard Tobin</h3></p><p><span>unread,</span></p><div><p><span>Feb 4, 1992, 3:46:49 PM</span><span>2/4/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i136" role="region"><p>&gt;A multithreaded file system is only a performance hack.  When there is only</p><div><p>&gt;one job active, the normal case on a small PC, it buys you nothing </p></div><p>I find the single-threaded file system a serious pain when using<br>Minix.  I often want to do something else while reading files from the<br>(excruciatingly slow) floppy disk.  I rather like to play rogue while<br>waiting for large C or Lisp compilations.  I look to look at files in<br>one editor buffer while compiling in another.</p><p>(The problem would be somewhat less if the file system stuck to<br>serving files and didn't interact with terminal i/o.)</p><p>Of course, in basic Minix with no virtual consoles and no chance of<br>running emacs, this isn't much of a problem.  But to most people<br>that's a failure, not an advantage.  It just isn't the case that on<br>single-user machines there's no use for more than one active process;<br>the idea only has any plausibility because so many people are used to<br>poor machines with poor operating systems.</p><p>As to portability, Minix only wins because of its limited ambitions.<br>If you wanted a full-featured Unix with paging, job-control, a window<br>system and so on, would it be quicker to start from basic Minix and<br>add the features, or to start from Linux and fix the 386-specific<br>bits?  I don't think it's fair to criticise Linux when its aims are so<br>different from Minix's.  If you want a system for pedagogical use,<br>Minix is the answer.  But if what you want is an environment as much<br>like (say) a Sun as possible on your home computer, it has some<br>deficiencies.</p><p>-- Richard<br>-- <br>Richard Tobin,<br>AI Applications Institute,                                <a href="" data-email-masked="" rel="nofollow">R.T...@ed.ac.uk</a><br>Edinburgh University.<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="P6X-qODKsjQJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Ken Thompson" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i140">Ken Thompson</h3></p><p><span>unread,</span></p><div><p><span>Feb 4, 1992, 12:07:54 AM</span><span>2/4/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i140" role="region"><p>viewpoint may be largely unrelated to its usefulness. Many if not<br>most of the software we use is probably obsolete according to the <br>latest design criteria. Most users could probably care less if the<br>internals of the operating system they use is obsolete. They are<br>rightly more interested in its performance and capabilities at the<br>user level.</p><p>I would generally agree that microkernels are probably the wave of<br>the future. However, it is in my opinion easier to implement a<br>monolithic kernel. It is also easier for it to turn into a mess in<br>a hurry as it is modified.</p><p>				Regards,<br>					Ken </p><p>-- <br>Ken Thompson  GTRI, Ga. Tech, Atlanta Ga. 30332 Internet:!<a href="" data-email-masked="" rel="nofollow">k...@prism.gatech.edu</a><br>uucp:...!{allegra,amd,hplabs,ut-ngp}!gatech!prism!kt4<br>"Rowe's Rule: The odds are five to six that the light at the end of the<br>tunnel is the headlight of an oncoming train."       -- Paul Dickson<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="Thq9pWZUWVsJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Kevin Brown" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i144">Kevin Brown</h3></p><p><span>unread,</span></p><div><p><span>Feb 4, 1992, 9:08:42 AM</span><span>2/4/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i144" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">47...@hydra.gatech.EDU</a>&gt; <a href="" data-email-masked="" rel="nofollow">k...@prism.gatech.EDU</a> (Ken Thompson) writes:<br>&gt;viewpoint may be largely unrelated to its usefulness. Many if not<br>&gt;most of the software we use is probably obsolete according to the <br>&gt;latest design criteria. Most users could probably care less if the<br>&gt;internals of the operating system they use is obsolete. They are<br>&gt;rightly more interested in its performance and capabilities at the<br>&gt;user level.<br>&gt;<br>&gt;I would generally agree that microkernels are probably the wave of<br>&gt;the future. However, it is in my opinion easier to implement a<br>&gt;monolithic kernel. It is also easier for it to turn into a mess in<br>&gt;a hurry as it is modified.</p><p>How difficult is it to structure the source tree of a monolithic kernel<br>such that most modifications don't have a large negative impact on the<br>source?  What sorts of pitfalls do you run into in this sort of endeavor,<br>and what suggestions do you have for dealing with them?</p><p>I guess what I'm asking is: how difficult is it to organize the source<br>such that most changes to the kernel remain localized in scope, even<br>though the kernel itself is monolithic?</p><p>I figure you've got years of experience with monolithic kernels :-),<br>so I'd think you'd have the best shot at answering questions like<br>these.</p><div><p>&gt;Ken Thompson  GTRI, Ga. Tech, Atlanta Ga. 30332 Internet:!<a href="" data-email-masked="" rel="nofollow">k...@prism.gatech.edu</a><br>&gt;uucp:...!{allegra,amd,hplabs,ut-ngp}!gatech!prism!kt4<br>&gt;"Rowe's Rule: The odds are five to six that the light at the end of the<br>&gt;tunnel is the headlight of an oncoming train."       -- Paul Dickson</p></div><p>				Kevin Brown</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="SYlRvxEZvWwJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="peter da silva" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i148">peter da silva</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 6:32:54 PM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i148" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">TYTSO.92J...@SOS.mit.edu</a>&gt; <a href="" data-email-masked="" rel="nofollow">ty...@athena.mit.edu</a> (Theodore Y. Ts'o) writes:<br>&gt; This is not necessarily the case; I think you're painting a much more<br>&gt; black and white view of the universe than necessarily exists.  I refer<br>&gt; you to such papers as Brent Welsh's (<a href="" data-email-masked="" rel="nofollow">we...@parc.xerox.com</a>) "The<br>&gt; Filsystem Belongs in the Kernel" paper, where in he argues that the<br>&gt; filesystem is a mature enough abstraction that it should live in the<br>&gt; kernel, not outside of it as it would in a strict microkernel design.</p><p>What does "a mature enough abstraction" mean, here? Things don't move<br>into the kernel simply because they're now considered safe and stable<br>enough, but because they're too inefficient when they're outside it or<br>they lose functionality by being outside it, and there's no easy fix.</p><p>The Amiga operating system certainly benefits from having a file system<br>outside the kernel. There are dozens of file systems, many of them written<br>by hobbyists, available. Ideas like "assigned paths" can be played with<br>in the file system without breaking stuff. All these file systems have a<br>common interface and so look to the application as part of the operating<br>system, but just because something is on the other side of the API doesn't<br>mean it is, or belongs, in the kernel.</p><div><p>&gt; There also several people who have been concerned about the speed of<br>&gt; OSF/1 Mach when compared with monolithic systems; in particular, the<br>&gt; nubmer of context switches required to handle network traffic, and<br>&gt; networked filesystems in particular.</p></div><p>If this is because the networking was moved out of the kernel, I consider<br>it a price well worth paying. Having networking code in the kernel is the<br>source of many subtle bugs in networks. Just for something that bit us,<br>what happens if you need to get to the upper level driver before you can<br>acknowledge a packet, but the process that you need to run is hung up in<br>the tty driver waiting for a ^Q?</p><p>Something *I* would have expected to find in the kernel before now, yet<br>isn't, is windowing systems. With a microkernel (and the associated lower<br>*cost* of a context switch) you can get much of the advantages of a kernel<br>window system without paying the cost in complexity.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="irukTeGaYHIJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Kevin Brown" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i152">Kevin Brown</h3></p><p><span>unread,</span></p><div><p><span>Feb 4, 1992, 9:28:08 AM</span><span>2/4/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i152" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb2.2...@trl.oz.au</a>&gt; <a href="" data-email-masked="" rel="nofollow">adu...@rhea.trl.OZ.AU</a> (Allan Duncan) writes:<br>&gt;From article &lt;<a href="" data-email-masked="" rel="nofollow">1992Jan30....@menudo.uh.edu</a>&gt;, by <a href="" data-email-masked="" rel="nofollow">ke...@nuchat.sccsi.com</a> (Kevin Brown):<br>&gt; <br>&gt;&gt; The *entire* system call interface in Minix needs to be rethought.  As it<br>&gt;&gt; stands right now, the file system is not just a file system, it's also a<br>&gt;&gt; system-call server.  That functionality needs to be separated out in order<br>&gt;&gt; to facilitate a multiple file system architecture.  Message passing is<br>&gt;&gt; probably the right way to go about making the call and waiting for it, but<br>&gt;&gt; the message should go to a system call server, not the file system itself.<br>&gt;&gt; <br>&gt;&gt; In order to handle all the special caveats of the Unix API, you end up writing<br>&gt;&gt; a monolithic "kernel" even if you're using a microkernel base.  You end up<br>&gt;&gt; with something called a "server", and an example is the BSD server that runs<br>&gt;&gt; under Mach.<br>&gt;&gt; <br>&gt;&gt; And, in any case, the message-passing in Minix needs to be completely redone.<br>&gt;&gt; As it is, it's a kludge.  I've been giving this some thought, but I haven't<br>&gt;&gt; had time to do anything with what I've thought of so far.  Suffice it to say<br>&gt;&gt; that the proper way to do message-passing is probably with message ports<br>&gt;&gt; (both public and private), with the various visible parts of the operating<br>&gt;&gt; system having public message ports.  Chances are, that ends up being the<br>&gt;&gt; system call server only, though this will, of course, depend on the goals<br>&gt;&gt; of the design.<br>&gt; <br>&gt;It gets to sound more and more like Tripos and the Amiga :-)</p><p>There's no question that many of my ideas spring from the architecture<br>of the Amiga's operating system.  It's pretty impressive to see a<br>message-passing, multitasking operating system that operates as fast<br>as the Amiga's OS does on hardware that slow.  They did a lot of things<br>right.</p><p>There are some ideas that, I think, are my own.  Or, at least, that I've<br>developed independently.  For example, if you have a message-passing<br>system that includes the option to transfer message memory ownership to the<br>target process, then it naturally follows that you can globally optimize the<br>use of your block cache by making your block cache global with respect<br>to *all* filesystems.  The filesystem code requests blocks from the<br>block cache manager and tells the block cache manager what device driver<br>to call and what parameters to send it when flushing the block.  The block<br>cache manager replies with a message that is the size of a block (or, if<br>you wish to allocate several at a time, several blocks).  Since<br>ownership is transferred as a result of passing the message, the block<br>cache manager can allocate the memory itself, optionally flushing as<br>many blocks as it needs in order to free up enough to send to the caller.<br>The block cache manager is, of course, a user process.  If the filesystem<br>code is written right, you can kill the block cache manager in order to<br>disable the block cache.  The filesystem will simply do its thing<br>unbuffered.  Makes for a slow system, but at least you can do it.  You<br>can also change the behavior of the buffer cache by sending control<br>messages to the cache manager.  Can you say "tunable parameters"?  :-)</p><p>You could also accomplish this with some sort of shared memory, but this<br>would require semaphore control of the allocation list.  You'd also have<br>to figure out a way to flush bits of the cache when needed (easy to do<br>if you're a monolithic kernel, but I'm referring to a microkernel) without<br>colliding with another process writing into the block.  Semaphore control<br>of the individual blocks as well?</p><div><p>&gt;Allan Duncan	ACSnet	 adu...@trl.oz<br>&gt;(+613) 541 6708	Internet <a href="" data-email-masked="" rel="nofollow">adu...@trl.oz.au</a><br>&gt;		UUCP	 {uunet,hplabs,ukc}!munnari!<a href="http://trl.oz.au/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://trl.oz.au&amp;source=gmail&amp;ust=1739122202426000&amp;usg=AOvVaw09mCp72aXKD1fiL-SU7xzY">trl.oz.au</a>!aduncan<br>&gt;Telecom Research Labs, PO Box 249, Clayton, Victoria, 3168, Australia.</p></div><p>				Kevin Brown</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="TEGcz0cgAHcJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Julien Maisonneuve" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i156">Julien Maisonneuve</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 6:10:14 PM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i156" role="region"><p>I would like to second Kevin brown in most of his remarks.<br>I'll add a few user points :<br>- When ast states that FS multithreading is useless, it reminds me of the many<br>times I tried to let a job run in the background (like when reading an archive on<br>a floppy), it is just unusable, the &amp; shell operator could even have been left<br>out.<br>- Most interesting utilities are not even compilable under Minix because of the<br>ATK compiler's incredible limits. Those were hardly understandable on a basic PC,<br>but become absurd on a 386. Every stupid DOS compiler has a large model (more<br>expensive, OK). I hate the 13 bit compress !<br>- The lack of Virtual Memory support prevents people studying this area to<br>experiment, and prevents users to use large programs. The strange design of the<br>MM also makes it hard to modify.</p><p>The problem is that even doing exploratory work under minix is painful.<br>If you want to get any work done (or even fun), even DOS is becoming a better<br>alternative (with things like DJ GPP).<br>In its basic form, it is really no more than OS course example, a good<br>toy, but a toy. Obtaining and applying patches is a pain, and precludes further<br>upgrades.</p><p>Too bad when not so much is missing to make it really good.<br>Thanks for the work andy, but Linux didn't deserve your answer.<br>For the common people, it does many things better than Minix.</p><p>					Julien Maisonneuve.</p><p>This is not a flame, just my experience.<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="J4A54XkUHrUJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Michael L. Kaufman" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i160">Michael L. Kaufman</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 11:27:48 PM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i160" role="region"><p>I tried to send these two posts from work, but I think they got eaten. If you<br>have seen them already, sorry.</p><p>-------------------------------------------------------------------------------</p><p>Andy Tanenbaum writes an interesting article (also interesting was finding out<br>that he actually reads this group) but I think he is missing an important <br>point.</p><p>He Wrote:<br>&gt;As most of you know, for me MINIX is a hobby, ...</p><p>Which is also probably true of most, if not all, of the people who are involved<br>in Linux. We are not developing a system to take over the OS market, we are<br>just having a good time.</p><p>&gt;   What is going to happen<br>&gt;   is that they will gradually take over from the 80x86 line.  They will<br>&gt;   run old MS-DOS programs by interpreting the 80386 in software.</p><p>Well when this happens, if I still want to play with Linux, I can just run it<br>on my 386 simulator.</p><div><p>&gt;   MINIX was designed to be reasonably portable, and has been ported from the<br>&gt;   Intel line to the 680x0 (Atari, Amiga, Macintosh), SPARC, and NS32016.<br>&gt;   LINUX is tied fairly closely to the 80x86.  Not the way to go.</p></div><p>That's fine for the people who have those machines, but it wasn't a free <br>lunch. That portibility was gained at the cost of some performance and some <br>features on the 386. Before you decide that LINUX is not the way to go, you<br>should think about what it is going to be used for.  I am going to use it for<br>running memory and computation intensive graphics programs on my 486. For me,<br>speed and memory were more important then future state-of-the-artness and<br>portability.</p><div><p>&gt;But in all honesty, I would<br>&gt;suggest that people who want a **MODERN** "free" OS look around for a <br>&gt;microkernel-based, portable OS, like maybe GNU or something like that.</p></div><p>I don't know of any free microkernel-based, portable OSes. GNU is still<br>vaporware, and likely to remain that way for the forseeable future. Do <br>you actually have one to recomend, or are you just toying with me? ;-)</p><p>------------------------------------------------------------------------------</p><div><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">12...@star.cs.vu.nl</a>&gt; <a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a> (Andy Tanenbaum) writes:<br>&gt;My point is that writing a new operating system that is closely tied to any<br>&gt;particular piece of hardware, especially a weird one like the Intel line,<br></p></div><p>&gt;is basically wrong.  An OS itself should be easily portable to new hardware<br>&gt;platforms.</p><p>I think I see where I disagree with you now. You are looking at OS design<br>as an end in itself. Minix is good because it is portable/Micro-Kernal/etc.<br>Linux is not good because it is monolithic/tightly tied to Intel/etc. That<br>is not a strange attitude for someone in the acedemic world, but it is not<br>something you should expect to be universally shared. Linux is not being written<br>as a teaching tool, or as an abstract exercise. It is being written to allow<br>people to run GNU-type software _today_. The fact that it may not be in use<br>in five years is less important then the fact that today (well, by April<br>probably) I can run all sorts of software on it that I want to run. You keep<br>saying that Minix is better, but if it will not run the software that I want<br>to run, it really isn't that good (for me) at all.</p><div><p>&gt;                     When OS/360 was written in assembler for the IBM 360<br>&gt;25 years ago, they probably could be excused.  When MS-DOS was written<br>&gt;specifically for the 8088 ten years ago, this was less than brilliant, as<br>&gt;IBM and Microsoft now only too painfully realize.</p></div><p>Same point. MSoft did not come out with Dos to "explore the frontiers of os<br>research". They did it to make a buck. And considering the fact that MS-DOS<br>probably still outsells everyone else put together, I don't think that you <br>say that they have failed _in their goals_. Not that MS-Dos is the best OS<br>in terms of anything else, only that it has served their needs. </p><p>Michael</p><p><br>-- <br>Michael Kaufman | I've seen things you people wouldn't believe. Attack ships on<br> kaufman        | fire off the shoulder of Orion. I watched C-beams glitter in<br>  @<a href="http://eecs.nwu.edu/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://eecs.nwu.edu&amp;source=gmail&amp;ust=1739122202430000&amp;usg=AOvVaw25uBM7GJY15WDfAaoh8cbe">eecs.nwu.edu</a> | the dark near the Tannhauser gate. All those moments will be<br>                | lost in time - like tears in rain. Time to die.     Roy Batty <br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="sETlccbNYMgJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Jonathan Allen" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i164">Jonathan Allen</h3></p><p><span>unread,</span></p><div><p><span>Feb 3, 1992, 8:43:00 AM</span><span>2/3/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i164" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">12...@star.cs.vu.nl</a>&gt;, <a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a> (Andy Tanenbaum) wrote:<br>&gt; In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Jan29.1...@epas.toronto.edu</a>&gt; <a href="" data-email-masked="" rel="nofollow">meg...@epas.utoronto.ca</a> (David Megginson) writes:<br>&gt;&gt;<br>&gt;&gt;Why does the<br>&gt;&gt;Intel architecture _not_ allow drivers to be independent programs?<br>&gt; <br>&gt; The drivers have to read and write the device registers in I/O space, and<br>&gt; this cannot be done in user mode on the 286 and 386. If it were possible<br>&gt; to do I/O in a protected way in user space, all the I/O tasks could have<br>&gt; been user programs, like FS and MM.</p><p>Surely this could have been done by a minute task just to read/write a<br>given port address in one message ?  The security could have been checked<br>like everything else using the process table ...</p><p>Sure it would not have been at all efficient, but would have given<br>the independance at a price.</p><p>Jonathan<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="f2Xfzy8aAcsJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Andy Tanenbaum" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i168">Andy Tanenbaum</h3></p><p><span>unread,</span></p><div><p><span>Feb 5, 1992, 3:48:48 PM</span><span>2/5/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i168" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">61...@skye.ed.ac.uk</a>&gt; ric...@aiai.UUCP (Richard Tobin) writes:<br>&gt;If you wanted a full-featured Unix with paging, job-control, a window<br>&gt;system and so on, would it be quicker to start from basic Minix and<br>&gt;add the features, or to start from Linux and fix the 386-specific<br>&gt;bits?  </p><p>Another option that seems to be totally forgotten here is buy UNIX or a<br>clone.  If you just want to USE the system, instead of hacking on its<br>internals, you don't need source code.  Coherent is only $99, and there<br>are various true UNIX systems with more features for more money.  For the<br>true hacker, not having source code is fatal, but for people who just<br>want a UNIX system, there are many alternatives (albeit not free).</p><p>Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vul.nl</a>)<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="PHN5k9IiS5QJ" data-subject="I/O protection" data-is-first="false" data-author="Richard Tobin" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i172">Richard Tobin</h3></p><p><span>unread,</span></p><div><p><span>Feb 5, 1992, 5:18:16 PM</span><span>2/5/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i172" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb2.1...@colorado.edu</a>&gt; <a href="" data-email-masked="" rel="nofollow">dr...@anchor.cs.colorado.edu</a> (Drew Eckhardt) writes:<br>&gt;Every 386 TSS has an iopermission bitmap.  If the CPL is of a lower priveledge<br>&gt;level than IOPL, the io permissions bitmap is consulted, allowing protection<br>&gt;on a port by port basis.</p><p>I was looking into using this recently under Minix 386, and to check I<br>was doing the right thing, I wrote a user program to access the video<br>registers.  The idea was to have it fail, and then change the kernel<br>to make it work.  To my surprise, it worked anyway...</p><p>I'll take a closer look sometime, but does anyone (Bruce?) happen to<br>already know the explanation?</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="5vxkHhyqX1IJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="John W. Linville" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i176">John W. Linville</h3></p><p><span>unread,</span></p><div><p><span>Feb 5, 1992, 6:56:35 PM</span><span>2/5/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i176" role="region"><p>Coherent is limited by a compiler that only supports the small memory model,<br>making it just as difficult (perhaps more in some instances) to port 'standard'<br>Unix programs to Coherent as it can be under Minix.  Also, Coherent is not<br>portable (or at least, to the best of my knowledge, has not been ported), so<br>this advocacy contradicts one of your arguments against Linux.</p><p>Since a true Unix system often costs as much as the machine it runs on (even<br>more since many Unix providers un-bundle networking and development packages),<br>buying a true Unix system is more than beyond the budget of many people.</p><p>John W. Linville</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="fgMbXWr3OykJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Lawrence C. Foard" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i180">Lawrence C. Foard</h3></p><p><span>unread,</span></p><div><p><span>Feb 5, 1992, 3:56:30 PM</span><span>2/5/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i180" role="region"><p>&gt;Don`t get me wrong, I am not unhappy with LINUX.  It will get all the people<br></p><p>&gt;who want to turn MINIX in BSD UNIX off my back.  But in all honesty, I would</p><div><p>&gt;suggest that people who want a **MODERN** "free" OS look around for a <br>&gt;microkernel-based, portable OS, like maybe GNU or something like that.</p></div><p>I believe you have some valid points, although I am not sure that a<br>microkernel is necessarily better. It might make more sense to allow some<br>combination of the two. As part of the IPC code I'm writting for Linux I am<br>going to include code that will allow device drivers and file systems to run<br>as user processes. These will be significantly slower though, and I believe it<br>would be a mistake to move everything outside the kernel (TCP/IP will be<br>internal).</p><p>Actually my main problem with OS theorists is that they have never tested<br>there ideas! None of these ideas (with a partial exception for MACH) has ever<br>seen the light of day. 32 bit home computers have been available for almost a<br>decade and Linus was the first person to ever write a working OS for them<br>that can be used without paying AT&amp;T $100,000. A piece of software in hand is<br>worth ten pieces of vaporware, OS theorists are quick to jump all over an OS<br>but they are unwilling to ever provide an alternative. </p><p>The general consensus that Micro kernels is the way to go means nothing when<br>a real application has never even run on one.</p><p>The release of Linux is allowing me to try some ideas I've been wanting to<br>experment with for years, but I have never had the opportunity to work with<br>source code for a functioning OS. <br>-- <br>Disclaimer: Opinions are based on logic rather than biblical "fact".   ------<br>Hackers do it for fun.  | First they came for the drug users, I said   \    /<br>"Profesionals" do it for money. | nothing, then they came for hackers,  \  /<br>Managers have others do it for them. | I said nothing... STOP W.O.D.     \/ <br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="qqBsMYdHG_MJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="David Megginson" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i184">David Megginson</h3></p><p><span>unread,</span></p><div><p><span>Feb 5, 1992, 9:50:55 PM</span><span>2/5/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i184" role="region"><p>&gt;Another option that seems to be totally forgotten here is buy UNIX or a<br>&gt;clone.  If you just want to USE the system, instead of hacking on its<br>&gt;internals, you don't need source code.  Coherent is only $99, and there<br>&gt;are various true UNIX systems with more features for more money.  For the<br>&gt;true hacker, not having source code is fatal, but for people who just<br>&gt;want a UNIX system, there are many alternatives (albeit not free).</p><p>What Unix's _are_ available for a simple, M68000-based ST, with _or_<br>without source? These are the only options I know of:</p><p>1) OS 9.<br>2) The Beckmeyer MT C-Shell.<br>3) MiNT.<br>4) Minix.</p><p>I have used all of these except for OS 9, and Minix is clearly the<br>closest thing to Unix that I can run (though it is easier to port BSD<br>programs to MiNT using the MiNT gcc library). I could shell out CAN<br>$3000 for a TT, but then I may as well buy a 386 box anyway. Besides,<br>I _like_ having the source. The extra advantage of Minix is that the<br>user base is a lot wider than the ST market, so I can get decent<br>system enhancements from Amiga, Mac, Sparc, XT, AT, '386 and '486<br>users as well as from fellow ST owners.</p><p><br>David</p><p>#################################################################<br>David Megginson                  <a href="" data-email-masked="" rel="nofollow">meg...@epas.utoronto.ca</a><br>Centre for Medieval Studies      <a href="" data-email-masked="" rel="nofollow">da...@doe.utoronto.ca</a><br>University of Toronto            39 Queen's Park Cr. E.<br>#################################################################</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="orXVJon3M0QJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Andy Tanenbaum" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i188">Andy Tanenbaum</h3></p><p><span>unread,</span></p><div><p><span>Feb 6, 1992, 12:33:23 AM</span><span>2/6/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i188" role="region"><p>I'm mortally insulted.  I AM NOT A THEORIST.  Ask anybody who was at our<br>department meeting yesterday (in joke).</p><p>Actually, these ideas have been very well tested in practice.  OSF is betting<br>its whole business on a microkernel (Mach 3.0).  USL is betting its business<br>on another one (Chorus).  Both of these run lots of software, and both have<br>been extensively compared to monolithic systems.  Amoeba has been fully<br>implemented and tested for a number of applications.  QNX is a microkernel<br>based system, and someone just told me the installed base is 200,000 systems.<br>Microkernels are not a pipe dream.  They represent proven technology.</p><p>The Mach guys wrote a paper called "UNIX as an application program."<br>It was by Golub et al., in the Summer 1990 USENIX conference.  The Chorus<br>people also have a technical report on microkernel performance, and I <br>coauthored another paper on the subject, which I mentioned yesterday<br>(Dec. 1991 Computing Systems).  Check them out.</p><p>Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>)<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="dNR-qU1mXSoJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Lawrence C. Foard" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i192">Lawrence C. Foard</h3></p><p><span>unread,</span></p><div><p><span>Feb 6, 1992, 10:22:40 AM</span><span>2/6/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i192" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb3.0...@menudo.uh.edu</a>&gt; <a href="" data-email-masked="" rel="nofollow">ke...@taronga.taronga.com</a> (Kevin Brown) writes:<br>&gt;Dr. Tanenbaum claims that the microkernel architecture is the way to go.<br>&gt;He has a great deal more experience with operating systems than I have.<br>&gt;It's an understatement that it's likely that there's some substance to<br>&gt;his statement.  :-)</p><p>I tend to prefer seeing for myself rather than accepting "expert" opinion.<br>Microkernels are nice asthetically, but there are times when practical issues<br>must also be considered :)</p><p>&gt;w3So from my point of view, the architecture of Minix is not ideal.  While</p><div><p><br>&gt;it may win in that it's a "microkernel" architecture, the division of<br>&gt;functionality is not entirely to my liking.  As is undoubtedly plainly<br>&gt;obvious by now.  :-)</p></div><p>I've been told by people who have used both that Linux is significantly<br>faster. There are certainly several factors involved (certainly using 32 bits<br>helps alot), but the multithreading also makes for much lower overhead. </p><p>&gt;However, as a *multiuser* operating system, ~ri.e. an operating system designed</p><div><p><br>&gt;to efficiently meet the needs of multiple users simultaneously while also<br>&gt;performing batch operations, Minix is lacking, as far as I'm concerned.  <br>&gt;The main reason, of course, is the single-threaded file system (hereafter,<br>&gt;STFS).  Now, Dr. Tanenbaum may feel that a multi-threaded file system <br>&gt;(hereafter, MTFS) is merely a performance hack. </p></div><p>I think this is a very valid problem. There are two ways a single threaded FS<br>could work and both have substantial problems. If the FS blocks while waiting <br>for I/O it would be completely unusable for "real" work. Imagine several users<br>accessing a database, if the FS blocks for I/O they will have to wait<br>eventhough the data they are looking for is already in the cache. If it is<br>designed to be non blocking then it is even more complicated than a<br>multithreaded FS and will have more overhead. I hope it is atleast the second</p><div><p>&gt;However much Minix may be lacking from my standpoint, it is nevertheless<br>&gt;a very useful and welcome enhancement to my system.  In spite of the<br>&gt;impression that I may have given everyone in my last posting, there will<br>&gt;always be a soft spot in my heart for it, if only because it's the first<br>&gt;decent operating system I've had on my system that I've had source to.<br>&gt;I don't have to tell you people how incredibly useful it is to have source.<br>&gt;You already know.</p></div><p>I will agree here, Minix is infinitly better than Messy-Loss :)</p><div><p>&gt;Given the reasons Linus wrote Linux, I think it's hard for anyone to fault<br>&gt;him for writing it the way he did.  And he was extremely nice in making<br>&gt;his code freely available to the rest of the world.  It's not something he<br>&gt;had to do.  In my book, that makes him almost beyond reproach.</p></div><p>I think more effort has been put into making practical use of Linux possible.<br>An educational OS is nice, but there is a world outside of colleges that <br>is suffering from the lack of cheap and useful OS's, I've been stuck doing<br>most consulting work in Messy Loss because customers don't want to fork out<br>$1000 for UNIX.</p><div><p>&gt;Dr. Tanenbaum didn't make Minix free.  His goals were different.  Minix<br>&gt;is a teaching aid above all else (unless Dr. Tanenbaum has changed his<br>&gt;views about Minix :-).  That means that he must be concerned with the<br>&gt;most efficient way to get Minix to the student population.  At the time<br>&gt;Minix was released, Prentice-Hall was a good solution, and has been for<br>&gt;some time.  However, I must wonder whether or not this is still the case.<br>&gt;Dr. Tanenbaum: do you still feel that free distribution of Minix via the<br>&gt;net is not the best way to distribute Minix?</p></div><p>I would guess that Prentice-Hall would have some objections :)</p><div><p><br>-- <br>Disclaimer: Opinions are based on logic rather than biblical "fact".   ------<br></p></div><p>This is your friendly   | First they came for the drug users, I said   \    /<br>neighborhood signature virus    | nothing, then they came for hackers,  \  /<br>please add me to your signature! |     I said nothing... STOP W.O.D.     \/ <br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="-0ZYXq4OnQQJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Timothy Murphy" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i196">Timothy Murphy</h3></p><p><span>unread,</span></p><div><p><span>Feb 6, 1992, 12:14:59 PM</span><span>2/6/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i196" role="region"><p>&gt;32 bit home computers have been available for almost a<br>&gt;decade and Linus was the first person to ever write a working OS for them<br>&gt;that can be used without paying AT&amp;T $100,000. A piece of software in hand is<br>&gt;worth ten pieces of vaporware, OS theorists are quick to jump all over an OS<br>&gt;but they are unwilling to ever provide an alternative. </p><p>Surely Bruce Evans' 386-Minix preceded Linux?</p><p>(Diffs for PC-Minix -&gt; 386-Minix<br>available from <a href="" data-email-masked="" rel="nofollow">archive...@plains.nodak.edu</a><br>in the directory Minix/oz)</p><p>--<br>Timothy Murphy  <br>e-mail: <a href="" data-email-masked="" rel="nofollow">t...@maths.tcd.ie</a><br>tel: <a href="tel:+353%201%20284%202366" value="+35312842366" target="_blank" rel="nofollow">+353-1-2842366</a><br>s-mail: School of Mathematics, Trinity College, Dublin 2, Ireland<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="rbuW0JQ4SRoJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Tony Travis" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i200">Tony Travis</h3></p><p><span>unread,</span></p><div><p><span>Feb 6, 1992, 3:17:13 AM</span><span>2/6/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i200" role="region"><p><a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a> (Andy Tanenbaum) writes:<br>&gt; Another option that seems to be totally forgotten here is buy UNIX or a<br>&gt; clone.  If you just want to USE the system, instead of hacking on its<br>&gt; internals, you don't need source code.  Coherent is only $99, and there<br>&gt; are various true UNIX systems with more features for more money.  For the<br>&gt; true hacker, not having source code is fatal, but for people who just<br>&gt; want a UNIX system, there are many alternatives (albeit not free).</p><p>Andy, I have followed the development of Minix since the first messages<br>were posted to this group and I am now running 1.5.10 with Bruce<br>Evans's patches for the 386.</p><p>I 'just' want a Unix on my PC and I am not interested in hacking on its<br>internals, but I *do* want the source code!</p><p>An important principle underlying the success and popularity of Unix is<br>the philosophy of building on the work of others.</p><p>This philosophy relies upon the availability of the source code in<br>order that it can be examined, modified and re-used in new software.</p><p>Many years ago, I was in the happy position of being an AT&amp;T Seventh<br>Edition Unix source licencee but, even then, I saw your decision to<br>make the source of Minix available as liberation from the shackles of<br>AT&amp;T copyright!!</p><p>I think you may sometimes forget that your 'hobby' has had a profound<br>effect on the availability of 'personal' Unix (ie. affordable Unix) and<br>that the 8086 PC I ran Minix 1.2 on actually cost me considerably more<br>than my present 386/SX clone.</p><p>Clearly, Minix _cannot_ be all things to all men, but I see the<br>progress to 386 versions in much the same way that I see 68000 or other<br>linear address space architectures: it is a good thing for people like<br>me who use Minix and feel constrained by the segmented architecture of<br>the PC version for applications.</p><p>NOTHING you can say would convince me that I should use Coherent ...</p><p>	Tony</p><p>-- <br>-------------------------------------------------------------------------------<br> Dr. A.J.Travis &lt;a...@uk.ac.sari.rri&gt;  | Rowett Research Institute,<br>                                      | Greenburn Road, Bucksburn, Aberdeen,<br>                                      | AB2 9SB. UK. tel 0224-712751<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="AdRgd3LxzpcJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Jerry Shekhel" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i204">Jerry Shekhel</h3></p><p><span>unread,</span></p><div><p><span>Feb 6, 1992, 10:28:05 PM</span><span>2/6/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i204" role="region"><p><a href="" data-email-masked="" rel="nofollow">linv...@garfield.catt.ncsu.edu</a> (John W. Linville) writes:<br>&gt;<br>&gt;Since a true Unix system often costs as much as the machine it runs on (even<br>&gt;more since many Unix providers un-bundle networking and development packages),<br>&gt;buying a true Unix system is more than beyond the budget of many people.<br>&gt;</p><p>For those who may be interested, MST sells System V Release 4.0.3 for the<br>386/486 for $399 including development system, $499 if you need networking.<br>X11R5 binaries may be obtained via FTP (networking is not required for X11R5).<br>I have just such a setup, and it works great.  MST's version of UNIX doesn't<br>have too much in the way of bug fixes relative to the AT&amp;T code, but the<br>only thing I've really had problems with was a couple of bugs in csh.  Now<br>that I have tcsh working (built without so much as a warning!) I'll never go<br>back :-)</p><p>Micro Station Technology<br>1140 Kentwood Avenue<br>Cupertine, CA 95014<br>Tel: <a href="tel:(408)%20253-3898" value="+14082533898" target="_blank" rel="nofollow">408-253-3898</a><br>Fax: <a href="tel:(408)%20253-7853" value="+14082537853" target="_blank" rel="nofollow">408-253-7853</a></p><p>I am not affiliated with MST except as a customer.</p><p>&gt;<br>&gt;John W. Linville<br>&gt;<br>--<br>+-------------------+----------------------+---------------------------------+<br>| JERRY J. SHEKHEL  | POLYGEN CORPORATION  | When I was young, I had to walk |<br>| Drummers do it... | Waltham, MA USA      | to school and back every day -- |<br>|    ... In rhythm! | <a href="tel:(617)%20890-2175" value="+16178902175" target="_blank" rel="nofollow">(617) 890-2175</a>       | 20 miles, uphill both ways.     |<br>+-------------------+----------------------+---------------------------------+<br>|           ...! [ princeton mit-eddie bu sunne ] !polygen!jerry             |<br>|                            <a href="" data-email-masked="" rel="nofollow">je...@polygen.com</a>                               |<br>+----------------------------------------------------------------------------+<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="TDS4dkZYXQUJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="peter da silva" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i208">peter da silva</h3></p><p><span>unread,</span></p><div><p><span>Feb 6, 1992, 5:02:47 PM</span><span>2/6/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i208" role="region"><p>&gt; QNX is a microkernel<br>&gt; based system, and someone just told me the installed base is 200,000 systems.</p><p>Oh yes, while I'm on the subject... there are over 3 million Amigas out there,<br>which means that there are more of them than any UNIX vendor has shipped, and<br>probably more than all UNIX systems combined.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="TS4MJ11fvHsJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="peter da silva" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i212">peter da silva</h3></p><p><span>unread,</span></p><div><p><span>Feb 6, 1992, 5:00:22 PM</span><span>2/6/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i212" role="region"><p>I beg to differ... there are many microkernel operating systems out there<br>for everything from an 8088 (QNX) up to large research systems.</p><div><p>&gt; None of these ideas (with a partial exception for MACH) has ever<br>&gt; seen the light of day. 32 bit home computers have been available for almost a<br>&gt; decade and Linus was the first person to ever write a working OS for them<br>&gt; that can be used without paying AT&amp;T $100,000.</p></div><p>I must have been imagining AmigaOS, then. I've been using a figment of my<br>imagination for the past 6 years.</p><p>AmigaOS is a microkernel message-passing design, with better response time<br>and performance than any other readily available PC operating system: including<br>MINIX, OS/2, Windows, MacOS, Linux, UNIX, and *certainly* MS-DOS.</p><p>The microkernel design has proven invaluable. Things like new file systems<br>that are normally available only from the vendor are hobbyist products on<br>the Amiga. Device drivers are simply shared libraries and tasks with specific<br>entry points and message ports. So are file systems, the window system, and<br>so on. It's a WONDERFUL design, and validates everything that people have<br>been saying about microkernels. Yes, it takes more work to get them off the<br>ground than a coroutine based macrokernel like UNIX, but the versatility<br>pays you back many times over.</p><p>I really wish Andy would do a new MINIX based on what has been learned since<br>the first release. The factoring of responsibilities in MINIX is fairly poor,<br>but the basic concept is good.</p><div><p>&gt; The general consensus that Micro kernels is the way to go means nothing when<br>&gt; a real application has never even run on one.</p></div><p>I'm dreaming again. I sure throught Deluxe Paint, Sculpt 3d, Photon Paint,<br>Manx C, Manx SDB, Perfect Sound, Videoscape 3d, and the other programs I<br>bought for my Amiga were "real". I'll have to send the damn things back now,<br>I guess.</p><p>The availability of Linux is great. I'm delighted it exists. I'm sure that<br>the macrokernel design is one reason it has been implemented so fast, and this<br>is a valid reason to use macrokernels. BUT... this doesn't mean that<br>microkernels are inherently slow, or simply research toys.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="ZuTfVXx56GYJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Tim W Smith" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i216">Tim W Smith</h3></p><p><span>unread,</span></p><div><p><span>Feb 7, 1992, 2:30:59 AM</span><span>2/7/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i216" role="region"><p>Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>) writes:<br>&gt; The drivers have to read and write the device registers in I/O space, and<br>&gt; this cannot be done in user mode on the 286 and 386. If it were possible<br>&gt; to do I/O in a protected way in user space, all the I/O tasks could have<br>&gt; been user programs, like FS and MM.</p><p>On the 386, you could run the drivers in V86 mode, which sort of counts<br>as user mode and allows access to I/O registers if the kernel sets things<br>up to allow this.</p><p>							Tim Smith<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="uyoao5g08EQJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Tim W Smith" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i220">Tim W Smith</h3></p><p><span>unread,</span></p><div><p><span>Feb 7, 1992, 3:09:23 AM</span><span>2/7/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i220" role="region"><p>&gt; Actually my main problem with OS theorists is that they have never tested<br>&gt; there ideas! None of these ideas (with a partial exception for MACH) has ever<br>&gt; seen the light of day. 32 bit home computers have been available for almost a<br>&gt; decade and Linus was the first person to ever write a working OS for them<br>&gt; that can be used without paying AT&amp;T $100,000. A piece of software in hand is</p><p>How about Netware 386 from Novell?  It seems to work.</p><p>							Tim Smith<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="DvFh3-oWEaEJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Richard Tobin" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i224">Richard Tobin</h3></p><p><span>unread,</span></p><div><p><span>Feb 7, 1992, 3:58:22 PM</span><span>2/7/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i224" role="region"><p>&gt;If you just want to USE the system, instead of hacking on its<br>&gt;internals, you don't need source code.</p><p>Unfortunately hacking on the internals is just what many of us want<br>the system for...  You'll be rid of most of us when BSD-detox or GNU<br>comes out, which should happen in the next few months (yeah, right).</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="m3VoG_ELbAIJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="bert thompson" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i228">bert thompson</h3></p><p><span>unread,</span></p><div><p><span>Feb 8, 1992, 8:43:54 AM</span><span>2/8/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i228" role="region"><p>feu...@netcom.COM (David Feustel) writes:</p><p>&gt;That's ok. Einstein got lousy grades in math and physics.</p><p>	no he didn't.</p><p>	bert.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="HeAxxIZFb40J" data-subject="LINUX is obsolete" data-is-first="false" data-author="Rogier Wolff" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i232">Rogier Wolff</h3></p><p><span>unread,</span></p><div><p><span>Feb 8, 1992, 10:13:39 AM</span><span>2/8/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i232" role="region"><p><a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a> (Andy Tanenbaum) writes:</p><p>&gt;In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb5....@wpi.WPI.EDU</a>&gt; <a href="" data-email-masked="" rel="nofollow">ent...@wintermute.WPI.EDU</a> (Lawrence C. Foard) writes:<br>&gt;&gt;Actually my main problem with OS theorists is that they have never tested<br>&gt;&gt;there ideas! <br>&gt;I'm mortally insulted.  I AM NOT A THEORIST.  Ask anybody who was at our<br>&gt;department meeting yesterday (in joke).</p><div><p>&gt;Actually, these ideas have been very well tested in practice.  </p></div><p>The problem is that to really do an unbiased test you would need two<br>*identical* teams, and ask them to make two OS's, for the same<br>destination machine, one using a microkernel architecture, and the other<br>using the monolithic approach. This is in practice not feasable and the<br>publications on the subject can only shout: "look: I've got a good <br>performance using a microkernel", "we've got very good performance using<br>a monolithic aproach" or "it only took us X months to implement this OS"</p><p>If people did benchmark their OS's they wrote the OS for one architecture,<br>and adapted it to test the other. This adaptation will naturally degrade<br>performance, and show that the designers were right in the first place.</p><p>Anyway, anybody have an opinion about the fact that code for printf<br>is included three times in the Minix OS when it runs (once in the <br>kernel, MM and FS)</p><p>							Roger</p><p>-- <br>If the opposite of "pro" is "con", what is the opposite of "progress"? <br>	(stolen from  kadokev@iitvax ==? <a href="" data-email-masked="" rel="nofollow">tech...@iitmax.iit.edu</a>)<br>EMail:  <a href="" data-email-masked="" rel="nofollow">wo...@duteca.et.tudelft.nl</a>   ** Tel  +31-15-783644 or +31-15-142371<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="j4D7OxymDVQJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="David Megginson" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i236">David Megginson</h3></p><p><span>unread,</span></p><div><p><span>Feb 8, 1992, 4:04:31 PM</span><span>2/8/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i236" role="region"><p>&gt;Anyway, anybody have an opinion about the fact that code for printf<br>&gt;is included three times in the Minix OS when it runs (once in the <br>&gt;kernel, MM and FS)</p><p>Back in the yore days, this might have been a problem. I remember when<br>every program, even wordprocessors, had to be written in assembler to<br>squeeze them down to the smallest size possible for a 64K system. One<br>of the reasons WordPerfect is such a mess today is that it was written<br>in assembler instead of C.</p><p>Now, even the small systems which Minix runs have at least 640K, so a<br>few wasted bytes are not so much of a problem.</p><p>Why not write Linux in 80386 assembler? It would be smaller and even<br>faster. And don't forget to code inline as much as possible, to avoid<br>the crippling overhead of function calls. And leave out comments,<br>because they waste disk space.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="Z-tUWIEuQjMJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Kevin Brown" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i240">Kevin Brown</h3></p><p><span>unread,</span></p><div><p><span>Feb 9, 1992, 10:02:24 AM</span><span>2/9/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i240" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb6.0...@wpi.WPI.EDU</a>&gt; <a href="" data-email-masked="" rel="nofollow">ent...@wintermute.WPI.EDU</a> (Lawrence C. Foard) writes:<br>&gt;In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb3.0...@menudo.uh.edu</a>&gt; <a href="" data-email-masked="" rel="nofollow">ke...@taronga.taronga.com</a> (Kevin Brown) writes:<br>&gt;&gt;Dr. Tanenbaum claims that the microkernel architecture is the way to go.<br>&gt;&gt;He has a great deal more experience with operating systems than I have.<br>&gt;&gt;It's an understatement that it's likely that there's some substance to<br>&gt;&gt;his statement.  :-)<br>&gt;<br>&gt;I tend to prefer seeing for myself rather than accepting "expert" opinion.<br>&gt;Microkernels are nice asthetically, but there are times when practical issues<br>&gt;must also be considered :)</p><p>I agree.  This is why I qualified my statement the way I did.  :-)</p><p>Having seen both monolithic and microkernel architectures running, though,<br>I tend to agree that microkernels are generally the way to go, all other<br>things being equal.</p><p>But as you say, all things are not always equal.  That's when it becomes<br>a judgement call.  Which is better?  Depends on what you're trying to do.</p><div><p>&gt;I've been told by people who have used both that Linux is significantly<br>&gt;faster. There are certainly several factors involved (certainly using 32 bits<br>&gt;helps alot), but the multithreading also makes for much lower overhead. </p></div><p>Yup.  I think that if Minix were arranged so that it had message queueing<br>and a true multithreaded filesystem, it might be comparable to a monolithic<br>kernel in terms of speed.  It's hard for me to say, though.  I haven't<br>played around much with multithreaded filesystems, so I don't know how<br>hard it is to make them work efficiently.  I'd think, though, that it would<br>depend enormously on how efficient your device drivers were, and how much<br>data copying you'd have to do (ideally, you'd pass references to the data<br>buffers around and do your actual data transfers directly to the user's<br>buffer).</p><p>&gt;&gt;However, as a *multiuser* operating system, i.e. an operating system designed</p><div><p><br>&gt;&gt;to efficiently meet the needs of multiple users simultaneously while also<br>&gt;&gt;performing batch operations, Minix is lacking, as far as I'm concerned.  <br>&gt;&gt;The main reason, of course, is the single-threaded file system (hereafter,<br>&gt;&gt;STFS).  Now, Dr. Tanenbaum may feel that a multi-threaded file system <br>&gt;&gt;(hereafter, MTFS) is merely a performance hack. <br>&gt;<br>&gt;I think this is a very valid problem. There are two ways a single threaded FS<br>&gt;could work and both have substantial problems. If the FS blocks while waiting <br>&gt;for I/O it would be completely unusable for "real" work. Imagine several users<br>&gt;accessing a database, if the FS blocks for I/O they will have to wait<br>&gt;eventhough the data they are looking for is already in the cache. If it is<br>&gt;designed to be non blocking then it is even more complicated than a<br>&gt;multithreaded FS and will have more overhead. I hope it is atleast the second</p></div><p>I haven't gone deeply into the source code of the Minix file system, but<br>the impression I get from my perusing of it is that it blocks on disk I/O<br>but not on terminal I/O, the idea being that disk I/O requests will almost<br>always be satisfied relatively soon after they are made, whereas terminal<br>I/O requests can take an indefinite amount of time to satisfy.</p><p>But it seems to me that if you're going to implement the mechanism to handle<br>I/O where the file system doesn't block waiting for it, why not use that<br>mechanism universally???</p><div><p>&gt;&gt;However much Minix may be lacking from my standpoint, it is nevertheless<br>&gt;&gt;a very useful and welcome enhancement to my system.  In spite of the<br>&gt;&gt;impression that I may have given everyone in my last posting, there will<br>&gt;&gt;always be a soft spot in my heart for it, if only because it's the first<br>&gt;&gt;decent operating system I've had on my system that I've had source to.<br>&gt;&gt;I don't have to tell you people how incredibly useful it is to have source.<br>&gt;&gt;You already know.<br>&gt;<br>&gt;I will agree here, Minix is infinitly better than Messy-Loss :)</p></div><p>Which is why I try to avoid using MS-DOS whenever possible.  I'll bet a<br>lot of us Minixers do the same.  :-)</p><div><p>&gt;&gt;Given the reasons Linus wrote Linux, I think it's hard for anyone to fault<br>&gt;&gt;him for writing it the way he did.  And he was extremely nice in making<br>&gt;&gt;his code freely available to the rest of the world.  It's not something he<br>&gt;&gt;had to do.  In my book, that makes him almost beyond reproach.<br>&gt;<br>&gt;I think more effort has been put into making practical use of Linux possible.<br>&gt;An educational OS is nice, but there is a world outside of colleges that <br>&gt;is suffering from the lack of cheap and useful OS's, I've been stuck doing<br>&gt;most consulting work in Messy Loss because customers don't want to fork out<br>&gt;$1000 for UNIX.</p></div><p>Even students can make good use of something like Linux.  I have 8 megabytes<br>of RAM on my machine, and 410 meg of harddrive space.  Yet I can barely<br>run SBProlog on my system, even though my system is considerably more macho<br>than most.  If I had demand paging on my system, this wouldn't be a problem,<br>but the only patches I have for demand paging seem not to work very well.<br>Once Linux becomes more stable (and gets support for Seagate ST-02 SCSI),<br>I'll snag the sources and check it out.  Since I already own Minix, I can<br>legally transport *everything* over to it, and since both share the same<br>filesystem layout, I can do the transporting with a minimum of hassle.</p><div><p>&gt;&gt;Dr. Tanenbaum didn't make Minix free.  His goals were different.  Minix<br>&gt;&gt;is a teaching aid above all else (unless Dr. Tanenbaum has changed his<br>&gt;&gt;views about Minix :-).  That means that he must be concerned with the<br>&gt;&gt;most efficient way to get Minix to the student population.  At the time<br>&gt;&gt;Minix was released, Prentice-Hall was a good solution, and has been for<br>&gt;&gt;some time.  However, I must wonder whether or not this is still the case.<br>&gt;&gt;Dr. Tanenbaum: do you still feel that free distribution of Minix via the<br>&gt;&gt;net is not the best way to distribute Minix?<br>&gt;<br>&gt;I would guess that Prentice-Hall would have some objections :)</p></div><p>No doubt.  :-(</p><p><br>--<br>Kevin Brown						Disclaimer: huh?<br><a href="" data-email-masked="" rel="nofollow">ke...@taronga.com</a>				  <a href="" data-email-masked="" rel="nofollow">ke...@nuchat.sccsi.com</a><br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="14ZRrl5U1UAJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="peter da silva" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i244">peter da silva</h3></p><p><span>unread,</span></p><div><p><span>Feb 10, 1992, 4:10:00 AM</span><span>2/10/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i244" role="region"><p>&gt; The problem is that to really do an unbiased test you would need two<br></p><p>&gt; *identical* teams, and ask them to make two OS's [...]</p><p>No, you don't. I don't think there's any question that a macrokernel is<br>very easy to get decent performance out of. Where the microkernel design<br>has a major advantage is in flexibility. Adding stuff to a macrokernel<br>is fairly complex and quickly becomes pretty gross. Look at BSD or System V<br>for examples. Adding stuff to a well designed microkernel is VERY easy.</p><p>Sometimes you don't want to compare oranges and oranges. Sometimes you want<br>to compare concentrated orange juice with fresh-squeezed. Fresh-squeezed<br>takes longer, but it's worth it.</p><p>Plus, with a microkernel you can get much better context switching between<br>microtasks than macro processes. So you can do stuff in separate processes<br>that would be out of the question in a macrokernel, and avoid nonsense like<br>the myriad inconsistencies in NFS.</p><p>&gt; anyone have an opinion about why the code for printf</p><div><p><br>&gt; is included three times in the Minix OS when it runs (once in the <br>&gt; kernel, MM and FS)</p></div><p>Anyone have an opinion why the code for printf is included only once in<br>AmigaOS (even though the AmigaOS 2.04 "kernel" is actually a dozen or<br>more separate processes)?</p><p>Minix is a poor technology demonstrator for microkernels. Which is OK, since<br>it wasn't supposed to be one.</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="mDeXKIXu8bsJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Dave Smythe" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i248">Dave Smythe</h3></p><p><span>unread,</span></p><div><p><span>Feb 10, 1992, 8:08:22 AM</span><span>2/10/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i248" role="region"><p>In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb5....@wpi.WPI.EDU</a>&gt; <a href="" data-email-masked="" rel="nofollow">ent...@wintermute.WPI.EDU</a> (Lawrence C. Foard) writes:<br>&gt;Actually my main problem with OS theorists is that they have never tested<br>&gt;there ideas! None of these ideas (with a partial exception for MACH) has ever<br>&gt;seen the light of day.</p><p>David Cheriton (Prof. at Stanford, and author of the V system) said something<br>similar to this in a class in distributed systems.  Paraphrased:</p><p>  "There are two kinds of researchers: those that have implemented<br>   something and those that have not.  The latter will tell you that<br>   there are 142 ways of doing things and that there isn't consensus<br>   on which is best.  The former will simply tell you that 141 of <br>   them don't work."</p><p>He really rips on the OSI-philes as well, for a similar reason.  The Internet<br>protocols are adapted only after having been in use for a period of time,<br>preventing things from getting standardized that will never be implementable<br>in a reasonable fashion.  OSI adherents, on the other hand, seem intent on<br>standardizing everything possible, including "escapes" from the standard,<br>before a reasonable reference implementation exists.  Consequently, you see<br>obsolete ideas immortalized, such as sub-byte-level data field packing,<br>which makes good performance difficult when your computer is drinking from<br>a 10+ Gbs fire-hose :-).</p><p>Just my $.02</p><p>D</p><p>-- <br>========================================================================<br>Dave Smythe   N6XLP    <a href="" data-email-masked="" rel="nofollow">dsm...@netcom.com</a> (also <a href="" data-email-masked="" rel="nofollow">dsm...@cs.stanford.edu</a>)<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="gAPtwHLWc0gJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Bill Mitchell" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i252">Bill Mitchell</h3></p><p><span>unread,</span></p><div><p><span>Feb 10, 1992, 4:03:51 PM</span><span>2/10/92</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i252" role="region"><p>in comp.os.minix, dsm...@netcom.COM (Dave Smythe) said:</p><p><br>&gt;In article &lt;<a href="" data-email-masked="" rel="nofollow">1992Feb5....@wpi.WPI.EDU</a>&gt; <a href="" data-email-masked="" rel="nofollow">ent...@wintermute.WPI.EDU</a> (Lawrence C. Foard) writes:<br>&gt;<br>&gt;David Cheriton (Prof. at Stanford, and author of the V system) said something<br>&gt;similar to this in a class in distributed systems.  Paraphrased:<br>&gt;<br>&gt;  "There are two kinds of researchers: those that have implemented<br>&gt;   something and those that have not.  The latter will tell you that<br>&gt;   there are 142 ways of doing things and that there isn't consensus<br>&gt;   on which is best.  The former will simply tell you that 141 of <br>&gt;   them don't work."<br>&gt;</p><p>Yeah, but what's the odds on two who have implemented something differently<br>agreeing on which 141 don't work?</p><p>-- <br><a href="" data-email-masked="" rel="nofollow">mitc...@mdd.comm.mot.com</a> (Bill Mitchell)</p></div></div><div jsname="A9KrYd" tabindex="0" jscontroller="ywEdOe" data-doc-id="d4RIjyWDPJMJ" data-subject="LINUX is obsolete" data-is-first="false" data-author="Christopher Stuart" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div><p><h3 id="i256">Christopher Stuart</h3></p><p><span>unread,</span></p><div><p><span>Feb 11, 1992, 2:52:57 PM</span><span>2/11/92</span></p></div></div><p><span>to </span></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="wiRDgwh0iMAJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Omniscientist" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i260">Omniscientist</h3></p><p><span>unread,</span></p><div><p><span>Jan 10, 2005, 3:02:10 PM</span><span>1/10/05</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i260" role="region"><p>Well, sorry Ken...but it looks like microkernels didn't last as long as<br>you thought. I'm on Linux right now...and minix isn't anywhere in<br>sight..</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="xydUWF3Vde4J" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="the...@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i264">the...@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Jan 11, 2005, 10:34:47 AM</span><span>1/11/05</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i264" role="region"><p>i'm glad I read this.</p><p>&gt; &gt;I was in the U.S. for a couple of weeks, so I haven't commented much<br>on<br>&gt; &gt;LINUX (not that I would have said much had I been around), but for<br>what<br>&gt; &gt;it is worth, I have a couple of comments now.<br>&gt; &gt;<br>&gt; &gt;As most of you know, for me MINIX is a hobby, something that I do in<br>the<br>&gt; &gt;evening when I get bored writing books and there are no major wars,<br>&gt; &gt;revolutions, or senate hearings being televised live on CNN.  My<br>real<br>&gt; &gt;job is a professor and researcher in the area of operating systems.<br>&gt; &gt;<br>&gt; &gt;As a result of my occupation, I think I know a bit about where<br>operating<br>&gt; &gt;are going in the next decade or so.  Two aspects stand out:<br>&gt; &gt;<br>&gt; &gt;1. MICROKERNEL VS MONOLITHIC SYSTEM<br>&gt; &gt;   Most older operating systems are monolithic, that is, the whole<br>operating<br>&gt; &gt;   system is a single a.out file that runs in 'kernel mode.'  This<br>binary<br>&gt; &gt;   contains the process management, memory management, file system<br>and the<br>&gt; &gt;   rest. Examples of such systems are UNIX, MS-DOS, VMS, MVS,<br>OS/360,<br>&gt; &gt;   MULTICS, and many more.<br>&gt; &gt;<br>&gt; &gt;   The alternative is a microkernel-based system, in which most of<br>the OS<br>&gt; &gt;   runs as separate processes, mostly outside the kernel.  They<br>communicate<br>&gt; &gt;   by message passing.  The kernel's job is to handle the message<br>passing,<br>&gt; &gt;   interrupt handling, low-level process management, and possibly<br>the I/O.<br>&gt; &gt;   Examples of this design are the RC4000, Amoeba, Chorus, Mach, and<br>the<br>&gt; &gt;   not-yet-released Windows/NT.<br>&gt; &gt;<br>&gt; &gt;   While I could go into a long story here about the relative merits<br>of the<br>&gt; &gt;   two designs, suffice it to say that among the people who actually<br>design<br>&gt; &gt;   operating systems, the debate is essentially over.  Microkernels<br>have won.<br>&gt; &gt;   The only real argument for monolithic systems was performance,<br>and there<br>&gt; &gt;   is now enough evidence showing that microkernel systems can be<br>just as<br>&gt; &gt;   fast as monolithic systems (e.g., Rick Rashid has published<br>papers comparing<br>&gt; &gt;   Mach 3.0 to monolithic systems) that it is now all over but the<br>shoutin`.<br>&gt;<br>&gt; Of course, there are some things that are best left to the kernel, be<br>it<br>&gt; micro or monolithic.  Like things that require playing with the<br>process'<br>&gt; stack, e.g. signal handling.  Like memory allocation.  Things like<br>that.<br>&gt;<br>&gt; The microkernel design is probably a win, all in all, over a<br>monolithic<br>&gt; design, but it depends on what you put in the kernel and what you<br>leave<br>&gt; out.<br>&gt;<br>&gt; &gt;   MINIX is a microkernel-based system.  The file system and memory<br>management<br>&gt; &gt;   are separate processes, running outside the kernel.  The I/O<br>drivers are<br>&gt; &gt;   also separate processes (in the kernel, but only because the<br>brain-dead<br>&gt; &gt;   nature of the Intel CPUs makes that difficult to do otherwise).<br>&gt;<br>&gt; Minix is a microkernel design, of sorts.  The problem is that it<br>gives special<br>&gt; priveleges to mm and fs, when there shouldn't be any (at least for<br>fs).  It<br>&gt; also fails to integrate most of the functionality of mm in the kernel<br>itself,<br>&gt; and this makes things like signal handling and memory allocation<br>*really*<br>&gt; ugly.  If you did these things in the kernel itself, then signal<br>handling<br>&gt; would be as simple as setting a virtual interrupt vector and causing<br>the<br>&gt; signalled process to receive that interrupt (with the complication<br>that<br>&gt; system calls might have to be terminated.  Which means that a message<br>would<br>&gt; have to be sent to every process that is servicing the process'<br>system call,<br>&gt; if any.  It's considerations like these that make the monolithic<br>kernel<br>&gt; design appealing).<br>&gt;<br>&gt; The *entire* system call interface in Minix needs to be rethought.<br>As it<br>&gt; stands right now, the file system is not just a file system, it's<br>also a<br>&gt; system-call server.  That functionality needs to be separated out in<br>order<br>&gt; to facilitate a multiple file system architecture.  Message passing<br>is<br>&gt; probably the right way to go about making the call and waiting for<br>it, but<br>&gt; the message should go to a system call server, not the file system<br>itself.<br>&gt;<br>&gt; In order to handle all the special caveats of the Unix API, you end<br>up writing<br>&gt; a monolithic "kernel" even if you're using a microkernel base.  You<br>end up<br>&gt; with something called a "server", and an example is the BSD server<br>that runs<br>&gt; under Mach.<br>&gt;<br>&gt; And, in any case, the message-passing in Minix needs to be completely<br>redone.<br>&gt; As it is, it's a kludge.  I've been giving this some thought, but I<br>haven't<br>&gt; had time to do anything with what I've thought of so far.  Suffice it<br>to say<br>&gt; that the proper way to do message-passing is probably with message<br>ports<br>&gt; (both public and private), with the various visible parts of the<br>operating<br>&gt; system having public message ports.  Chances are, that ends up being<br>the<br>&gt; system call server only, though this will, of course, depend on the<br>goals<br>&gt; of the design.<br>&gt;<br>&gt; &gt;   LINUX is<br>&gt; &gt;   a monolithic style system.  This is a giant step back into the<br>1970s.<br>&gt; &gt;   That is like taking an existing, working C program and rewriting<br>it in<br>&gt; &gt;   BASIC.  To me, writing a monolithic system in 1991 is a truly<br>poor idea.<br>&gt;<br>&gt; Depends on the design criteria, as you should know.  If your goal is<br>to<br>&gt; design a Unix workalike that is relatively simple and relatively<br>small,<br>&gt; then a monolithic design is probably the right approach for the job,<br>because<br>&gt; unless you're designing for really backwards hardware, the problems<br>of<br>&gt; things like interrupted system calls, memory allocation within the<br>kernel<br>&gt; (so you don't have to statically allocate *everything* in your OS),<br>signal<br>&gt; handling, etc. all go away (or are at least minimized) if you use a<br>&gt; monolithic design.  If you want the ability to bring up and take down<br>&gt; file systems, add and remove device drivers, etc., all at runtime,<br>then<br>&gt; a microkernel approach is the right solution.<br>&gt;<br>&gt; Frankly, I happen to like the idea of removable device drivers and<br>such,<br>&gt; so I tend to favor the microkernel approach as a general rule.<br>&gt;<br>&gt; &gt;2. PORTABILITY<br>&gt; &gt;   Once upon a time there was the 4004 CPU.  When it grew up it<br>became an<br>&gt; &gt;   8008.  Then it underwent plastic surgery and became the 8080.  It<br>begat<br>&gt; &gt;   the 8086, which begat the 8088, which begat the 80286, which<br>begat the<br>&gt; &gt;   80386, which begat the 80486, and so on unto the N-th generation.<br>In<br>&gt; &gt;   the meantime, RISC chips happened, and some of them are running<br>at over<br>&gt; &gt;   100 MIPS.  Speeds of 200 MIPS and more are likely in the coming<br>years.<br>&gt; &gt;   These things are not going to suddenly vanish.  What is going to<br>happen<br>&gt; &gt;   is that they will gradually take over from the 80x86 line.  They<br>will<br>&gt; &gt;   run old MS-DOS programs by interpreting the 80386 in software.<br>(I even<br>&gt; &gt;   wrote my own IBM PC simulator in C, which you can get by FTP from<br>&gt; &gt;   <a href="http://ftp.cs.vu.nl/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://ftp.cs.vu.nl&amp;source=gmail&amp;ust=1739122202455000&amp;usg=AOvVaw092-fC-TBZemOq4Ld3KeqO">ftp.cs.vu.nl</a> =  192.31.231.42 in dir minix/simulator.)  I think<br>it is a<br>&gt; &gt;   gross error to design an OS for any specific architecture, since<br>that is<br>&gt; &gt;   not going to be around all that long.<br>&gt;<br>&gt; Again, look at the design criteria.  If portability isn't an issue,<br>then<br>&gt; why worry about it?  While LINUX suffers from lack of portability,<br>portability<br>&gt; was obviously never much of a consideration for its author, who<br>explicitly<br>&gt; stated that it was written as an exercise in learning about the 386<br>&gt; architecture.<br>&gt;<br>&gt; And, in any case, while MINIX is portable in the sense that most of<br>the code<br>&gt; can be ported to other platforms, it *still* suffers from the<br>limitations of<br>&gt; the original target machine that drove the walk down the design<br>decision tree.<br>&gt; The message passing is a kludge because the 8088 is slow.  The kernel<br>doesn't<br>&gt; do memory allocation (thus not allowing FS and the drivers to get<br>away with<br>&gt; using a malloc library or some such, and thus causing everyone to<br>have to<br>&gt; statically allocate everything), probably due to some other<br>limitation of<br>&gt; the 8088.  The very idea of using "clicks" is obviously the result of<br>the<br>&gt; segmented architecture of the 8088.  The file system size is too<br>limited<br>&gt; (theoretically fixed in 1.6, but now you have *two* file system<br>formats to<br>&gt; contend with.  If having the file system as a separate process is<br>such a<br>&gt; big win, then why don't we have two file system servers, eh?  Why<br>simply<br>&gt; extend the existing Minix file system instead of implementing BSD's<br>FFS<br>&gt; or some other high-performance file system?  It's not that I'm greedy<br>&gt; or anything... :-).<br>&gt;<br>&gt; &gt;   MINIX was designed to be reasonably portable, and has been ported<br>from the<br>&gt; &gt;   Intel line to the 680x0 (Atari, Amiga, Macintosh), SPARC, and<br>NS32016.<br>&gt; &gt;   LINUX is tied fairly closely to the 80x86.  Not the way to go.<br>&gt;<br>&gt; All in all, I tend to agree.</p><div><p>&gt;<br>&gt; &gt;Don`t get me wrong, I am not unhappy with LINUX.  It will get all<br>the people<br>&gt; &gt;who want to turn MINIX in BSD UNIX off my back.  But in all honesty,<br>I would<br>&gt; &gt;suggest that people who want a **MODERN** "free" OS look around for<br>a<br>&gt; &gt;microkernel-based, portable OS, like maybe GNU or something like<br>that.<br>&gt;<br></p></div><p>&gt; Yeah, right.  Point me someplace where I can get a free "modern" OS<br>and I'll<br>&gt; gladly investigate.  But the GNU OS is currently vaporware, and as<br>far as I'm<br>&gt; concerned it will be for a LOOOOONG time to come.<br>&gt;<br>&gt; Any other players?  BSD 4.4 is a monolithic architecture, so by your<br>&gt; definition it's out.  Mach is free, but the BSD server isn't (AT&amp;T<br>code,<br>&gt; you know), and in any case, isn't the BSD server something you'd<br>consider<br>&gt; to be a monolithic design???<br>&gt;<br>&gt; Really.  Why do you think LINUX is as popular as it is?  The answer<br>is<br>&gt; simple, of course: because it's the *only* free Unix workalike OS in<br>&gt; existence.  BSD doesn't qualify (yet).  Minix doesn't qualify.  XINU<br>&gt; isn't even in the running.  GNU's OS is vaporware, and probably will<br>&gt; be for a long time, so *by definition* it's not in the running.  Any<br>&gt; other players?  I haven't heard of any...<br>&gt;<br>&gt; &gt;Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>)<br>&gt;<br>&gt; Minix is an excellent piece of work.  A good starting point for<br>anyone who<br>&gt; wants to learn about operating systems.  But it needs rewriting to<br>make it<br>&gt; truly elegant and functional.  As it is, there are too many kludges<br>and<br>&gt; hacks (e.g., the message passing).<br>&gt; <br>&gt; 				Kevin Brown</p></div></div><div jsname="A9KrYd" tabindex="0" jscontroller="ywEdOe" data-doc-id="5xiFK-ENpJYJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Gary" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div><p><h3 id="i268">Gary</h3></p><p><span>unread,</span></p><div><p><span>Jan 13, 2005, 3:04:45 AM</span><span>1/13/05</span></p></div></div><p><span>to </span></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="trHoKGnj5wEJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="chandan" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i272">chandan</h3></p><p><span>unread,</span></p><div><p><span>Jan 14, 2005, 12:11:02 PM</span><span>1/14/05</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i272" role="region"><p>hi,<br>im new to this forum. but i can say that there is not a single<br>operating system which had been designed for students except minix.<br>ofcourse linux is great in its own terms. but doesn't u think that<br>minix is well suited for distributed operating system concept.i liked<br>microkernel concept.  i certainly say that minix is student's os.<br>linux, too, was not great initially but the modification provided by<br>different groups and organization changed it into a major force.  i<br>know that minix is older than linux but former is not popular. reason<br>is itself cited in one of A. Tanen. article. (want to leave this os for<br>students).</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="ccp8TGlh8VMJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Adrien Plisson" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i276">Adrien Plisson</h3></p><p><span>unread,</span></p><div><p><span>Jan 16, 2005, 10:43:24 AM</span><span>1/16/05</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i276" role="region"><p>Gary wrote:<br>&gt; Is there a particular reason that you're trolling this group by answering <br>&gt; 13 year old posts by Ken Thompson?</p><p>i do have a question: why do i see a lot of greetings post for thorvald <br>on this newsgroup lately ? are these "10 years old posts revived by some <br>kind of bug" ? do people confuse minix and linux ?</p><p>thanks</p><p>-- <br>rien</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="3en_qiP-R7UJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Adrien Plisson" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i280">Adrien Plisson</h3></p><p><span>unread,</span></p><div><p><span>Jan 16, 2005, 10:49:47 AM</span><span>1/16/05</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i280" role="region"><p>well, i didn't read the post by Michael Black when i posted this. Now i <br>understand, sorry for disturbing...</p><p>-- <br>rien</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="MsdWVyGInA8J" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Tux Wonder-Dog" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i284">Tux Wonder-Dog</h3></p><p><span>unread,</span></p><div><p><span>Jan 20, 2005, 12:50:12 PM</span><span>1/20/05</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i284" role="region"><p>chandan wrote:</p><p>Actually, there's Switzer's Tunix, a more rigorously microkernel-based<br>teaching operating system than Minix - because practically everything's a<br>server in Tunix, versus not that many in Minix.  Switzer wrote his book and<br>OS for students.</p><p>And there is Wirth's Oberon, just to stir the pot a bit.  Wirth wrote his<br>experimental OS plus language for students.</p><p>And Per Brinch Hansen's Solo and associated Concurrent Pascal OSes, largely<br>written for students as well.</p><p>It seems to be quite wide-spread.</p><p>One of the OSes that _wasn't_ written for students, surprise, surprise, was<br>Unix.  It was a production system that got studied - read the Lions Book/s.</p><p>Having said that, if it hadn't been for the work of Andy Tanenbaum in<br>writing his book and Minix, the world would've missed out on Linux, since<br>it inspired Linus Torvalds to go one better; and I for one wouldn't have<br>learned as much about Operating Systems as I've managed to.</p><p>So, thanks to Andy Tanenbaum; and also thanks to Linus Torvalds.  And, did I<br>forget to mention, thank you to the entire BSD team through the years, etc?</p><p>Wesley Parish<br>-- <br>"Good, late in to more rewarding well."&nbsp;&nbsp;"Well,&nbsp;you&nbsp;tonight.&nbsp;&nbsp;And&nbsp;I&nbsp;was<br>lookintelligent woman of Ming home.&nbsp;&nbsp;I&nbsp;trust&nbsp;you&nbsp;with&nbsp;a&nbsp;tender&nbsp;silence."&nbsp;&nbsp;I<br>get a word into my hands, a different and unbelike, probably - 'she<br>fortunate fat woman', wrong word.&nbsp;&nbsp;I&nbsp;think&nbsp;to&nbsp;me,&nbsp;I&nbsp;justupid.<br>Let not emacs meta-X dissociate-press write your romantic dialogs...!!!<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="piFMo_eIHykJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="chandan" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i288">chandan</h3></p><p><span>unread,</span></p><div><p><span>Jan 24, 2005, 9:04:47 AM</span><span>1/24/05</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i288" role="region"><p>thanks tux. i hadn't any idea about these OSes. thanks again</p></div></div><div jsname="A9KrYd" tabindex="0" jscontroller="ywEdOe" data-doc-id="QEVMMIMSeoQJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="burt" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div><p><h3 id="i292">burt</h3></p><p><span>unread,</span></p><div><p><span>Jan 25, 2005, 7:36:49 PM</span><span>1/25/05</span></p></div></div><p><span>to </span></p></div><div jsname="A9KrYd" tabindex="0" jscontroller="ywEdOe" data-doc-id="HaCLx8rL0lgJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Moses" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div><p><h3 id="i296">Moses</h3></p><p><span>unread,</span></p><div><p><span>May 30, 2011, 5:38:31 AM</span><span>5/30/11</span></p></div></div><p><span>to </span></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="_oRX-hbdiPIJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Moses" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i300">Moses</h3></p><p><span>unread,</span></p><div><p><span>May 30, 2011, 5:42:16 AM</span><span>5/30/11</span></p></div></div><p><span>to </span></p></div><p>me 3 :DDD<br></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="eEg4BI3nytwJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="derrick....@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i304">derrick....@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Mar 13, 2012, 1:59:27 PM</span><span>3/13/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i304" role="region"><p>This thread is impressive. The idea that I can read old USENET posts is absolutely amazing. The idea I can reply to them is even cooler.
<br>First of all, Yes, Tanenbaum was wrong, but the discussion here will last far longer than LINUX will.
</p><p>
Second of all, for the first internet "flame war", this was likely the most mild flame war I've ever seen. If people were "Flaming", they were certainly more cordial!
</p><p>
As an aside, I wonder what happens when I post here. Does it only update to Google Groups, or am I actually posting on the USENET? (I'm pretty sure it's the latter, because Groups should allow me to post to the USENET proper, but I'm not sure).
</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="kwiVbefF19gJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="max...@googlemail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i308">max...@googlemail.com</h3></p><p><span>unread,</span></p><div><p><span>Mar 15, 2012, 12:19:33 PM</span><span>3/15/12</span></p></div></div><p><span>to </span></p></div><p>Yes this is a legendary thread!
<br></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="9Thxo9y-IZUJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Tonton Th" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i312">Tonton Th</h3></p><p><span>unread,</span></p><div><p><span>Mar 20, 2012, 11:41:32 AM</span><span>3/20/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i312" role="region"><div><p>On 03/13/2012 01:59 PM, <a href="" data-email-masked="" rel="nofollow">derrick....@gmail.com</a> wrote:
</p><p>
&gt;
<br>&gt; As an aside, I wonder what happens when I post here.
<br> &gt; Does it only update to Google Groups, or am I actually
<br> &gt; posting on the USENET? (I'm pretty sure it's the latter,
<br> &gt; because Groups should allow me to post to the USENET proper,
<br> &gt; but I'm not sure).
</p></div><p>    Welcome in the good old real Usenet.
</p><p>
-- 
</p><p>
                                 Nous vivons dans un monde étrange/
<br>                                 <a href="http://foo.bar.quux.over-blog.com/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://foo.bar.quux.over-blog.com/&amp;source=gmail&amp;ust=1739122202467000&amp;usg=AOvVaw2c90TGf1Bd2JHnn6-FQDq_">http://foo.bar.quux.over-blog.com/</a></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="JAPfbTAT6okJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Srinivas Nayak" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i316">Srinivas Nayak</h3></p><p><span>unread,</span></p><div><p><span>Jun 16, 2012, 1:28:29 PM</span><span>6/16/12</span></p></div></div><p><span>to </span></p></div><p>One thing I heard is, linux 2.6 kernel doesn't support many old hardwares.
<br>What is that exactly?
<br>Is it because some device drivers removed because of bulkiness of 2.6? 
<br></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="GqH6UfK6nQ4J" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="tth...@panvistamedia.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i320">tth...@panvistamedia.com</h3></p><p><span>unread,</span></p><div><p><span>Jun 29, 2012, 11:57:33 PM</span><span>6/29/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i320" role="region"><p>On Tuesday, March 20, 2012 6:41:32 AM UTC-4, Tonton Th wrote:
</p><div><p>&gt; On 03/13/2012 01:59 PM, <a href="" data-email-masked="" rel="nofollow">derrick....@gxxxx.com</a> wrote:
<br>&gt; 
<br>&gt; &gt;
<br>&gt; &gt; As an aside, I wonder what happens when I post here.
<br>&gt;  &gt; Does it only update to Google Groups, or am I actually
<br>&gt;  &gt; posting on the USENET? (I'm pretty sure it's the latter,
<br>&gt;  &gt; because Groups should allow me to post to the USENET proper,
<br>&gt;  &gt; but I'm not sure).
<br>&gt; 
<br>&gt;     Welcome in the good old real Usenet.
</p></div><p>I thought Google Groups quickly fixed this mis-feature?
</p><p>
But with respect to the topic of the thread:
</p><div><p>  "MINIX was designed to be reasonably portable, and has been ported from the
<br>   Intel line to the 680x0 (Atari, Amiga, Macintosh), SPARC, and NS32016.
<br>   LINUX is tied fairly closely to the 80x86.  Not the way to go."
</p></div><p>How things change. As far as Minix v3 is concerned, "all the world's an x86"; downloads don't even bother naming the single supported platform: <a href="http://www.minix3.org/download/index.html" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://www.minix3.org/download/index.html&amp;source=gmail&amp;ust=1739122202468000&amp;usg=AOvVaw3dL-kaqjT-pkyFvT-xoqnv">http://www.minix3.org/download/index.html</a></p><p>
Maybe it will eventually be ported to ARM. But portability in general is, sadly, no longer a goal for the project.
</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="Jm3K-SzKV3EJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="mr.fi...@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i324">mr.fi...@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Sep 21, 2012, 3:07:18 AM</span><span>9/21/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i324" role="region"><p>Em quarta-feira, 29 de janeiro de 1992 11h23min33s UTC-2, ast  escreveu:
</p><p>&gt; I was in the U.S. for a couple of weeks, so I haven't commented much on
<br>&gt; LINUX (not that I would have said much had I been around), but for what 
<br>&gt; it is worth, I have a couple of comments now.
<br>&gt; 
<br></p><p>&gt;    MINIX is a microkernel-based system.  The file system and memory management
<br>&gt;    are separate processes, running outside the kernel.  The I/O drivers are
<br>&gt;    also separate processes (in the kernel, but only because the brain-dead
<br></p><p>&gt;    nature of the Intel CPUs makes that difficult to do otherwise).  LINUX is
</p><p>&gt;    a monolithic style system.  This is a giant step back into the 1970s.
<br>&gt;    That is like taking an existing, working C program and rewriting it in
<br>&gt;    BASIC.  To me, writing a monolithic system in 1991 is a truly poor idea.
<br>&gt; 
<br>&gt; 
<br></p><p>&gt; 2. PORTABILITY
<br>&gt;    Once upon a time there was the 4004 CPU.  When it grew up it became an
<br>&gt;    8008.  Then it underwent plastic surgery and became the 8080.  It begat
<br>&gt;    the 8086, which begat the 8088, which begat the 80286, which begat the
<br>&gt;    80386, which begat the 80486, and so on unto the N-th generation.  In
<br>&gt;    the meantime, RISC chips happened, and some of them are running at over
<br>&gt;    100 MIPS.  Speeds of 200 MIPS and more are likely in the coming years.
<br>&gt;    These things are not going to suddenly vanish.  What is going to happen
<br>&gt;    is that they will gradually take over from the 80x86 line.  They will
<br>&gt;    run old MS-DOS programs by interpreting the 80386 in software.  (I even
<br>&gt;    wrote my own IBM PC simulator in C, which you can get by FTP from
<br>&gt;    <a href="http://ftp.cs.vu.nl/" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://ftp.cs.vu.nl&amp;source=gmail&amp;ust=1739122202470000&amp;usg=AOvVaw1p6j_YSwws2qQ9rqO_McyA">ftp.cs.vu.nl</a> =  192.31.231.42 in dir minix/simulator.)  I think it is a
<br>&gt;    gross error to design an OS for any specific architecture, since that is
<br>&gt;    not going to be around all that long.
<br>&gt; 
<br></p><p>&gt;    MINIX was designed to be reasonably portable, and has been ported from the
<br>&gt;    Intel line to the 680x0 (Atari, Amiga, Macintosh), SPARC, and NS32016.
<br>&gt;    LINUX is tied fairly closely to the 80x86.  Not the way to go.
<br>&gt; 
<br></p><p>&gt; Don`t get me wrong, I am not unhappy with LINUX.  It will get all the people
<br>&gt; who want to turn MINIX in BSD UNIX off my back.  But in all honesty, I would
<br>&gt; suggest that people who want a **MODERN** "free" OS look around for a 
<br>&gt; microkernel-based, portable OS, like maybe GNU or something like that.
<br>&gt; 
<br>&gt; 
<br></p><p>&gt; Andy Tanenbaum (<a href="" data-email-masked="" rel="nofollow">a...@cs.vu.nl</a>)
<br>&gt; 
<br>&gt; 
<br>&gt; P.S. Just as a random aside, Amoeba has a UNIX emulator (running in user
<br>&gt; space), but it is far from complete.  If there are any people who would
<br>&gt; like to work on that, please let me know.  To run Amoeba you need a few 386s,
<br>&gt; one of which needs 16M, and all of which need the WD Ethernet card.
</p><p>
Yeah, this is the famous and epic discussion between Linus Torvalds and Andrew S. Tanembaum about Linux kernel architecture and how Tanembaum thinks that monolithic kernels are inferior to microkernels.
</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="Qdy0iySAmrgJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="mkam...@tvz.hr" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i328">mkam...@tvz.hr</h3></p><p><span>unread,</span></p><div><p><span>Sep 28, 2012, 3:45:52 PM</span><span>9/28/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i328" role="region"><p>Dana srijeda, 29. siječnja 1992. 14:23:33 UTC+1, korisnik ast napisao je:
</p><p>Wow,wish that either Linus or Tannenbaum would be my teachers...If any of you two ever start to work for the Technical Polytechnic of Zagreb I will be very happy.
<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="oJ9vCmwcGpgJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="nimeto...@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i332">nimeto...@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Oct 9, 2012, 8:57:07 PM</span><span>10/9/12</span></p></div></div><p><span>to </span></p></div><p>This shoulda been locked.
<br></p></div><div jsname="A9KrYd" tabindex="0" jscontroller="ywEdOe" data-doc-id="6Nj5QIdvfhcJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Martijn van Buul" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div><p><h3 id="i336">Martijn van Buul</h3></p><p><span>unread,</span></p><div><p><span>Oct 10, 2012, 2:07:26 PM</span><span>10/10/12</span></p></div></div><p><span>to </span></p></div><div jsname="A9KrYd" tabindex="0" jscontroller="ywEdOe" data-doc-id="qQrcaqvw5ZoJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="delro...@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div><p><h3 id="i340">delro...@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Oct 23, 2012, 2:35:08 AM</span><span>10/23/12</span></p></div></div><p><span>to Martijn van Buul</span></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="IxXlpicRku8J" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Martijn van Buul" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i344">Martijn van Buul</h3></p><p><span>unread,</span></p><div><p><span>Oct 23, 2012, 8:51:48 AM</span><span>10/23/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i344" role="region"><p>* <a href="" data-email-masked="" rel="nofollow">delro...@gmail.com</a>:
</p><p>Maybe I'm a zebra. That, or maybe you have no clue what you're talking about.
</p><p>I see it's obviously the latter explanation.
</p></div></div><div jsname="A9KrYd" tabindex="0" jscontroller="ywEdOe" data-doc-id="1m-ylBuHgK8J" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Edward A. Falk" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div><p><h3 id="i348">Edward A. Falk</h3></p><p><span>unread,</span></p><div><p><span>Oct 24, 2012, 2:37:48 AM</span><span>10/24/12</span></p></div></div><p><span>to </span></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="XQynGlxHmfsJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Asad Dhamani" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i352">Asad Dhamani</h3></p><p><span>unread,</span></p><div><p><span>Nov 18, 2012, 9:33:29 PM</span><span>11/18/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i352" role="region"><p>Welcome to 2012! 20 years, I have my own Linux distro! :D The future is now a thing of the past! Feels so great seeing so old threads! 
<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="BY6gQ_lZdZsJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="amyas...@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i356">amyas...@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Nov 25, 2012, 12:30:50 PM</span><span>11/25/12</span></p></div></div><p><span>to </span></p></div><p>So I can post a reply right now for this historical flame war?? And Google will actually index my name along with ast and Linus? Wow :D
<br></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="ne9QRB16vAAJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="luke...@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i360">luke...@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Nov 26, 2012, 8:34:02 PM</span><span>11/26/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i360" role="region">
<p>El miércoles, 29 de enero de 1992 09:20:50 UTC-5, David Megginson  escribió:
<br>&gt; I would like to at least look at LINUX, but I cannot, since I run
<br>&gt; a 68000-based machine. In any case, it is nice having the kernel
<br>&gt; independent, since patches like the multi-threaded FS patch don't
<br>&gt; have to exist in a different version for each CPU.
<br>&gt; 
<br>&gt; I second everything AST said, except that I would like to see
<br>&gt; the kernel _more_ independent from everything else. Why does the
<br>&gt; Intel architecture _not_ allow drivers to be independent programs?
<br>&gt; 
<br>&gt; I also don't like the fact that the kernel, mm and fs share the
<br>&gt; same configuration files. Since they _are_ independent, they should
<br>&gt; have more of a sense of independence.
<br>&gt; 
<br>&gt; 
<br>&gt; David
<br>&gt; 
<br>&gt; #################################################################
<br>&gt; David Megginson                  <a href="" data-email-masked="" rel="nofollow">meg...@epas.utoronto.ca</a>
<br>&gt; Centre for Medieval Studies      <a href="" data-email-masked="" rel="nofollow">da...@doe.utoronto.ca</a>
<br>&gt; University of Toronto            39 Queen's Park Cr. E.
<br>&gt; #################################################################
</p><p>


El miércoles, 29 de enero de 1992 09:20:50 UTC-5, David Megginson  escribió:
<br>&gt; I would like to at least look at LINUX, but I cannot, since I run
<br>&gt; a 68000-based machine. In any case, it is nice having the kernel
<br>&gt; independent, since patches like the multi-threaded FS patch don't
<br>&gt; have to exist in a different version for each CPU.
<br>&gt; 
<br>&gt; I second everything AST said, except that I would like to see
<br>&gt; the kernel _more_ independent from everything else. Why does the
<br>&gt; Intel architecture _not_ allow drivers to be independent programs?
<br>&gt; 
<br>&gt; I also don't like the fact that the kernel, mm and fs share the
<br>&gt; same configuration files. Since they _are_ independent, they should
<br>&gt; have more of a sense of independence.
<br>&gt; 
<br>&gt; 
<br>&gt; David
<br>&gt; 
<br>&gt; #################################################################
<br>&gt; David Megginson                  <a href="" data-email-masked="" rel="nofollow">meg...@epas.utoronto.ca</a>
<br>&gt; Centre for Medieval Studies      <a href="" data-email-masked="" rel="nofollow">da...@doe.utoronto.ca</a>
<br>&gt; University of Toronto            39 Queen's Park Cr. E.
<br>&gt; #################################################################
</p><p>
ast, time proved you were wrong, yet, you are the best dinosaur I ever know, 
<br>greetings from cuba.
</p><p>
Skywalker.
</p></div></div><div jsname="A9KrYd" tabindex="0" jscontroller="ywEdOe" data-doc-id="oj6J5KIOoSMJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Martijn van Buul" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div><p><h3 id="i364">Martijn van Buul</h3></p><p><span>unread,</span></p><div><p><span>Nov 27, 2012, 11:33:38 AM</span><span>11/27/12</span></p></div></div><p><span>to </span></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="sxsP5MPfqKIJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="caront...@hotmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i368">caront...@hotmail.com</h3></p><p><span>unread,</span></p><div><p><span>Dec 30, 2012, 11:32:31 PM</span><span>12/30/12</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i368" role="region"><p>El miércoles, 29 de enero de 1992 06:23:33 UTC-7, ast  escribió:
</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="ocyQDEp4XggJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="sk...@ns.sympatico.ca" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i372">sk...@ns.sympatico.ca</h3></p><p><span>unread,</span></p><div><p><span>Feb 1, 2013, 12:14:26 PM</span><span>2/1/13</span></p></div></div><p><span>to Martijn van Buul</span></p></div><div jsname="yjbGtf" aria-labelledby="i372" role="region"><div><p>On Wednesday, October 10, 2012 9:07:26 AM UTC-3, Martijn van Buul wrote:
</p><p>
&gt; &gt; This shoulda been locked.
<br>&gt; 
<br>&gt; 
<br>&gt; 
<br>&gt; This isn't a forum.
<br>&gt; 
</p></div><p>it's usenet, afaik a non-moderated newsgroup can't really have locked threads, violates the rules.
<br></p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="zgCMBcKlE64J" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="Martijn van Buul" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i376">Martijn van Buul</h3></p><p><span>unread,</span></p><div><p><span>Feb 1, 2013, 12:53:06 PM</span><span>2/1/13</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i376" role="region"><p>* <a href="" data-email-masked="" rel="nofollow">sk...@ns.sympatico.ca</a>:
</p><div><p>&gt; it's usenet, afaik a non-moderated newsgroup can't really have locked
<br>&gt; threads, violates the rules.
</p></div><p>It's not a question of "rules", it's a question of not being capable of.
</p><p>
The rules, if any, state you shouldn't post articles with a line length of
<br>more than 80 characters ;)
</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="doCINA5DkMgJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="derrick....@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i380">derrick....@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Apr 17, 2013, 6:31:22 PM</span><span>4/17/13</span></p></div></div><p><span>to </span></p></div><p>I feel like I'm a part of history.
<br>I wasn't even born when this thread opened...
<br></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="YtMVqMGb460J" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="syn4...@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i384">syn4...@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Apr 25, 2013, 7:18:37 PM</span><span>4/25/13</span></p></div></div><p><span>to </span></p></div><p>Me too. :D
<br></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="21W3UwBPdhoJ" data-subject="Re: LINUX is obsolete" data-is-first="false" data-author="usama...@gmail.com" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i388">usama...@gmail.com</h3></p><p><span>unread,</span></p><div><p><span>Apr 28, 2013, 10:57:13 AM</span><span>4/28/13</span></p></div></div><p><span>to </span></p></div><p>I am very surprised to read this thread.
<br>Was there Google and Google groups in 1992.....?
<br></p></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="IWxMnkUSHA0J" data-subject="[OT] Archives [Was: LINUX is obsolete]" data-is-first="false" data-author="Antoine Leca" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i392">Antoine Leca</h3></p><p><span>unread,</span></p><div><p><span>Apr 29, 2013, 12:58:44 PM</span><span>4/29/13</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i392" role="region"><div><p><a href="" data-email-masked="" rel="nofollow">usama...@gmail.com</a> wrote:
<br>&gt; I am very surprised to read this thread.
<br>&gt; Was there Google and Google groups in 1992.....?
</p></div><p>Not exactly; there was known as Usenet then; and Google Groups just
<br>bought the Usenet archives (through DejaNews) in 2001 IIRC.
<br>	<a href="http://www.google.com/googlegroups/archive_announce_20.html" target="_blank" rel="nofollow" data-saferedirecturl="https://www.google.com/url?hl=en-US&amp;q=http://www.google.com/googlegroups/archive_announce_20.html&amp;source=gmail&amp;ust=1739122202482000&amp;usg=AOvVaw0L9OgSnhAekkvSnXIBTS5x">http://www.google.com/googlegroups/archive_announce_20.html</a></p><p>
And since Usenet does allow threads to last and last, and since Pr
<br>Tanenbaum did not put an "Expire" header on his post, Google Groups
<br>offer you the opportunity to post to that thread. Even posts completely
<br>off-topic to that thread (or to this group comp.os.minix as well.)
</p><p>

Antoine
</p></div></div><div tabindex="0" jscontroller="ywEdOe" data-doc-id="YntFnA8-dTkJ" data-subject="Re: [OT] Archives [Was: LINUX is obsolete]" data-is-first="false" data-author="Michael Black" jsaction="VqL3Gc:xvWlrc;QvNAx:AHmuwe;JIbuQc:OOqk2e(onkYyb),OOqk2e(IgWJu),FUJCwf(OqWcW),Bmlfs(rKtXic),qHAave(k1xLRe);rcuQ6b:npT2md;DB0tFc:dvCNbf; keydown:hXsouf; click:mHokFf(A9KrYd),gfTIJc(yjbGtf),hXsouf;" aria-expanded="true" role="listitem"><div jsname="A9KrYd"><div><p><h3 id="i396">Michael Black</h3></p><p><span>unread,</span></p><div><p><span>Apr 30, 2013, 9:35:44 PM</span><span>4/30/13</span></p></div></div><p><span>to </span></p></div><div jsname="yjbGtf" aria-labelledby="i396" role="region"><p>No.
</p><p>
Google moved to a new interface, and allowed replies to messages older 
<br>than 30 days.  30 days wsa the way from the beginning, and really is 
<br>proper for old messages.  They had it that way from when they took over 
<br>the dejanews archive.  A previous time they changed the interface, and put 
<br>the bug in, but after complaints it was fixed.  I have no idea if they 
<br>removed the vandalism to old threads, but that time back some years did 
<br>cause stupid responses just like now, the idiots attracted to a thread 
<br>that google itself has pointed out as "historic", at one point they put up 
<br>a timeline of usenet and pointed to specific posts, including this one.
</p><p>
I'm tired of fighting with google, so I've never bothered complaining this 
<br>recent tiem. Their current interface may be fine for a web-based 
<br>newsgroup, but it's not right at all for Usenet.  It doesn't even show 
<br>dates, or even where the message is posted to (so nobody knows about 
<br>cross-posting.
</p><p>
There is no reason to reply to old messages.  The conversation has moved 
<br>on, if someone saved the message at the time and gets around to it later, 
<br>that's different from someone replhing through google years later.  The 
<br>posters just drop the thread into the newsgroup, they are oblivious to 
<br>where it's going.  They often don't even quote.  Suddenly a mystery 
<br>message appears in the newsgroup without context, people reply without 
<br>even wondering where the rest of the thread is.
</p><p>
The replies usually offer nothing new, they ignore that the thread back 20 
<br>years ago had plenty of answers, likely sufficient.  The replies ignore 
<br>the fact that whoever posted back when may no longer be reading the 
<br>newsgroup.  Indeed, when some idiot replies to an old message that was 
<br>offereing something for sale, the original poster may not have been there 
<br>except to post his ad.
</p><p>
All of these replies are from idiots who think it's "cool" to reply to an 
<br>old thread, like they were actually around 20 years ago.  They haven't 
<br>even added anything useful, just a bunch of "me toos".
</p><p>
The only reason I've not bothered replying to condemn these idiots is 
<br>because this is a historical thread, and I didn't want to add my 
<br>vandalism.  But since you've just given approval to it, I had to speak 
<br>out.  Don't ecnourage the idiots.
</p><p>
As an aside, deajnews only started in 1995 or 96.  Their archive is what 
<br>google bought.  But then google tracked down older archives of a more 
<br>limited nature, putting them together, which is why there is now an 
<br>incomplete archive going back to  the start of Usenet, 1979.  It's those 
<br>other archives that kept this thread, and the vandalism is because of 
<br>google, and because of the idiots who reply.
</p><p>
   Michael
</p></div></div></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Ghostwriter – use the reMarkable2 as an interface to vision-LLMs (183 pts)]]></title>
            <link>https://github.com/awwaiid/ghostwriter</link>
            <guid>42979986</guid>
            <pubDate>Sat, 08 Feb 2025 03:02:57 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://github.com/awwaiid/ghostwriter">https://github.com/awwaiid/ghostwriter</a>, See on <a href="https://news.ycombinator.com/item?id=42979986">Hacker News</a></p>
<div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><h2 tabindex="-1" dir="auto"><strong>MAIN IDEA</strong></h2><a id="user-content-main-idea" aria-label="Permalink: MAIN IDEA" href="#main-idea"></a></p>
<blockquote>
<p dir="auto">An experiment for the remarkable2 that watches what you write and, when prompted either with a gesture or some on-screen content, can write back to the screen. This is an exploration of various interacts through this handwriting+screen medium.</p>
</blockquote>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/awwaiid/ghostwriter/blob/main/docs/simple-chihuahua.jpg"><img src="https://github.com/awwaiid/ghostwriter/raw/main/docs/simple-chihuahua.jpg" width="300"></a><a target="_blank" rel="noopener noreferrer" href="https://github.com/awwaiid/ghostwriter/blob/main/docs/chihuahua-logo.png"><img src="https://github.com/awwaiid/ghostwriter/raw/main/docs/chihuahua-logo.png" width="300"></a></p>
<p dir="auto"><b><i>I wrote the handwritten prompt, GPT-4o drew the Chihuahua!!!</i></b></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/awwaiid/ghostwriter/blob/main/docs/example-kansas.gif"><img src="https://github.com/awwaiid/ghostwriter/raw/main/docs/example-kansas.gif" data-animated-image=""></a></p>
<p dir="auto"><h2 tabindex="-1" dir="auto">Setup/Installation</h2><a id="user-content-setupinstallation" aria-label="Permalink: Setup/Installation" href="#setupinstallation"></a></p>
<p dir="auto">You need an <code>OPENAI_API_KEY</code> (or similar for other models) environment variable set. I did this by adding it to my ~/.bashrc file on the remarkable:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# In the remarkable's ~/.bashrc or before you run ghostwriter, set one or more of your keys
export OPENAI_API_KEY=your-key-here
export ANTHROPIC_API_KEY=your-key-here
export GOOGLE_API_KEY=your-key-here"><pre><span><span>#</span> In the remarkable's ~/.bashrc or before you run ghostwriter, set one or more of your keys</span>
<span>export</span> OPENAI_API_KEY=your-key-here
<span>export</span> ANTHROPIC_API_KEY=your-key-here
<span>export</span> GOOGLE_API_KEY=your-key-here</pre></div>
<p dir="auto">Install by getting the binary to your remarkable. On your not-remarkable:</p>
<div dir="auto" data-snippet-clipboard-copy-content="wget https://github.com/awwaiid/ghostwriter/releases/latest/download/ghostwriter

# Replace this ip address with your remarkable ip address
scp ghostwriter root@192.168.1.117:"><pre>wget https://github.com/awwaiid/ghostwriter/releases/latest/download/ghostwriter

<span><span>#</span> Replace this ip address with your remarkable ip address</span>
scp ghostwriter root@192.168.1.117:</pre></div>
<p dir="auto">Then you have to ssh over and run it. Here is how to install and run (run these on the remarkable):</p>
<div dir="auto" data-snippet-clipboard-copy-content="# One itme -- make it executable after the initial copy
chmod +x ./ghostwriter

./ghostwriter --help # Get the options and see that it runs at all"><pre><span><span>#</span> One itme -- make it executable after the initial copy</span>
chmod +x ./ghostwriter

./ghostwriter --help <span><span>#</span> Get the options and see that it runs at all</span></pre></div>
<p dir="auto"><h2 tabindex="-1" dir="auto">Usage</h2><a id="user-content-usage" aria-label="Permalink: Usage" href="#usage"></a></p>
<p dir="auto">First you need to start <code>ghostwriter</code> on the reMarkable. SSH into your remarkable and run:</p>
<div data-snippet-clipboard-copy-content="# Use the defaults, including claude-3-5-sonnet
./ghostwriter

# Use ChatGPT with the gpt-4o-mini model
./ghostwriter --model gpt-4o-mini"><pre><code># Use the defaults, including claude-3-5-sonnet
./ghostwriter

# Use ChatGPT with the gpt-4o-mini model
./ghostwriter --model gpt-4o-mini
</code></pre></div>
<p dir="auto">Draw some stuff on your screen, and then trigger the assistant by <em>touching/tapping the upper-right corner with your finger</em>. In the ssh session you'll see other touch-detections and there is a log of what happens while it is processing. You should see some dots drawn during processing and then a typewritten or drawn response!</p>
<p dir="auto"><h2 tabindex="-1" dir="auto">Status / Journal</h2><a id="user-content-status--journal" aria-label="Permalink: Status / Journal" href="#status--journal"></a></p>
<ul dir="auto">
<li><strong>2024-10-06</strong> - Bootstrapping
<ul dir="auto">
<li>Basic proof of concept works!!!</li>
<li>Drawing back on the screen doesn't work super well; it takes the SVG output from ChatGPT and rasterizes it and then tries to draw lots of individual dots on the screen. The Remarkable flips out a bit ... and when the whole screen is a giant black square it really freaks out and doesn't complete</li>
<li>Things that worked at least once:
<ul dir="auto">
<li>Writing "Fill in the answer to this math problem... 3 + 7 ="</li>
<li>"Draw a picture of a chihuahua. Use simple line-art"</li>
</ul>
</li>
</ul>
</li>
<li><strong>2024-10-07</strong> - Loops are the stuff of souls
<ul dir="auto">
<li>I got a rudimentary gesture and status display!</li>
<li>So now you can touch in the upper-right and you get an "X" drawn. Then as the input is processed you get further crosses through the X. You have to erase it yourself though :)</li>
</ul>
</li>
<li><strong>2024-10-10</strong> - Initial virtual keyboard setup
<ul dir="auto">
<li>I've started to learn about using the Remarkable with a keyboard, something that I hadn't done before. It's surprisingly limited ... there is basicaly one large textarea for each page with some very basic formatting</li>
<li>To write in that I have to make a pretend keyboard, which we can do via rM-input-devices, and I've done basic validation that it works!</li>
<li>So now I want to introduce a mode where it always writes back to the text layer and recognizes that text comes from Machine and hadwriting from Human. Not sure that I'll like this mode</li>
</ul>
</li>
<li><strong>2024-10-20</strong> - Text output and other modes
<ul dir="auto">
<li>Slowly starting to rework the code to be less scratch-work, organized a bit</li>
<li>Now introduced <code>./ghostwriter text-assist</code> mode, uses a virtual keyboard to respond!</li>
</ul>
</li>
<li><strong>2024-10-21</strong> - Binary release build
<ul dir="auto">
<li>Got a github action all set to do binary builds</li>
</ul>
</li>
<li><strong>2024-10-23</strong> - Code shuffle
<ul dir="auto">
<li>Doing a bit of refactoring, grouping utilities into separate files</li>
<li>Yesterday a new Anthropic model came out (3.5-sonnet-new) which might be better at spacial awareness on the screen, so next up is to try that out in drawing-mode</li>
<li>In any case, next I want to set it up with <code>tools</code> so that it can contextually give back an SVG or text or start to trigger external scripts, like for TODO list management</li>
</ul>
</li>
<li><strong>2024-11-02</strong> - Tool Time
<ul dir="auto">
<li>Switch to providing some tools -- draw_text and draw_svg</li>
<li>This should make it more compatible with Anthropic?</li>
<li>More immediately, this means now there is the one overall assistant and it decides to draw back keyboard text or SVG drawing</li>
</ul>
</li>
<li><strong>2024-11-07</strong> - Claude! (Anthropic)
<ul dir="auto">
<li>More shuffling to start to isolate the API</li>
<li>... and now I added Claude/Anthropic!</li>
<li>It is able to use an almost identical tool-use setup, so I should be able to merge the two</li>
<li>So far it seems to like drawing a bit more, but it is not great at drawing and not much better at spacial awareness</li>
<li>Maybe next on the queue will be augmenting spacial awareness through some image pre-processing and result positioning. Like detect bounding boxes, segments, etc, feed that into the model, and have the model return an array of svgs and where they should be positioned. Maybe.</li>
</ul>
</li>
<li><strong>2024-11-22</strong> - Manual Evaluations
<ul dir="auto">
<li>Starting to sketch out how an evaluation might work</li>
<li>First I've added a bunch of parameters for recording input/output</li>
<li>Then I use that to record a sample input and output on the device</li>
<li>Then I added support to run ghostwriter on my laptop using the pre-captured input (build with <code>./build.sh local</code>)</li>
<li>Next I will build some tooling around iterating on examples given different prompts or pre-processing</li>
<li>And then if I can get enough examples maye I'll have to make an AI judge to scale :)</li>
<li>To help with that ... on idea is to make overlay the original input with the output but make the output a different color to make it differentiable by the judge</li>
<li>So far this technique is looking good for SVG output, but it'd be nice to somehow render keyboard output locally too. That is tricker since the keyboard input rendering is done by the reMarkable app</li>
</ul>
</li>
<li><strong>2024-12-02</strong> - Initial segmenter

</li>
<li><strong>2024-12-15</strong> - Engine Unification
<ul dir="auto">
<li>With the usual help from claude/copilot and some tutorials I extracted out some polymorphic engine layer for OpenAI and Anthropic backends</li>
<li>So now you can pass in engine and model</li>
<li>A lot of other codebases take a model and then do a map; maybe I'll do that based on the model name or something</li>
<li>I also got the prompt and tool definitions externalized (into a <code>prompts/</code> directory) and unified, so each engine does whatever it needs to adjust for its own API</li>
<li>In theory the <code>prompts/</code> files are both bundled in the executable AND overridable at runtime with a local directory, but I haven't verified that much</li>
</ul>
</li>
<li><strong>2024-12-18</strong> - System Upgrade Panic
<ul dir="auto">
<li>I auto-update my remarkable, usually fine</li>
<li>But I just got 3.16.2.3 and ... screenshots stopped working!</li>
<li>So I used <a href="https://github.com/Jayy001/codexctl">codexctl</a> to downgrade. It gave me a VERY scary "SystemError: Update failed!" and then the whole system locked up!</li>
<li>... but a reboot fixed it and the downgrade to 3.14.1.9 worked upon reboot</li>
<li>So... I'm keeping an eye out for other reports of issues on the new version</li>
<li>Oh yes. Now you can take prompts/general.json, rename it to <code>james.json</code> and go in and add "Your name is James" into the prompt. Then copy that to your reMarkable</li>
<li>Now run <code>./remarkable --prompt james.json</code> and it has a locally modified prompt!<br><a target="_blank" rel="noopener noreferrer" href="https://github.com/awwaiid/ghostwriter/blob/main/docs/james-name.png"><img src="https://github.com/awwaiid/ghostwriter/raw/main/docs/james-name.png" width="300"></a></li>
</ul>
</li>
<li><strong>2024-12-19</strong> -- Not Quite Local

</li>
<li><strong>2024-12-22</strong> -- Starting to Evaluate
<ul dir="auto">
<li>Starting to build out the evaluation system a bit more, including a <a href="https://github.com/awwaiid/ghostwriter/blob/main/run_eval.sh">basic script to kick it all off</a></li>
<li>Right now it is a hard-wired set of parameters which basically turn on/off segmentation and use either Claude 3.5 Sonnet or ChatGPT 4o-mini</li>
<li>See <a href="https://github.com/awwaiid/ghostwriter/blob/main/evaluation_results/2024-12-21_13-57-31/results.md">the initial evaluation report</a>!</li>
<li>I think markdown doesn't let me lay this out how I want, so will probably switch to html (maybe turn on github site hosting for it)</li>
<li>This is starting to get into the terratory where it can take some time and money to execute ... running this a bunch of times and I sent like $1. Not sure how long it took. but there were 48 executions in this final report</li>
<li>Oh -- I think it's rather important to run each set a few times assuming there is some temperature involved</li>
<li>To scale this even further we of course would want to bring in a JUDGE-BOT!</li>
<li>Then I could say things like "my new segmentation algorithm improved output quality by 17% per the JUDGE-BOT" etc</li>
</ul>
</li>
<li><strong>2024-12-25</strong> -- CLI simplify and expand
<ul dir="auto">
<li>Now you can pass just <code>-m gpt-4o-mini</code> and it will guess the engine is <code>openai</code></li>
<li>You can also pass <code>--engine-api-key</code> and <code>--engine-url-base</code></li>
<li>So now to use <a href="https://groq.com/" rel="nofollow">Groq</a>: <code>./ghostwriter -m llama-3.2-90b-vision-preview --engine-api-key $GROQ_API_KEY --engine openai --engine-base-url https://api.groq.com/openai</code></li>
<li>... but so far Llama 3.2 90b vision is still quite bad with this interface</li>
<li>I turned off a bunch of debugging. Now I'll need to go back and introduce log-level or something</li>
<li>BONUS: And now I've added Google Gemini! Try <code>-m gemini-2.0-flash-exp</code> with your <code>GOOGLE_API_KEY</code> set!<br><a target="_blank" rel="noopener noreferrer" href="https://github.com/awwaiid/ghostwriter/blob/main/docs/gemini_hello_chihuahua.png"><img src="https://github.com/awwaiid/ghostwriter/raw/main/docs/gemini_hello_chihuahua.png" width="200"></a></li>
</ul>
</li>
<li><strong>2024-12-28</strong> -- Usability
<ul dir="auto">
<li>I used a powered usb-hub to get an external keyboard plugged in, trying to see what sort of keyboard shortcuts we might have</li>
<li>That helped to get a further sense for where the keyboard input goes</li>
<li>So now I'm sending an extra touch-event in the bottom-center of the screen which will make the next keyboard input always go below the lowest element, which is what I wanted. Before it would go below the most recent typed text, so if you drew under that it would get confusing. Before, the answer to "what is your favorite color?" would have been placed directly below the first typed output; now it is nice and neatly put lower down! Also I guess this is a dream-bubble of a sheep?<br><a target="_blank" rel="noopener noreferrer" href="https://github.com/awwaiid/ghostwriter/blob/main/docs/sheep-dreams.png"><img src="https://github.com/awwaiid/ghostwriter/raw/main/docs/sheep-dreams.png" width="300"></a></li>
</ul>
</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">Ideas</h2><a id="user-content-ideas" aria-label="Permalink: Ideas" href="#ideas"></a></p>
<ul dir="auto">
<li>[DONE] Matt showed me his iOS super calc that just came out, take inspiration from that!
<ul dir="auto">
<li>This already kinda works, try writing an equation</li>
</ul>
</li>
<li>[DONE] A gesture or some content to trigger the request
<ul dir="auto">
<li>like an x in a certain place</li>
<li>or a hover circle -- doesn't need to be an actual touch event per se</li>
</ul>
</li>
<li>[DONE] Take a screenshot, feed it into a vision model, get some output, put the output back on the screen somehow</li>
<li>[DONE] Like with actual writing; or heck it can draw a million dots on the screen if it does it fast</li>
<li>[DONE] OK ... we can also send <em>keyboard</em> events! That means we can use the Remarkable text area. This is an awkward and weird text area that lives on a different layer from the drawing
<ul dir="auto">
<li>So maybe we can say drawing = human, text = machine</li>
<li>Probably a lot easier to erase too...</li>
</ul>
</li>
<li>[DONE] Basic Evaluation
<ul dir="auto">
<li>Create a set of screenshots for inputs</li>
<li>Represent different use-cases</li>
<li>Some of these, such as TODO-extraction, might have specific expectations for output or execution, but most of them won't</li>
<li>Run through the system to get example output -- text, svg, actions</li>
<li>Write a test suite to judge the results .... somewhat human powered? Separate VLM judge?</li>
</ul>
</li>
<li>[WIP] Prompt library
<ul dir="auto">
<li>There is already the start of this in <a href="https://github.com/awwaiid/ghostwriter/blob/main/prompts">prompts/</a></li>
<li>The idea is to give a set of tools (maybe actual llm "tools") that can be configured in the prompt</li>
<li>But also could put in there some other things ... like an external command that gets run for the tool</li>
<li>Example: a prompt that is good at my todo list management. It would look for "todo", extract that into a todo, and then run <code>add-todo.sh</code> or something
<ul dir="auto">
<li>(which would in turn ssh somewhere to add something to taskwarrior)</li>
</ul>
</li>
</ul>
</li>
<li>Initial config
<ul dir="auto">
<li>On first run, maybe create a config file</li>
<li>Could prompt for openai key and then write it into the file</li>
<li>Maybe an auto-start, auto-recovery?</li>
</ul>
</li>
<li>Generate Diagrams
<ul dir="auto">
<li>Let one of the outputs be plantuml and/or mermaid, and then turn that into an SVG/png that it then outputs to the screen</li>
</ul>
</li>
<li>External stuff
<ul dir="auto">
<li>Let it look things up</li>
<li>Let it send me stuff ... emails, slacks</li>
</ul>
</li>
<li>Conversation Mode
<ul dir="auto">
<li>On a single screen, keep track of each version of the screen betweent turns</li>
<li>So first send would be the screen</li>
<li>Second send would be the original screen and then the response screen (maybe with claude output in red) and then the new additions (maybe in green?)
<ul dir="auto">
<li>This could then be a whole chain for the page</li>
<li>Could have two separate buttons to trigger the VLM -- one for "new prompt" and one for "continue"</li>
</ul>
</li>
<li>OR we could make it so that every time it was the last three:
<ul dir="auto">
<li>Black: Original</li>
<li>Red: Claude response</li>
<li>Green: New input</li>
</ul>
</li>
<li>Or could use the same color structure but a whole chain of messages?</li>
<li>Might be weird when we go to a new blank page though. It'd look like the new input erased everything</li>
<li>In general this would also make it easier to handle scrolling maybe</li>
</ul>
</li>
<li>Run off of a network-local VLM (like ollama)
<ul dir="auto">
<li>First attempt at using the OpenAI-API compatible ollama failed; the ollama LLAMA 3.2 vision model doesn't support tools</li>
<li>Though Groq has a modified llama-3.2-vision that DOES have tools... but it isn't nearly as good as ChatGPT, Claude, or Gemini.</li>
</ul>
</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">References</h2><a id="user-content-references" aria-label="Permalink: References" href="#references"></a></p>
<ul dir="auto">
<li>Generally pulled resources from <a href="https://github.com/reHackable/awesome-reMarkable">Awesome reMarkable</a></li>
<li>Adapted screen capture from <a href="https://github.com/cloudsftp/reSnap">reSnap</a></li>
<li>Techniques for screen-drawing inspired from <a href="https://github.com/rmkit-dev/rmkit/blob/master/src/lamp/main.cpy">rmkit lamp</a></li>
<li>Super cool SVG-to-png done with <a href="https://github.com/RazrFalcon/resvg">resvg</a></li>
<li>Make the keyboard input device even without a keyboard via <a href="https://github.com/pl-semiotics/rM-input-devices">rM-input-devices</a></li>
<li>Not quite the same, but I recently found <a href="https://github.com/nickian/reMarkableAI">reMarkableAI</a> that does OCR→OpenAI→PDF→Device</li>
<li>Another reMarkable-LLM interface is <a href="https://github.com/StarNumber12046/rMAI">rMAI</a>. This one is a separate app (not trying to integrate in with simulated pen/keyboard input) and uses <a href="https://replicate.com/" rel="nofollow">replicate</a> as the model API service</li>
<li>I haven't adopted anything from it yet, but <a href="https://github.com/machinelevel/sp425-crazy-cow">Crazy Cow</a> is a cool/crazy tool that turns text into pen strokes for the reMarkable1</li>
</ul>
<p dir="auto"><h2 tabindex="-1" dir="auto">Development</h2><a id="user-content-development" aria-label="Permalink: Development" href="#development"></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="# Initial dependencies install (also ... rust, which I get via asdf)
rustup target add armv7-unknown-linux-gnueabihf
sudo apt-get install gcc-arm-linux-gnueabihf
cargo install cross

# Then to build
cross build --release --target=armv7-unknown-linux-gnueabihf

# And deploy by scp'ing the binary over and run it on the device!
scp target/armv7-unknown-linux-gnueabihf/release/ghostwriter remarkable:"><pre><span><span>#</span> Initial dependencies install (also ... rust, which I get via asdf)</span>
rustup target add armv7-unknown-linux-gnueabihf
sudo apt-get install gcc-arm-linux-gnueabihf
cargo install cross

<span><span>#</span> Then to build</span>
cross build --release --target=armv7-unknown-linux-gnueabihf

<span><span>#</span> And deploy by scp'ing the binary over and run it on the device!</span>
scp target/armv7-unknown-linux-gnueabihf/release/ghostwriter remarkable:</pre></div>
<p dir="auto"><h2 tabindex="-1" dir="auto">Scratch Notes</h2><a id="user-content-scratch-notes" aria-label="Permalink: Scratch Notes" href="#scratch-notes"></a></p>
<div data-snippet-clipboard-copy-content="
# Record an evaluation on the device
./ghostwriter --output-file tmp/result.out --model-output-file tmp/result.json --save-screenshot tmp/input.png --no-draw-progress --save-bitmap tmp/result.png claude-assist

# On local, copy the evaluation to local and then put it into a folder
export evaluation_name=tic_tac_toe_1
rm tmp/*
scp -r remarkable:tmp/ ./
mkdir -p evaluations/$evaluation_name
mv tmp/* evaluations/$evaluation_name

# Run an evaluation
./target/release/ghostwriter --input-png evaluations/$evaluation_name/input.png --output-file tmp/result.out --model-output-file tmp/result.json --save-bitmap tmp/result.png --no-draw --no-draw-progress --no-loop --no-trigger claude-assist

# Layer the input and output
convert \( evaluations/$evaluation_name/input.png -colorspace RGB \) \( tmp/result.png -type truecolormatte -transparent white -fill red -colorize 100 \) -compose Over -composite tmp/merged-output.png"><pre><code>
# Record an evaluation on the device
./ghostwriter --output-file tmp/result.out --model-output-file tmp/result.json --save-screenshot tmp/input.png --no-draw-progress --save-bitmap tmp/result.png claude-assist

# On local, copy the evaluation to local and then put it into a folder
export evaluation_name=tic_tac_toe_1
rm tmp/*
scp -r remarkable:tmp/ ./
mkdir -p evaluations/$evaluation_name
mv tmp/* evaluations/$evaluation_name

# Run an evaluation
./target/release/ghostwriter --input-png evaluations/$evaluation_name/input.png --output-file tmp/result.out --model-output-file tmp/result.json --save-bitmap tmp/result.png --no-draw --no-draw-progress --no-loop --no-trigger claude-assist

# Layer the input and output
convert \( evaluations/$evaluation_name/input.png -colorspace RGB \) \( tmp/result.png -type truecolormatte -transparent white -fill red -colorize 100 \) -compose Over -composite tmp/merged-output.png
</code></pre></div>
<p dir="auto">Prompt / Tool ideas:</p>
<ul dir="auto">
<li>There are a few models for tools -- each tool can be re-usable and generalized or each tool could include things like extra-inputs for chain-of thought and hints for what goes into each parameter</li>
<li>The prompts should be plain JSON or YAML and should be normalized across V/LLM models</li>
<li>A general direction I'm thinking is to have top-level "modes" that each have a main prompt and a set of tools they can use</li>
<li>But maybe there can be a whole state-machine flow that the follow also?</li>
<li>So like ... a math-helper might have a different state-machine than a todo-helper</li>
<li>The states would be start, intermediate, and terminal</li>
<li>The terminal states should all have some output or effect, those are the ones that do something</li>
<li>The start state is the initial prompt</li>
<li>One intermediate state could be <code>thinking</code> where it can use the input of the tool as a place to write out thoughts, and the output of the tool is ignored</li>
<li>But overall what we're leading to here is a system where the prompts are easy to write, easy to copy/paste, easy to maintain</li>
<li>And then maybe we can have a set of evals or examples that are easy to use on top of a prompt mode</li>
<li>Increasingly, the reMarkable2 case might HAPPEN to be a specific prompt we set up in this system...</li>
<li>So the state machine chould be:</li>
</ul>
<section data-identity="6af76b40-5cb9-4682-aab3-e2f7f80c83d2" data-host="https://viewscreen.githubusercontent.com" data-src="https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com" data-type="mermaid" aria-label="mermaid rendered output container">
  <div dir="auto" data-json="{&quot;data&quot;:&quot;stateDiagram-v2\n    [*] --&amp;gt; Screenshot\n    Screenshot --&amp;gt; OutputScreen\n    Screenshot --&amp;gt; OutputKeyboardText\n&quot;}" data-plain="stateDiagram-v2
    [*] --> Screenshot
    Screenshot --> OutputScreen
    Screenshot --> OutputKeyboardText
">
      <pre lang="mermaid" aria-label="Raw mermaid code">stateDiagram-v2
    [*] --&gt; Screenshot
    Screenshot --&gt; OutputScreen
    Screenshot --&gt; OutputKeyboardText
</pre>
    </div>
  <span role="presentation">
    <span data-view-component="true">
      <span>Loading</span>
</span>
  </span>
</section>

<section data-identity="c37795ec-f89c-407a-b274-4c0d2f25e052" data-host="https://viewscreen.githubusercontent.com" data-src="https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com" data-type="mermaid" aria-label="mermaid rendered output container">
  <div dir="auto" data-json="{&quot;data&quot;:&quot;stateDiagram-v2\n    [*] --&amp;gt; WaitForTouch\n    WaitForTouch --&amp;gt; Screenshot\n    Screenshot --&amp;gt; OutputScreen\n    Screenshot --&amp;gt; OutputKeyboardText\n    OutputScreen --&amp;gt; [*]\n    OutputKeyboardText --&amp;gt; [*]\n&quot;}" data-plain="stateDiagram-v2
    [*] --> WaitForTouch
    WaitForTouch --> Screenshot
    Screenshot --> OutputScreen
    Screenshot --> OutputKeyboardText
    OutputScreen --> [*]
    OutputKeyboardText --> [*]
">
      <pre lang="mermaid" aria-label="Raw mermaid code">stateDiagram-v2
    [*] --&gt; WaitForTouch
    WaitForTouch --&gt; Screenshot
    Screenshot --&gt; OutputScreen
    Screenshot --&gt; OutputKeyboardText
    OutputScreen --&gt; [*]
    OutputKeyboardText --&gt; [*]
</pre>
    </div>
  <span role="presentation">
    <span data-view-component="true">
      <span>Loading</span>
</span>
  </span>
</section>

<section data-identity="9b785cb0-c2fd-40a6-aceb-97efa237742f" data-host="https://viewscreen.githubusercontent.com" data-src="https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com" data-type="mermaid" aria-label="mermaid rendered output container">
  <div dir="auto" data-json="{&quot;data&quot;:&quot;stateDiagram-v2\n    [*] --&amp;gt; WaitForTouch\n    WaitForTouch --&amp;gt; Screenshot\n    Screenshot --&amp;gt; Thinking\n    Thinking --&amp;gt; Thinking\n    Thinking --&amp;gt; OutputScreen\n    Thinking --&amp;gt; OutputKeyboardText\n    OutputScreen --&amp;gt; [*]\n    OutputKeyboardText --&amp;gt; [*]\n&quot;}" data-plain="stateDiagram-v2
    [*] --> WaitForTouch
    WaitForTouch --> Screenshot
    Screenshot --> Thinking
    Thinking --> Thinking
    Thinking --> OutputScreen
    Thinking --> OutputKeyboardText
    OutputScreen --> [*]
    OutputKeyboardText --> [*]
">
      <pre lang="mermaid" aria-label="Raw mermaid code">stateDiagram-v2
    [*] --&gt; WaitForTouch
    WaitForTouch --&gt; Screenshot
    Screenshot --&gt; Thinking
    Thinking --&gt; Thinking
    Thinking --&gt; OutputScreen
    Thinking --&gt; OutputKeyboardText
    OutputScreen --&gt; [*]
    OutputKeyboardText --&gt; [*]
</pre>
    </div>
  <span role="presentation">
    <span data-view-component="true">
      <span>Loading</span>
</span>
  </span>
</section>

</article></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Starlink in the Falkland Islands – A national emergency situation? (142 pts)]]></title>
            <link>https://www.openfalklands.com/february-2025-starlink-in-the-falkland-islands-a-national-emergency-situation/</link>
            <guid>42979869</guid>
            <pubDate>Sat, 08 Feb 2025 02:41:35 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://www.openfalklands.com/february-2025-starlink-in-the-falkland-islands-a-national-emergency-situation/">https://www.openfalklands.com/february-2025-starlink-in-the-falkland-islands-a-national-emergency-situation/</a>, See on <a href="https://news.ycombinator.com/item?id=42979869">Hacker News</a></p>
Couldn't get https://www.openfalklands.com/february-2025-starlink-in-the-falkland-islands-a-national-emergency-situation/: Error: timeout of 10000ms exceeded]]></description>
        </item>
        <item>
            <title><![CDATA[VSCode's SSH Agent Is Bananas (632 pts)]]></title>
            <link>https://fly.io/blog/vscode-ssh-wtf/</link>
            <guid>42979467</guid>
            <pubDate>Sat, 08 Feb 2025 01:25:32 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://fly.io/blog/vscode-ssh-wtf/">https://fly.io/blog/vscode-ssh-wtf/</a>, See on <a href="https://news.ycombinator.com/item?id=42979467">Hacker News</a></p>
<div id="readability-page-1" class="page"><article>
         <dl>
             <dt>Author</dt>
             <dd>
                 <img alt="Thomas Ptacek" src="https://fly.io/static/images/thomas.webp">
               <dl>
                 <dt>Name</dt>
                 <dd>
                   Thomas Ptacek
                 </dd>
                  <dt>@tqbf</dt>
                  <dd>
                    <a href="https://twitter.com/tqbf" target="_blank">
                      @tqbf
                    </a>
                  </dd>
               </dl>
             </dd>
         </dl>

        <section>
          <p>We’re interested in getting integrated into the flow VSCode uses to do remote editing over SSH, because everybody is using VSCode now, and, in particular, they’re using forks of VSCode that generate code with LLMs. </p>
<p>”hallucination” is what we call it when LLMs get code wrong; “engineering” is what we call it when people do.</p>
<p>LLM-generated code is <a href="https://nicholas.carlini.com/writing/2024/how-i-use-ai.html" title="">useful in the general case</a> if you know what you’re doing. But it’s ultra-useful if you can close the loop between the LLM and the execution environment (with an “Agent” setup). There’s lots to say about this, but for the moment: it’s a semi-effective antidote to hallucination: the LLM generates the code, the agent scaffolding runs the code, the code generates errors, the agent feeds it back to the LLM, the process iterates. </p>

<p>So, obviously, the issue here is you don’t want this iterative development process happening on your development laptop, because LLMs have boundary issues, and they’ll iterate on your system configuration just as happily on the Git project you happen to be working in. A thing you’d really like to be able to do: run a closed-loop agent-y (“agentic”? is that what we say now) configuration for an LLM, on a clean-slate Linux instance that spins up instantly and that can’t screw you over in any way. You get where we’re going with this.</p>

<p>Anyways! I would like to register a concern.</p>

<p>Emacs hosts the spiritual forebearer of remote editing systems, a blob of hyper-useful Elisp called <a href="https://www.gnu.org/software/tramp/" title="">“Tramp”</a>. If you can hook Tramp up to any kind of interactive environment — usually, an SSH session — where it can run Bourne shell commands, it can extend Emacs to that environment.</p>

<p>So, VSCode has a feature like Tramp. Which, neat, right? You’d think, take Tramp, maybe simplify it a bit, switch out Elisp for Typescript.</p>

<p>You’d think wrong!</p>

<p>Unlike Tramp, which lives off the land on the remote connection, VSCode mounts a full-scale invasion: it runs a Bash snippet stager that downloads an agent, including a binary installation of Node. </p>

<p>I <em>think</em> this is <a href="https://github.com/microsoft/vscode/tree/c9e7e1b72f80b12ffc00e06153afcfedba9ec31f/src/vs/server/node" title="">the source code</a>?</p>

<p>The agent runs over port-forwarded SSH. It establishes a WebSockets connection back to your running VSCode front-end. The underlying protocol on that connection can:</p>

<ul>
<li>Wander around the filesystem
</li><li>Edit arbitrary files
</li><li>Launch its own shell PTY processes
</li><li>Persist itself
</li></ul>

<p>In security-world, there’s a name for tools that work this way. I won’t say it out loud, because that’s not fair to VSCode, but let’s just say the name is murid in nature.</p>

<p>I would be a little nervous about letting people VSCode-remote-edit stuff on dev servers, and apoplectic if that happened during an incident on something in production. </p>

<p>It turns out we don’t have to care about any of this to get a custom connection to a Fly Machine working in VSCode, so none of this matters in any kind of deep way, but: we’ve decided to just be a blog again, so: we had to learn this, and now you do too.</p>

          
        </section>
        <dl>
            <dt>
              Previous post  ↓
            </dt>
            <dd>
              <a href="https://fly.io/blog/ai-gpu-clusters-from-your-laptop-livebook/">
                AI GPU Clusters, From Your Laptop, With Livebook
              </a>
            </dd>
        </dl>
      </article></div>]]></description>
        </item>
    </channel>
</rss>