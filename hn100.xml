<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>HN100 - Readable Contents</title>
        <link>https://hn.algolia.com/api/v1/search_by_date?tags=%28story,poll%29&amp;numericFilters=points%3E100</link>
        <description>Uses Readability to add bodies to the RSS feed</description>
        <lastBuildDate>Sat, 07 Sep 2024 16:30:01 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Keyhole – Forge own Windows Store licenses (307 pts)]]></title>
            <link>https://massgrave.dev/blog/keyhole</link>
            <guid>41472643</guid>
            <pubDate>Sat, 07 Sep 2024 09:13:00 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://massgrave.dev/blog/keyhole">https://massgrave.dev/blog/keyhole</a>, See on <a href="https://news.ycombinator.com/item?id=41472643">Hacker News</a></p>
Couldn't get https://massgrave.dev/blog/keyhole: Error: timeout of 10000ms exceeded]]></description>
        </item>
        <item>
            <title><![CDATA[Asynchronous IO: the next billion-dollar mistake? (141 pts)]]></title>
            <link>https://yorickpeterse.com/articles/asynchronous-io-the-next-billion-dollar-mistake/</link>
            <guid>41471707</guid>
            <pubDate>Sat, 07 Sep 2024 05:43:29 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://yorickpeterse.com/articles/asynchronous-io-the-next-billion-dollar-mistake/">https://yorickpeterse.com/articles/asynchronous-io-the-next-billion-dollar-mistake/</a>, See on <a href="https://news.ycombinator.com/item?id=41471707">Hacker News</a></p>
<div id="readability-page-1" class="page"><section><header><time datetime="2024-09-06T16:00:00Z">September 6, 2024</time></header><p>
Asynchronous IO (also known as "non-blocking IO") is a technique applications
use to allow performing of many IO operations without blocking the calling OS
thread, and without needing to spawn many threads (i.e. one thread per
operation). In the late 1990s/early 2000s, an increasing amount of people using
the internet meant an increasing amount of traffic web services needed to
handle, better known as the <a href="https://en.wikipedia.org/wiki/C10k_problem">C10K
problem</a>.</p><p>Using asynchronous IO to approach this problem appears compelling: it allows you
to handle many connections at once, without needing to increase the number of OS
threads. This is especially compelling if you consider that support for good
multi-threading was still a hit a miss at the time. For example, Linux didn't
have good support for threads until the 2.6 release in December 2003.</p><p>Since then the use of and support for asynchronous IO has grown. Languages such
as Go and Erlang bake support for asynchronous IO directly into the language,
while others such as Rust rely on third-party libraries such as
<a href="https://tokio.rs/">Tokio</a>.</p><p><a href="https://inko-lang.org/">Inko</a>, a language that I'm working on, also includes
built-in support for asynchronous IO. Similar to Go and Erlang, this is hidden
from the user. For example, when reading from a socket there's no need to
explicitly poll or "await" anything, as the language takes care of it for you:</p><div><pre><code><span>import</span> std.net.ip (IpAddress)
<span>import</span> std.net.socket (TcpClient)

<span>class</span> <span>async</span> Main {
  <span>fn</span> <span>async</span> main {
    <span>let</span> client = TcpClient.new(ip: IpAddress.v4(<span>1</span>, <span>1</span>, <span>1</span>, <span>1</span>), port: <span>80</span>).or_panic(
      <span>'failed to connect'</span>,
    )

    client
      .write_string(<span>'GET / HTTP/1.0\r\nHost: one.one.one.one\r\n\r\n'</span>)
      .or_panic(<span>'failed to write the request'</span>)

    ...
  }
}
</code></pre></div><p>If the write would block, Inko's scheduler sets aside the calling process and
reschedules it when the write can be performed without blocking. Other languages
use a different mechanism, such as callbacks or
<a href="https://en.wikipedia.org/wiki/Async/await">async/await</a>. Each approach comes
with its own set of benefits, drawbacks and challenges.</p><p>Not every IO operation can be performed asynchronously though. File IO is
perhaps the best example of this (at least on Linux). To handle such cases,
languages must provide some sort of alternative strategy such as performing the
work in a dedicated pool of OS threads.</p><div><p>Using <a href="https://en.wikipedia.org/wiki/Io_uring">io_uring</a> is another approach,
but it's a recent addition to Linux, specific <em>to</em> Linux (meaning you need a
fallback for other platforms), and <a href="https://www.phoronix.com/news/Google-Restricting-IO_uring">disabled entirely by
some</a>. Either way,
the point still stands: you end up having to handle sockets and files (and
potentially other types of "files") differently.</p></div><p>For example, Inko handles this by the standard library signalling to the
scheduler it's about to perform a potentially blocking operation. The scheduler
periodically checks threads in a "we might be blocking" state. If the thread is
in such a state for too long, it's flagged as "blocking" and a backup thread is
woken up to take over its work. When the blocked thread finishes its work, it
reschedules the process it was running and becomes a backup thread itself. While
this works, it limits the amount of blocking IO operations you can perform
concurrently to the number of backup threads you have. Automatically adding and
removing threads can improve things, but increases the complexity of the system.</p><p>In 2009, <a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a> stated that his
invention of NULL pointers was something he considers a "billion-dollar mistake"
due to the problems and headaches it brought with it. The more I work on systems
that use asynchronous IO, the more I wonder: is asynchronous IO the next
billion-dollar mistake?</p><p>More specifically, what if instead of spending 20 years developing various
approaches to dealing with asynchronous IO (e.g. async/await), we had instead
spent that time making OS threads more efficient, such that one wouldn't need
asynchronous IO in the first place?</p><p>To illustrate, consider the Linux kernel today: spawning an OS thread takes
somewhere between 10 and 20 microseconds (<a href="https://github.com/inko-lang/inko/issues/690">based on my own
measurements</a>), while a context
switch takes somewhere in the range of <a href="https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/">1-2
microseconds</a>.
This becomes a problem when you want to spawn many threads such that each
blocking operation is performed on its own thread. Not only do you need many OS
threads, but the time to start them can also vary greatly, and the more OS
threads you have the more context switches occur. The end result is that while
you certainly can spawn many OS threads, performance will begin to deteriorate
as the number of threads increases.</p><p>Now imagine a parallel universe where instead of focusing on making asynchronous
IO work, we focused on improving the performance of OS threads such that one can
easily use hundreds of thousands of OS threads without negatively impacting
performance (= the cost to start threads is lower, context switches are cheaper,
etc). In this universe, asynchronous IO and async/await wouldn't need to exist
(or at least wouldn't be as widely used). You need to handle 100 000 requests
that perform a mixture of IO and CPU bound work? Just use 100 000 threads and
let the OS handle it.</p><p>Not only would this offer an easier mental model for developers, it also leads
to a simpler stack. Libraries such as epoll and kqueue wouldn't need to exist,
as one would just start a new OS thread for their blocking/polling needs.
Need to call a C function that may block the calling thread? Just run it on a
separate thread, instead of having to rely on some sort of mechanism provided by
the IO runtime/language to deal with blocking C function calls.</p><p>Unfortunately, we do not live in such a universe. Instead in our universe the
cost of OS threads is quite high, and inconsistent across platforms. Which
brings me back to Tony Hoare: over the decades, we invested a massive amount of
resources in dealing with asynchronous IO, perhaps billions of dollars worth of
resources. Was that a mistake and should we have instead invested that into
improving the performance of OS threads? I think so, but until an operating
system comes along that dramatically improves the performance of threads ,
becomes as popular as Linux, <em>and</em> is capable of running everything you can run
on Linux or provide better alternatives (such that people will actually want to
switch), we're stuck with asynchronous IO.</p></section></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Malaysia started mandating ISPs to redirect DNS queries to local servers (232 pts)]]></title>
            <link>https://thesun.my/local-news/mcmc-addresses-misinformation-on-dns-redirection-internet-access-restrictions-BN12972452</link>
            <guid>41471510</guid>
            <pubDate>Sat, 07 Sep 2024 04:50:52 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://thesun.my/local-news/mcmc-addresses-misinformation-on-dns-redirection-internet-access-restrictions-BN12972452">https://thesun.my/local-news/mcmc-addresses-misinformation-on-dns-redirection-internet-access-restrictions-BN12972452</a>, See on <a href="https://news.ycombinator.com/item?id=41471510">Hacker News</a></p>
<div id="readability-page-1" class="page"><div> <p><b>KUALA LUMPUR: </b>The Malaysian Communications and Multimedia Commission (MCMC) has instructed Internet Service Providers (ISPs) to redirect Domain Name Service (DNS) traffic that uses third-party DNS servers back to their own DNS servers.</p> <p>MCMC in a statement tonight said this is to ensure that users continue to benefit from the protection provided by the local ISP’s DNS servers and that malicious sites are inaccessible to Malaysians.</p> <p>As a commitment to protecting the safety of Internet users, MCMC has blocked a total of 24,277 websites between between 2018 to Aug 1, classified into various categories, which are online gambling (39 per cent), pornography/obscene content (31 per cent), copyright infringement (14 per cent), other harmful sites (12 per cent), prostitution (two per cent) and unlawful investments/scams (two per cent).</p> <p>“It has been falsely claimed that the measure undertaken by MCMC is a draconian measure. We reiterate that Malaysia’s implementation is for the protection of vulnerable groups from harmful online content.</p> <p>“The DNS system can protect users by blocking access to websites known for distributing malware, phishing, and other malicious activities, as well as filter inappropriate content such as adult material and violent websites,” the statement said.</p> <p>MCMC said some users choose to use third-party DNS servers like Google DNS or Cloudflare, which are said to offer various benefits, such as faster speeds and increased privacy, but they might not have the same level of protection for harmful content particularly in the local context, compared to local ISP’s DNS servers.</p> <p>DNS is a system designed to turn website addresses into numeric IP addresses to locate websites on the Internet, while ISPs typically operate their own DNS servers, which can be configured to block access to certain websites or domains based on their content, a common method used to protect users from harmful content.</p> <p>The statement said an inaccurate claim also suggested that a so-called blanket ban, with some suggesting that legitimate websites have been made inaccessible because of DNS redirection.</p> <p>“Websites are only blocked when they are found to host malicious content, such as copyright infringements, online gambling, or pornography. Legitimate websites remain accessible as usual, and DNS redirection ensures that harmful content is filtered out while safe sites remain reachable without noticeable disruption,” the statement said.</p> <p>Thus, MCMC encouraged users to report any difficulties in accessing legitimate websites directly to their respective ISPs so the issue could be addressed promptly, as they have yet to receive any such complaint.</p> <p>Moreover, any websites that believe they have been unfairly targeted or affected may file an appeal through the established channels, it said.</p> <p>The Appeals Tribunal, established by MCMC and chaired by a High Court judge, operates independently to ensure a fair and impartial review of each case.</p> <p>“ MCMC remains committed to maintaining a safe and secure online environment in Malaysia, balancing the protection of internet users with the need for seamless access to legitimate online content,” it said</p> <p>Previously, it has been announced that MCMC will introduce a new regulatory framework for safe Internet use by children and families on Aug 1, with implementation set for Jan 1, 2025.</p> <p>Under the new framework, social media and Internet messaging services with at least eight million registered users in Malaysia must apply for an Application Service Provider Class Licence under the Communications and Multimedia Act 1998 (Act 588).</p> </div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[What's new in C++26 (part 1) (115 pts)]]></title>
            <link>https://mariusbancila.ro/blog/2024/09/06/whats-new-in-c26-part-1/</link>
            <guid>41471488</guid>
            <pubDate>Sat, 07 Sep 2024 04:44:37 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://mariusbancila.ro/blog/2024/09/06/whats-new-in-c26-part-1/">https://mariusbancila.ro/blog/2024/09/06/whats-new-in-c26-part-1/</a>, See on <a href="https://news.ycombinator.com/item?id=41471488">Hacker News</a></p>
<div id="readability-page-1" class="page"><article id="post-4733">

	

	
	<div>
		
<p>The C++26 version of the C++ standard is a work in progress, but a series of language and library features have been already added. Furthermore, some of them are already supported by Clang and GCC. One of these new changes was discussed in my previous article, <a href="https://mariusbancila.ro/blog/2024/04/21/erroneous-behaviour-has-entered-the-chat/" target="_blank" rel="noopener" title="">Erroneous behaviour has entered the chat</a>. In this post, we will look at several language features added in C++26.</p>



<h2>Specifying a reason for deleting a function</h2>



<p>Since C++11, we can declare a function as deleted, so that the compiler will prevent its use. This can be used to prevent the use of class special member functions, but also to delete any other function. A function can be deleted as follows (example from the proposal paper):</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class NonCopyable
{
public:
    // ...
    NonCopyable() = default;

    // copy members
    NonCopyable(const NonCopyable&amp;) = delete;
    NonCopyable&amp; operator=(const NonCopyable&amp;) = delete;
    // maybe provide move members instead
};</pre>



<p>In C++26, you can specify a reason why this function is deleted:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class NonCopyable
{
public:
    // ...
    NonCopyable() = default;

    // copy members
    NonCopyable(const NonCopyable&amp;)
        = delete("Since this class manages unique resources, copy is not supported; use move instead.");
    NonCopyable&amp; operator=(const NonCopyable&amp;)
        = delete("Since this class manages unique resources, copy is not supported; use move instead.");
    // provide move members instead
};</pre>



<p>The reason for having this feature is to help API authors to provide tailored messages for the removal of a function, instead of just relying on the generic compiler error for using a deleted function.</p>



<p>For more info see: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2573r2.html" target="_blank" rel="noopener" title="">P2573R2: = delete(“should have a reason”);</a></p>



<h2>Placeholder variables with no name</h2>



<p>There are cases when a variable has to be declared but its name is never used. An example is structure bindings. Another is locks (like <code>lock_guard</code>), that are only used for their side-effects. In the future, another example could be pattern matching (for which several proposals exist).</p>



<p>In C++26, we can use a single underscore (<code>_</code>) to define an unnamed variable.</p>



<p>For instance, in the following example, <code>unused</code> is a variable that is not used:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">[[maybe_unused]] auto [data, unused] = get_data();</pre>



<p>In C++26, the <code>unused</code> variable can be named <code>_</code> (single underscore):</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">auto [data, _] = get_data();</pre>



<p>When the single underscore identifier is used for the declaration of a variable, non-static class member variable, lambda capture, or structure binding, the <code>[[maybe_unused]]</code> attribute is implicitly added, therefore, there is no need to explicitly use it.</p>



<p>A declaration with the name <code>_</code> is said to be <em>name-independent</em> if it declares:</p>



<ul><li>a variable with automatic storage duration</li><li>a structure binding, but not in a namespace scope</li><li>a variable introduced by an init capture</li><li>a non-static data member</li></ul>



<p>The compiler will not emit warnings that a name-independent declaration is used or not. Moreover, multiple name-independent declarations can be used in the same scope (that is not a namespace scope):</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int main()
{
  int _;
  _ = 0;         // OK

  std::string _; // OK, because _ is a name-independent declaration
  _ = "0";       // Error: ambiguous reference to placeholder '_', which is defined multiple times
}</pre>



<p>On the other hand, the following is not possible:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int main()
{
  int _;
  _ = 0;                // OK

  static std::string _; // Error: static variables are not name-independent
}</pre>



<p>The following is also not possible, because the declarations are in a namespace scope:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">namespace n
{
  int f() {return 42;}

  auto _ = f(); // OK
  auto _ = f(); // Error: redefinition of _
}</pre>



<p>To learn more about this feature see: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2169r4.pdf" target="_blank" rel="noopener" title="">P2169: A nice placeholder with no name</a>.</p>



<h2>Structured binding declaration as a&nbsp;condition</h2>



<p>A structure binding defines a set of variables that are bound to sub-objects or elements of their initializer.</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">auto [position, length] = get_next_token(text, offset);</pre>



<p>A structure binding can appear in a for-range declaration, such as in the following example:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">for (auto [position, length] : tokenize(text, offset))
{
  std::println("pos {}, len {}", position, length);
}</pre>



<p>On the other hand, variables can appear in the condition of an <code>if</code>, <code>while</code>, or <code>for</code> statement:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (auto it = std::find_if(begin(arr), end(arr), is_even); it != std::end(arr))
{
  std::println("{} is the 1st even number", *it);
}</pre>



<p>However, structure bindings cannot be declared in the condition of an <code>if</code>, <code>while</code>, or <code>for</code> statement. That changes in C++26, which makes it possible:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if(auto [position, length] = get_next_token(text, offset); position &gt;= 0)
{
  std::println("pos {}, len {}", position, length);
}</pre>



<p>An interesting and very useful case is presented in the proposal paper (P0963). Consider the following C++26 example for using <code>std::to_chars</code>:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (auto result = std::to_chars(p, last, 42))
{
​​​​    auto [ptr, _] = result;
​​​​    // okay to proceed
​​​​} 
else 
{
​​​​    auto [ptr, ec] = result;
​​​​    // handle errors
​​​​}</pre>



<p>When the function succeeds, we are only interested in the <code>ptr</code> member of <code>std::to_chars_result</code>, which contains a pointer to the one-past-the-end pointer of the characters written. If the function fails, then we also need to look at the <code>ec</code> member (of the <code>std::errc</code> type) representing an error code.</p>



<p>This code can be simplified with structure bindings, in C++26, as follows:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">​​​​if (auto [ptr, ec] = std::to_chars(p, last, 42))
{
​​​​    // okay to proceed
​​​​} 
else 
{
​​​​    // handle errors
​​​​}</pre>



<p>To learn more about this feature see: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0963r3.html" target="_blank" rel="noopener" title="">P0963: Structured binding declaration as a condition</a>.</p>



<h2>user-generated static_assert messages</h2>



<p>The <code>static_assert</code>‘s second parameter, which is a string representing the error message, can now be a compile-time user-generated string-like object. The following example uses a hypothetical constexpr <code>std::format</code>, although this may also later appear in C++26:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">static_assert(sizeof(int) == 4, std::format("Expected 4, actual {}", sizeof(int)));</pre>



<p>To learn more about this feature see: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2741r3.pdf" target="_blank" rel="noopener" title="P2471R3: user-generated static_assert messages">P2471R3: user-generated static_assert messages</a>.</p>





	</div><!-- .entry-content -->

	</article></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Ford Patents In-Car System That Eavesdrops So It Can Play You Ads (140 pts)]]></title>
            <link>https://www.motortrend.com/news/ford-in-vehicle-advertising-patent/</link>
            <guid>41471417</guid>
            <pubDate>Sat, 07 Sep 2024 04:21:22 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://www.motortrend.com/news/ford-in-vehicle-advertising-patent/">https://www.motortrend.com/news/ford-in-vehicle-advertising-patent/</a>, See on <a href="https://news.ycombinator.com/item?id=41471417">Hacker News</a></p>
Couldn't get https://www.motortrend.com/news/ford-in-vehicle-advertising-patent/: Error: Request failed with status code 403]]></description>
        </item>
        <item>
            <title><![CDATA[QtCS2024: Compile once, Run everywhere (135 pts)]]></title>
            <link>https://wiki.qt.io/QtCS2024_Compile_once._Run_everywhere</link>
            <guid>41470571</guid>
            <pubDate>Fri, 06 Sep 2024 23:55:12 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://wiki.qt.io/QtCS2024_Compile_once._Run_everywhere">https://wiki.qt.io/QtCS2024_Compile_once._Run_everywhere</a>, See on <a href="https://news.ycombinator.com/item?id=41470571">Hacker News</a></p>
<div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><h2><span id="Session_Summary">Session Summary</span></h2>
<p>Compiling and deploying of C++ applications on Windows, Linux, macOS for x86_64 and arm64 can be challenging. By using <i><a rel="nofollow" href="https://justine.lol/cosmopolitan/">Cosmopolitan Libc</a></i> we could have an alternative.
</p><p>Slides at <a rel="nofollow" href="https://git.qt.io/cradam/presentations/-/raw/main/2024.09.06/QtCS2024-CompileOnce-RunEverywhere.pdf?ref_type=heads">2024.09.06/QtCS2024-CompileOnce-RunEverywhere.pdf · GitLab</a>
</p>
<h2><span id="Session_Owners">Session Owners</span></h2>
<p>Cristian Adam
</p>
<h2><span id="Notes_.28AI_transcribed.29"></span><span id="Notes_(AI_transcribed)">Notes (AI transcribed)</span></h2>
<p>Cristian Adam, a member of the Qt Creator team, presented a talk on "Compile Once, Run Everywhere" using Cosmopolitan libc for C++ applications. 
</p><p>Key points include:
</p>
<ul><li>Qt Creator is currently compiled for multiple platforms (X64 and ARM64 for MacOS, separate packages for Linux, Windows ARM64 in progress) using the Qt installer framework.</li>
<li>Cosmopolitan libc is a C runtime that detects the host machine at runtime and provides the right system calls, enabling "compile once, run everywhere" for C++ applications.</li>
<li>Cosmopolitan applications are compiled twice (X64 and ARM64) and packaged as a batch script plus payload, similar to Linux run installers.</li>
<li>Mozilla's llamafile is an example of a Cosmopolitan application that runs locally after downloading and adding execute permissions.</li>
<li>Adam successfully built and ran CMake, Qt Base, and Qt GUI with VNC QPA using Cosmopolitan libc on MacOS and Linux, but encountered issues on Windows due to Cosmopolitan's Libc's POSIX implementation.</li>
<li>Challenges include integrating with native platforms, launching applications, and supporting WebSockets for Qt QPA VNC platform.</li>
<li>Adam demonstrated Qt Creator running in Cosmopolitan, with menus working but window borders missing.</li>
<li>The size of the Cosmopolitan Qt Creator binary is around 230 megabytes, and there were no noteworthy performance differences compared to the native version.</li>
<li>Adam plans to continue working on Cosmopolitan support for Qt Creator and encourages others to contribute and report issues.</li></ul>
<!-- 
NewPP limit report
Cached time: 20240906120349
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.002 seconds
Real time usage: 0.003 seconds
Preprocessor visited node count: 8/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key heroku_app_db:pcache:idhash:10820-0!canonical and timestamp 20240906120352 and revision id 42513.
 -->
</div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Hardware Acceleration of LLMs: A comprehensive survey and comparison (229 pts)]]></title>
            <link>https://arxiv.org/abs/2409.03384</link>
            <guid>41470074</guid>
            <pubDate>Fri, 06 Sep 2024 22:09:14 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://arxiv.org/abs/2409.03384">https://arxiv.org/abs/2409.03384</a>, See on <a href="https://news.ycombinator.com/item?id=41470074">Hacker News</a></p>
<div id="readability-page-1" class="page"><div id="content-inner">
    
    
                
    <p><a href="https://arxiv.org/pdf/2409.03384">View PDF</a>
    <a href="https://arxiv.org/html/2409.03384v1">HTML (experimental)</a></p><blockquote>
            <span>Abstract:</span>Large Language Models (LLMs) have emerged as powerful tools for natural language processing tasks, revolutionizing the field with their ability to understand and generate human-like text. In this paper, we present a comprehensive survey of the several research efforts that have been presented for the acceleration of transformer networks for Large Language Models using hardware accelerators.
<br>The survey presents the frameworks that have been proposed and then performs a qualitative and quantitative comparison regarding the technology, the processing platform (FPGA, ASIC, In-Memory, GPU), the speedup, the energy efficiency, the performance (GOPs), and the energy efficiency (GOPs/W) of each framework. The main challenge in comparison is that every proposed scheme is implemented on a different process technology making hard a fair comparison. The main contribution of this paper is that we extrapolate the results of the performance and the energy efficiency on the same technology to make a fair comparison; one theoretical and one more practical. We implement part of the LLMs on several FPGA chips to extrapolate the results to the same process technology and then we make a fair comparison of the performance.
    </blockquote>

    <!--CONTEXT-->
    
  </div><div>
      <h2>Submission history</h2><p> From: Christoforos Kachris [<a href="https://arxiv.org/show-email/95ee12c7/2409.03384">view email</a>]      <br>    <strong>[v1]</strong>
        Thu, 5 Sep 2024 09:43:25 UTC (1,209 KB)<br>
</p></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Godot founders had desperately hoped Unity wouldn't 'blow up' (150 pts)]]></title>
            <link>https://www.gamedeveloper.com/programming/godot-founders-had-desperately-hoped-unity-wouldn-t-blow-up-</link>
            <guid>41468667</guid>
            <pubDate>Fri, 06 Sep 2024 18:41:06 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://www.gamedeveloper.com/programming/godot-founders-had-desperately-hoped-unity-wouldn-t-blow-up-">https://www.gamedeveloper.com/programming/godot-founders-had-desperately-hoped-unity-wouldn-t-blow-up-</a>, See on <a href="https://news.ycombinator.com/item?id=41468667">Hacker News</a></p>
Couldn't get https://www.gamedeveloper.com/programming/godot-founders-had-desperately-hoped-unity-wouldn-t-blow-up-: Error: timeout of 10000ms exceeded]]></description>
        </item>
        <item>
            <title><![CDATA[HNInternal: Show HN: Infinity – Realistic AI characters that can speak (398 pts)]]></title>
            <link>https://news.ycombinator.com/item?id=41467704</link>
            <guid>41467704</guid>
            <pubDate>Fri, 06 Sep 2024 16:47:04 GMT</pubDate>
            <description><![CDATA[<p>See on <a href="https://news.ycombinator.com/item?id=41467704">Hacker News</a></p>
Couldn't get https://news.ycombinator.com/item?id=41467704: Error: timeout of 10000ms exceeded]]></description>
        </item>
    </channel>
</rss>