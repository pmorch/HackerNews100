<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>HN100 - Readable Contents</title>
        <link>https://hn.algolia.com/api/v1/search_by_date?tags=%28story,poll%29&amp;numericFilters=points%3E100</link>
        <description>Uses Readability to add bodies to the RSS feed</description>
        <lastBuildDate>Wed, 17 Dec 2025 18:30:02 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[AWS CEO says replacing junior devs with AI is 'one of the dumbest ideas' (208 pts)]]></title>
            <link>https://www.finalroundai.com/blog/aws-ceo-ai-cannot-replace-junior-developers</link>
            <guid>46302267</guid>
            <pubDate>Wed, 17 Dec 2025 17:08:35 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://www.finalroundai.com/blog/aws-ceo-ai-cannot-replace-junior-developers">https://www.finalroundai.com/blog/aws-ceo-ai-cannot-replace-junior-developers</a>, See on <a href="https://news.ycombinator.com/item?id=46302267">Hacker News</a></p>
<div id="readability-page-1" class="page"><div cta-rich-text="" fs-toc-element="contents" fs-toc-offsettop="1.5rem"><figure><p><img src="https://cdn.prod.website-files.com/6660a5bfdcf6c5fbf039f446/69428e2d7c764c046536a548_AWS%20CEO%20Junior%20Developers%20AI.jpg" loading="lazy" alt="AWS CEO Junior Developers AI"></p></figure><p>‍</p><p><strong>AWS CEO Matt Garman outlined 3 solid reasons why companies should not focus on cutting junior developer roles, noting that they “<em>are actually the most experienced with the AI tools</em>”.</strong></p><h2><strong>3 Reasons AI Should Not Replace Junior Developers</strong></h2><p>In a tech world obsessed with AI replacing human workers, Matt Garman, CEO of Amazon Web Services (AWS), is pushing back against one of the industry’s most popular cost-cutting ideas.</p><p>Speaking on <a href="https://www.wired.com/story/the-big-interview-podcast-matt-garman-ceo-aws/" target="_blank" rel="nofollow"><em>WIRED’s The Big Interview</em> podcast</a>, Garman has a bold message for companies racing to cut costs with AI.</p><p>‍</p><figure><p><img src="https://cdn.prod.website-files.com/6660a5bfdcf6c5fbf039f446/69428e63cef065d3e9f62638_Matt%20Garman%20on%20Junior%20Developers.jpg" loading="lazy" alt="Matt Garman on Junior Developers"></p></figure><p>‍</p><p>He was asked to explain why he once called replacing junior employees with AI “<a href="https://www.finalroundai.com/blog/aws-ceo-matt-garman-says-replacing-junior-developers-with-ai-the-dumbest-thing"><em>one of the dumbest ideas</em></a>” he’d ever heard, and to expand on how he believes agentic AI will actually change the workplace in the coming years.</p><h3><strong>1) Junior Devs Often Know AI Tools Better</strong></h3><p><strong>First, junior employees are often better with AI tools than senior staff.</strong>&nbsp;</p><blockquote><em>“Number one, my experience is that many of the most junior folks are actually the most experienced with the AI tools. So they're actually most able to get the most out of them.”</em></blockquote><p>‍</p><p>Fresh grads have grown up with new technology, so they can adapt quickly. Many of them learn AI-powered tools while studying or during internships. They tend to explore new features, find quick methods to write code, and figure out how to get the best results from AI agents.&nbsp;</p><p>According to the <a href="https://survey.stackoverflow.co/2025/ai?utm_source=chatgpt.com#sentiment-and-usage-ai-sel-prof-exp" target="_blank" rel="nofollow">2025 Stack Overflow Developer Survey</a>, 55.5% of early-career developers reported using AI tools daily in their development process, higher than for the experienced folks.</p><p>This comfort with new tools allows them to work more efficiently. In contrast, senior developers have established workflows and may take more time to adopt. <a href="https://www.peoplemanagement.co.uk/article/1930418/half-gen-z-help-senior-colleagues-upskill-ai-study-finds" target="_blank" rel="nofollow">Recent research</a> shows that over half of Gen Z employees are actually helping senior colleagues upskill in AI.</p><h3><strong>2) Junior Developers Shouldn’t Be The Default Cost-Saving Move</strong></h3><p><strong>Second, junior staff are usually the least expensive employees.</strong></p><blockquote><em>“Number two, they're usually the least expensive because they're right out of college, and they generally make less. So if you're thinking about cost optimization, they're not the only people you would want to optimize around.”</em></blockquote><p>‍</p><p>Junior employees usually get much less in salary and benefits, so removing them does not deliver huge savings. If a company is trying to save money, it doesn’t make that much financial sense.&nbsp;</p><p>So, when companies talk about increasing profit margins, junior employees should not be the default or only target. True optimization, Real cost-cutting means looking at the whole company because there are plenty of other places where expenses can be trimmed.</p><p>In fact, 30% of companies that laid off workers expecting savings <a href="https://myabcm.com/layoffs-the-cost-cutting-measure-that-could-sink-your-company" target="_blank" rel="nofollow">ended up increasing expenses</a>, and many had to rehire later.&nbsp;</p><h3><strong>3) Removing Juniors Breaks the Talent Pipeline</strong></h3><p><strong>Third, companies need fresh talent.</strong></p><blockquote><em>“Three, at some point, that whole thing explodes on itself. If you have no talent pipeline that you're building and no junior people that you're mentoring and bringing up through the company, we often find that that's where we get some of the best ideas.”</em></blockquote><p>‍</p><p>Think of a company like a sports team. If you only keep veteran players and never recruit rookies, what happens when those veterans retire? You are left with no one who knows how to play the game.</p><p>Also, hiring people straight out of college brings new ways of thinking into the workplace. They have fresh ideas shaped by the latest trends, motivation to innovate.&nbsp;</p><p>More importantly, they form the foundation of a company’s future workforce. If a company decides to stop hiring junior employees altogether, it cuts off its own talent pipeline. Over time, that leads to fewer leaders to promote from within.</p><p>A <a href="https://www.deloitte.com/us/en/insights/topics/talent/overcoming-the-tech-talent-shortage-amid-transformation.html" target="_blank" rel="nofollow">Deloitte report</a> also notes that the tech workforce is expected to grow at roughly twice the rate of the overall U.S. workforce, highlighting the demand for tech talent. Without a strong pipeline of junior developers coming in, companies might face a tech talent shortage.&nbsp;</p><p>When there are not enough junior hires being trained today, teams struggle to fill roles tomorrow, especially as projects scale.</p><h2><strong>Bottom Line</strong></h2><p>This isn’t just corporate talk. As the leader of one of the world’s largest cloud computing platforms, serving everyone from Netflix to the U.S. intelligence agencies, Garman has a front-row seat to how companies are actually using AI.&nbsp;</p><p>And what he is seeing makes him worried that short-term thinking could damage businesses for years to come. Garman’s point is grounded in long-term strategy. A company that relies solely on AI to handle tasks without training new talent could find itself short of people.</p><p>Still, Garman admits the next few years will be bumpy. “Y<em>our job is going to change</em>,” he said. He believes AI will make companies more productive as well as the employees.&nbsp;</p><p>When technology makes something easier, people want more of it. AI enables the creation of software faster, allowing companies to develop more products, enter new markets, and serve more customers.</p><p>Developers will be responsible for more than just writing code, with faster adaptation to new technologies becoming essential. But he has a hopeful message in the end.</p><p>That’s why Geoffrey Hinton has advised that <a href="https://www.finalroundai.com/blog/ai-godfather-geoffrey-hinton-mid-level-coding-jobs">Computer Science degrees remain essential</a>. This directly supports Matt Garman’s point. Fresh talent with a strong understanding of core fundamentals becomes crucial for filling these higher-value roles of the future.</p><p>“<strong><em>I’m very confident in the medium to longer term that AI will definitely create more jobs than it removes at first,</em></strong>” Garman said.</p></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[HNInternal: Tell HN: HN Was Down (221 pts)]]></title>
            <link>https://news.ycombinator.com/item?id=46301921</link>
            <guid>46301921</guid>
            <pubDate>Wed, 17 Dec 2025 16:48:18 GMT</pubDate>
            <description><![CDATA[<p>See on <a href="https://news.ycombinator.com/item?id=46301921">Hacker News</a></p>
<div id="readability-page-1" class="page"><div><tbody><tr id="46302176"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46302176" href="https://news.ycombinator.com/vote?id=46302176&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Is this still a valid account for HN status? It says it’s the official one, but with the changes at Twitter to no longer show chronological feeds (at least for users that aren’t logged in), it’s rather useless. The top 5 listed post (for me) are seemingly random from 2014 - 2022.</p><p><a href="https://x.com/HNStatus" rel="nofollow">https://x.com/HNStatus</a></p><p>Is there a better place to check, beyond a basic down detector that may provide more insight or signal that the outage is acknowledged?</p></div></td></tr></tbody></table></td></tr><tr id="46302580"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302580" href="https://news.ycombinator.com/vote?id=46302580&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Only way I have figured out how to to change the "Following" sort order back to chronoligical is from the mobile app: click the down arrow on the "Following" tab. Change the sort from "popular" to "most recent."</p><p>Seems to reset it on the web view, too.</p></div></td></tr></tbody></table></td></tr><tr id="46302222"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302222" href="https://news.ycombinator.com/vote?id=46302222&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p><a href="https://hn.hund.io/" rel="nofollow">https://hn.hund.io/</a> Is a status page, no idea if official or not, but it didn't register here for some reason.</p><p>I didn't read the post text, it's identified there haha, my bad! I wish the text post text wasn't grey, I gloss over it too easily.</p></div></td></tr></tbody></table></td></tr><tr id="46302334"><td></td></tr><tr id="46301962"><td></td></tr><tr id="46302563"><td></td></tr><tr id="46302487"><td></td></tr><tr id="46302271"><td></td></tr><tr id="46302115"><td></td></tr><tr id="46302517"><td></td></tr><tr id="46302398"><td></td></tr><tr id="46302143"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302143" href="https://news.ycombinator.com/vote?id=46302143&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>It just reinforces for me that addiction is a human problem not a problem with technology</p><p>I know dang basically works 
tirelessly to not change the format in order to not induce those addictive patterns</p><p>but yet here we all are</p></div></td></tr></tbody></table></td></tr><tr id="46302199"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_46302199" href="https://news.ycombinator.com/vote?id=46302199&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>It's a website with the smartest people in the world. The level of conversations here are unrivaled in internet communities.</p><p>It's understandable to be addicted. Lol.</p><p>I visit this place multiple times a day.</p></div></td></tr></tbody></table></td></tr><tr id="46302506"><td></td></tr><tr id="46302607"><td><table><tbody><tr><td indent="4"><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_46302607" href="https://news.ycombinator.com/vote?id=46302607&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Now now, HN does have its unusually high share of "Very Stable Geniuses" and "High I.Q. Individuals", we have to acknowledge that.</p></div></td></tr></tbody></table></td></tr><tr id="46302285"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_46302285" href="https://news.ycombinator.com/vote?id=46302285&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>It's really not 'the smartest people.' It's people interested in tech, and often in making-a-lot-of-money-in-tech. It does have a lot of people with significant industry experience, which is cool.</p></div></td></tr></tbody></table></td></tr><tr id="46302523"><td><table><tbody><tr><td indent="4"><img src="https://news.ycombinator.com/s.gif" height="1" width="160"></td><td><center><a id="up_46302523" href="https://news.ycombinator.com/vote?id=46302523&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>&gt; It's really not 'the smartest people.'</p><p>This was especially obvious during Covid, I even stopped visiting because the comment section was so crazy.</p></div></td></tr></tbody></table></td></tr><tr id="46302395"><td></td></tr><tr id="46302359"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_46302359" href="https://news.ycombinator.com/vote?id=46302359&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>This one is at least healthy-ish for the mind. I’d much rather hacker news than any other news. Social Media is an emotional rage-bait cesspool these days. If it’s not for Hacker News those of us who abstain from the rest would be living in the dark.</p></div></td></tr></tbody></table></td></tr><tr id="46302049"><td></td></tr><tr id="46302283"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46302283" href="https://news.ycombinator.com/vote?id=46302283&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>I got stuck in an infinite loop.</p><p>Try opening HN -&gt; it's down, better check HN to see everyone talking about a major website being down -&gt; Try opening HN -&gt; loop</p></div></td></tr></tbody></table></td></tr><tr id="46302389"><td></td></tr><tr id="46302451"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302451" href="https://news.ycombinator.com/vote?id=46302451&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>I always hated the late use-it-or-loose-it at the end of the year where you end up buying the things that were denied requests from earlier in the year. You just cost me half a year of using the damn thing.</p></div></td></tr></tbody></table></td></tr><tr id="46302566"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46302566" href="https://news.ycombinator.com/vote?id=46302566&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>In other words, productivity in tech skyrocketed for hours..though it seems some work was flavoured with irrational anger.</p></div></td></tr></tbody></table></td></tr><tr id="46302482"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46302482" href="https://news.ycombinator.com/vote?id=46302482&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>I was able to view the site without being signed in (i.e. private window) but any browser I was logged into wouldn't load.</p><p>I'm sure it's a coincidence but it started working again shortly after emailing hn@ycombinator.com</p></div></td></tr></tbody></table></td></tr><tr id="46302039"><td></td></tr><tr id="46302192"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302192" href="https://news.ycombinator.com/vote?id=46302192&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Next time you can avoid that fate by opening HN in a private browsing (or whatever your browser calls its equivalent) window. This outage, like the vast majority of HN outages, only affected logged in requests.</p><p>I suppose you could also just clear your HN cookies in regular browsing window, but then when they fix it you'd have to log in again.</p></div></td></tr></tbody></table></td></tr><tr id="46302179"><td></td></tr><tr id="46301960"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46301960" href="https://news.ycombinator.com/vote?id=46301960&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Yeah I couldn't log in for a bit this morning. It's concerning how often and how many times I tried. Glad it's resolved.</p></div></td></tr></tbody></table></td></tr><tr id="46302136"><td></td></tr><tr id="46302187"><td></td></tr><tr id="46302174"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46302174" href="https://news.ycombinator.com/vote?id=46302174&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>A lot of the outage indicators failed. Someone needs to create an outage indicator reliability dashboard.</p></div></td></tr></tbody></table></td></tr><tr id="46302206"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302206" href="https://news.ycombinator.com/vote?id=46302206&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>A lot of them got fooled by the caching; pages for signed-out users are cached heavily and those kept returning successful responses even if the actual backend server was down.</p></div></td></tr></tbody></table></td></tr><tr id="46302340"><td></td></tr><tr id="46302394"><td></td></tr><tr id="46302215"><td></td></tr><tr id="46302240"><td></td></tr><tr id="46302062"><td></td></tr><tr id="46302200"><td></td></tr><tr id="46302160"><td></td></tr><tr id="46302175"><td></td></tr><tr id="46302171"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46302171" href="https://news.ycombinator.com/vote?id=46302171&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>It was the first time since I started using this website (August last year) that it was down.</p><p>I'm still impressed nonetheless.</p><p>I'd like to know what caused the outage and how it could have been prevented, for learning purposes.</p></div></td></tr></tbody></table></td></tr><tr id="46302214"><td></td></tr><tr id="46302315"><td></td></tr><tr id="46302069"><td></td></tr><tr id="46302166"><td></td></tr><tr id="46302157"><td></td></tr><tr id="46302209"><td></td></tr><tr id="46302322"><td><table><tbody><tr><td indent="3"><img src="https://news.ycombinator.com/s.gif" height="1" width="120"></td><td><center><a id="up_46302322" href="https://news.ycombinator.com/vote?id=46302322&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>&gt; how do you keep track of his comments?</p><p>You can just look at them, turn on showdead in your profile and you'll see a bunch of flag-killed comments in this discussion by whatevermrfukz. No need for a plugin or scraper.</p></div></td></tr></tbody></table></td></tr><tr id="46302404"><td></td></tr><tr id="46302421"><td></td></tr><tr id="46302335"><td></td></tr><tr id="46302510"><td></td></tr><tr id="46302347"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46302347" href="https://news.ycombinator.com/vote?id=46302347&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>I got confused by the "minutes ago" thing.</p><p>Working with full dates in the HTML and doing a tiny JavaScript that calculates the "minutes ago" would actually be a neat improvement.</p></div></td></tr></tbody></table></td></tr><tr id="46302241"><td></td></tr><tr id="46302609"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302609" href="https://news.ycombinator.com/vote?id=46302609&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>I thought I was being rate-limited for opening posts too fast, which has happened before.</p><p>After more than an hour I thought, "wow this is pretty harsh" and "so much of my exposure to learning things is directly tied to HN posts". I was lost lol.</p></div></td></tr></tbody></table></td></tr><tr id="46302107"><td></td></tr><tr id="46302104"><td></td></tr><tr id="46302112"><td></td></tr><tr id="46302195"><td></td></tr><tr id="46302248"><td></td></tr><tr id="46302083"><td><table><tbody><tr><td indent="0"><img src="https://news.ycombinator.com/s.gif" height="1" width="0"></td><td><center><a id="up_46302083" href="https://news.ycombinator.com/vote?id=46302083&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Just a month ago, I got downvoted to -2 for saying HN for being self-hosted hasn't shown up as more reliable than something behind Cloudflare. My point is made.</p><p>Edit: Now it happens again. Knee jerk defenses all the way down.</p></div></td></tr></tbody></table></td></tr><tr id="46302203"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302203" href="https://news.ycombinator.com/vote?id=46302203&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Unless the downtime was caused by something Cloudflare would've prevented, this downtime would've happened regardless of being behind Cloudflare. Cloudflare adds another single point of failure.</p></div></td></tr></tbody></table></td></tr><tr id="46302177"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302177" href="https://news.ycombinator.com/vote?id=46302177&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Could this be a self-inflicted bug? In that case, the broader point still stands: cloud providers can cause outages that are outside your direct realm of responsibility.</p></div></td></tr></tbody></table></td></tr><tr id="46302185"><td><table><tbody><tr><td indent="2"><img src="https://news.ycombinator.com/s.gif" height="1" width="80"></td><td><center><a id="up_46302185" href="https://news.ycombinator.com/vote?id=46302185&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>Your VPS server and your data center and the ISP your data center uses and the AS system your ISP uses all can cause outages outside your direct realm of responsibility.</p></div></td></tr></tbody></table></td></tr><tr id="46302300"><td></td></tr><tr id="46302198"><td><table><tbody><tr><td indent="1"><img src="https://news.ycombinator.com/s.gif" height="1" width="40"></td><td><center><a id="up_46302198" href="https://news.ycombinator.com/vote?id=46302198&amp;how=up&amp;goto=item%3Fid%3D46301921"></a></center></td><td><br>
<div><p>It's absolutely irresistible downvoting people who preemptively complain about being downvoted like you do. It really made my day. Post another complaint so I can do it again please! It's not knee jerk when you explicitly ask for it, by leading with a complaint about downvoting, instead of just making your point and letting it fall or rise on its own merits. You're the one who put the idea of downvoting you into my head in the first place.</p></div></td></tr></tbody></table></td></tr></tbody></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Gemini 3 Flash: frontier intelligence built for speed (306 pts)]]></title>
            <link>https://blog.google/products/gemini/gemini-3-flash/</link>
            <guid>46301851</guid>
            <pubDate>Wed, 17 Dec 2025 16:42:13 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://blog.google/products/gemini/gemini-3-flash/">https://blog.google/products/gemini/gemini-3-flash/</a>, See on <a href="https://news.ycombinator.com/item?id=46301851">Hacker News</a></p>
<div id="readability-page-1" class="page"><article>

    
    





    

    
      








<div data-analytics-module="{
    &quot;module_name&quot;: &quot;Hero Menu&quot;,
    &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
  }">
  
  <div>
      
      
        <p>
          Gemini 3 Flash is our latest model with frontier intelligence built for speed that helps everyone learn, build, and plan anything — faster.
        </p>
      
    </div>
  
  <div data-component="uni-ai-generated-summary" data-analytics-module="{
    &quot;event&quot;: &quot;module_impression&quot;,
    &quot;module_name&quot;: &quot;ai_summary&quot;,
    &quot;section_header&quot;: &quot;CTA&quot;
  }">
      
        <div data-summary-id="ai_summary_1">
          <h2>General summary</h2>
          <p>Google is releasing Gemini 3 Flash, a fast and cost-effective model built for speed. You can now access Gemini 3 Flash through the Gemini app and AI Mode in Search. Developers can access it via the Gemini API in Google AI Studio, Google Antigravity, Gemini CLI, Android Studio, Vertex AI and Gemini Enterprise.</p>
          
          <p><small>
            Summaries were generated by Google AI. Generative AI is experimental.
          </small>
        </p></div>
      
        <div data-summary-id="ai_summary_2">
          <h2>Bullet points</h2>
          <ul>
<li>"Gemini 3 Flash: frontier intelligence built for speed" introduces a fast, efficient AI model.</li>
<li>Gemini 3 Flash offers Pro-grade reasoning at Flash-level speed and a lower cost.</li>
<li>It's great for coding, complex analysis, and quick answers in interactive apps.</li>
<li>Gemini 3 Flash is now the default model in the Gemini app and AI Mode in Search.</li>
<li>Developers and everyday users can access Gemini 3 Flash via various Google platforms.</li>
</ul>
          
          <p><small>
            Summaries were generated by Google AI. Generative AI is experimental.
          </small>
        </p></div>
      

      
      <div>
        <h4>
          Explore other styles:
        </h4>
        
      </div>
      

      </div>
</div>

    

    
      










<div>
    <figure>
      <div>
        <p><img alt="Gemini 3 Flash text" data-component="uni-progressive-image" fetchpriority="high" height="150px" src="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3_flash_model_blog_header_.width-200.format-webp.webp" width="360px" data-sizes="(max-width: 1023px) 100vw,(min-width: 1024px and max-width: 1259) 80vw, 1046px" data-srcset="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3_flash_model_blog_header_.width-800.format-webp.webp 800w, https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3_flash_model_blog_header.width-1200.format-webp.webp 1200w, https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3_flash_model_blog_header.width-1600.format-webp.webp 1600w, https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3_flash_model_blog_header.width-2200.format-webp.webp 2200w">
        </p>
      </div>
      
    </figure>
  </div>






    

    
    <div data-reading-time="true" data-component="uni-article-body">

            
  
    



















<div data-component="uni-audio-player-tts" uni-l10n="{
       &quot;stop&quot;: &quot;Click to stop audio&quot;,
       &quot;play&quot;: &quot;Click to play audio&quot;,
       &quot;progress&quot;: &quot;Current audio progress minutes with seconds: [[progress]]&quot;,
       &quot;duration&quot;: &quot;Duration of the audio minutes with seconds: [[duration]]&quot;,
       &quot;settings&quot;: &quot;Click for settings&quot;,
       &quot;timeText&quot;: &quot;[[duration]] minutes&quot;
     }" data-analytics-module="{
      &quot;module_name&quot;: &quot;Audio TTS&quot;,
      &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
     }" data-tts-audios="[
      
        {&quot;voice_name&quot;: &quot;Gacrux&quot;,
        &quot;voice_source&quot;: &quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/media/tts_audio_82955_gacrux_2025_12_17_16_29_26.wav&quot;,
        &quot;mimetype&quot;: &quot;audio/x-wav&quot;},
      
        {&quot;voice_name&quot;: &quot;Umbriel&quot;,
        &quot;voice_source&quot;: &quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/media/tts_audio_82955_umbriel_2025_12_17_16_31_33.wav&quot;,
        &quot;mimetype&quot;: &quot;audio/x-wav&quot;}
      ]">
  <p><audio title="Gemini 3 Flash: frontier intelligence built for speed">
      <source src="https://blog.google/products/gemini/gemini-3-flash/self.ttsaudio_set.first.tts_audio.url" type="self.ttsaudio_set.first.tts_audio.file.file.mime_type">
      <p>Your browser does not support the audio element.</p>
  </audio></p><div aria-label="">
        <p><span>
          Listen to article
          <span tabindex="0" role="tooltip" aria-label="This content is generated by Google AI. Generative AI is experimental">
            <p>This content is generated by Google AI. Generative AI is experimental</p>
            <svg>
  <use xmlns:xlink="http://www.w3.org/1999/xlink" href="/static/blogv2/images/icons.svg?version=pr20251215-1743#ttf-info"></use>
</svg>

          </span>
        </span></p><p>[[duration]] minutes</p>
      </div>
</div>

  





            
            
<!--article text-->

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }"><p data-block-key="qapzx">Today, we're expanding the Gemini 3 model family with the release of Gemini 3 Flash, which offers frontier intelligence built for speed at a fraction of the cost. With this release, we’re making Gemini 3’s next-generation intelligence accessible to everyone across Google products.</p><p data-block-key="b4nrq">Last month, we kicked off Gemini 3 with <a href="https://blog.google/products/gemini/gemini-3/#note-from-ceo">Gemini 3 Pro</a> and <a href="https://blog.google/products/gemini/gemini-3-deep-think/">Gemini 3 Deep Think</a> mode, and the response has been incredible. Since launch day, we have been processing over 1T tokens per day on our API. We’ve seen you use Gemini 3 to <a href="https://x.com/googleaidevs/status/1991333601959350306">vibe code simulations</a> to learn about complex topics, build and design <a href="https://x.com/googleaidevs/status/1991318283065131160">interactive games</a> and understand all types of <a href="https://x.com/googleaidevs/status/1997033279610818745?s=20">multimodal content</a>.</p><p data-block-key="3c1p3">With Gemini 3, we introduced frontier performance across complex reasoning, <a href="https://blog.google/technology/developers/gemini-3-pro-vision/">multimodal and vision understanding</a> and agentic and vibe coding tasks. Gemini 3 Flash retains this foundation, combining Gemini 3's Pro-grade reasoning with Flash-level latency, efficiency and cost. It not only enables everyday tasks with improved reasoning, but also is our most impressive model for agentic workflows.</p><p data-block-key="347o3">Starting today, Gemini 3 Flash is rolling out to millions of people globally:</p><ul><li data-block-key="4suea">For developers in the Gemini API in <a href="https://blog.google/technology/developers/build-with-gemini-3-flash">Google AI Studio</a>, <a href="https://developers.googleblog.com/gemini-3-flash-is-now-available-in-gemini-cli/">Gemini CLI</a> and our new agentic development platform <a href="https://antigravity.google/blog/gemini-3-flash-in-google-antigravity">Google Antigravity</a></li><li data-block-key="72mi8">For everyone via the <a href="https://blog.google/products/gemini/gemini-3-flash-gemini-app/">Gemini app</a> and in <a href="https://blog.google/products/search/google-ai-mode-update-gemini-3-flash">AI Mode in Search</a></li><li data-block-key="7upf8">For enterprises in <a href="https://cloud.google.com/blog/products/ai-machine-learning/gemini-3-flash-for-enterprises">Vertex AI and Gemini Enterprise</a></li></ul></div>
  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }"><h2 data-block-key="qapzx">Gemini 3 Flash: frontier intelligence at scale</h2><p data-block-key="b8etv">Gemini 3 Flash demonstrates that speed and scale don’t have to come at the cost of intelligence. It delivers frontier performance on PhD-level reasoning and knowledge benchmarks like GPQA Diamond (90.4%) and Humanity’s Last Exam (33.7% without tools), rivaling larger frontier models, and significantly outperforming even the best 2.5 model, Gemini 2.5 Pro, across a number of benchmarks. It also reaches state-of-the-art performance with an impressive score of 81.2% on MMMU Pro, comparable to Gemini 3 Pro.</p></div>
  

  
    














<uni-image-full-width alignment="full" alt-text="A benchmark comparison table showing performance scores and prices for several language models including Gemini 3 Flash, Gemini 3 Pro Thinking, Gemini 2.5 Flash Thinking, Gemini 2.5 Pro Thinking, Claude Sonnet 4.5, GPT-5.2 Extra high, and Grok 4.1 Fast, across various tasks like academic reasoning, scientific knowledge, math, multi-modal understanding, coding, and long context performance." external-image="" or-mp4-video-title="" or-mp4-video-url="" section-header="Gemini 3 Flash: frontier intelligence built for speed" external-link="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3-flash_final_benchmark-table_light_25-1.original.png" custom-class="image-full-width--constrained-width uni-component-spacing">
  
  
    <p><img alt="A benchmark comparison table showing performance scores and prices for several language models including Gemini 3 Flash, Gemini 3 Pro Thinking, Gemini 2.5 Flash Thinking, Gemini 2.5 Pro Thinking, Claude Sonnet 4.5, GPT-5.2 Extra high, and Grok 4.1 Fast, across various tasks like academic reasoning, scientific knowledge, math, multi-modal understanding, coding, and long context performance." src="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3-flash_final_benchmark-ta.width-100.format-webp.webp" loading="lazy" data-loading="{
            &quot;mobile&quot;: &quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3-flash_final_benchmark-ta.width-500.format-webp.webp&quot;,
            &quot;desktop&quot;: &quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3-flash_final_benchmark-t.width-1000.format-webp.webp&quot;
          }">
    </p>
  
</uni-image-full-width>


  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }">
        <p data-block-key="qapzx">In addition to its frontier-level reasoning and multimodal capabilities, Gemini 3 Flash was built to be highly efficient, pushing the Pareto frontier of quality vs. cost and speed. When processing at the highest thinking level, Gemini 3 Flash is able to modulate how much it thinks. It may think longer for more complex use cases, but it also uses 30% fewer tokens on average than 2.5 Pro, as measured on typical traffic, to accurately complete everyday tasks with higher performance.</p>
      </div>
  

  
    














<uni-image-full-width alignment="full" alt-text="A scatter plot showing LMArena Elo Score versus Price per million tokens for various language models, with a line highlighting the Pareto frontier through 'gemini-3-pro', 'gemini-3-flash', and 'gemini-3-flash-lite'." external-image="" or-mp4-video-title="" or-mp4-video-url="" section-header="Gemini 3 Flash: frontier intelligence built for speed" external-link="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3-flash_pareto_graph_dec17_1_DF5Txhz.original.png" custom-class="image-full-width--constrained-width uni-component-spacing">
  
    <div slot="caption-slot">
      <p data-block-key="90v27">Gemini 3 Flash pushes the Pareto frontier on performance vs. cost and speed.</p>
    </div>
  
  
    <p><img alt="A scatter plot showing LMArena Elo Score versus Price per million tokens for various language models, with a line highlighting the Pareto frontier through 'gemini-3-pro', 'gemini-3-flash', and 'gemini-3-flash-lite'." src="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3-flash_pareto_graph_dec17.width-100.format-webp.webp" loading="lazy" data-loading="{
            &quot;mobile&quot;: &quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3-flash_pareto_graph_dec17.width-500.format-webp.webp&quot;,
            &quot;desktop&quot;: &quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3-flash_pareto_graph_dec1.width-1000.format-webp.webp&quot;
          }">
    </p>
  
</uni-image-full-width>


  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }">
        <p data-block-key="yrydl">Gemini 3 Flash’s strength lies in its raw speed, building on the Flash series that developers and consumers already love. It outperforms 2.5 Pro while being 3x faster (based on <a href="https://artificialanalysis.ai/models/gemini-3-flash-reasoning">Artificial Analysis</a> benchmarking) at a fraction of the cost. Gemini 3 Flash is priced at $0.50/1M input tokens and $3/1M output tokens (audio input remains at $1/1M input tokens).</p>
      </div>
  

  
    














<uni-image-full-width alignment="full" alt-text="Dynamic thinking in Gemini 3 Flash demo" external-image="" or-mp4-video-title="Gemini 3 Flash Action Replay" or-mp4-video-url="https://storage.googleapis.com/gweb-uniblog-publish-prod/original_videos/Keyword_ACTION_REPLAY_V10_1.mp4" section-header="Gemini 3 Flash: frontier intelligence built for speed" custom-class="image-full-width--constrained-width uni-component-spacing">
  
    
  
  
</uni-image-full-width>


  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }"><h2 data-block-key="qapzx">For developers: intelligence that keeps up</h2><p data-block-key="8tjig">Gemini 3 Flash is made for iterative development, offering Gemini 3’s Pro-grade coding performance with low latency — it’s able to reason and solve tasks quickly in high-frequency workflows. On SWE-bench Verified, a benchmark for evaluating coding agent capabilities, Gemini 3 Flash achieves a score of 78%, outperforming not only the 2.5 series, but also Gemini 3 Pro. It strikes an ideal balance for agentic coding, production-ready systems and responsive interactive applications.</p></div>
  

  
    
  
    




  <uni-youtube-player-article index="9" thumbnail-alt="Demo of Gemini 3 Flash for developers" subtitle="Gemini 3 Flash in Google Antigravity works quickly to update production-ready applications." video-id="MPkgMSWQMSU" video-type="video">
  </uni-youtube-player-article>











  


  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }">
        <p data-block-key="qapzx">Gemini 3 Flash’s strong performance in reasoning, tool use and multimodal capabilities is ideal for developers looking to do more complex video analysis, data extraction and visual Q&amp;A, which means it can enable more intelligent applications — like in-game assistants or A/B test experiments — that demand both quick answers and deep reasoning.</p>
      </div>
  

  
    

















<uni-image-carousel section-header="Gemini 3 Flash: frontier intelligence built for speed" images="[
    
      {
        
          &quot;src&quot;: [&quot; https://storage.googleapis.com/gweb-uniblog-publish-prod/original_videos/SlingShot_Thumbnail_vF.mp4 &quot;],
        
        &quot;alt&quot;: &quot;Gemini 3 Flash sling shot game demo&quot;,
        &quot;isVideo&quot;: true,
        &quot;videoTitle&quot;: &quot;Gemini 3 Flash Sling Shot&quot;
      },
    
      {
        
          &quot;src&quot;: [&quot; https://storage.googleapis.com/gweb-uniblog-publish-prod/original_videos/Gemini3Flash_SpinnerEvolve_short_noendcard.mp4 &quot;],
        
        &quot;alt&quot;: &quot;Gemini 3 Spinner Evolve demo&quot;,
        &quot;isVideo&quot;: true,
        &quot;videoTitle&quot;: &quot;Gemini 3 Flash Spinner Evolve&quot;
      },
    
      {
        
          &quot;src&quot;: [&quot; https://storage.googleapis.com/gweb-uniblog-publish-prod/original_videos/Disc_augmented_image_asset3_1.mp4 &quot;],
        
        &quot;alt&quot;: &quot;Gemini 3 Flash demo Cloud City&quot;,
        &quot;isVideo&quot;: true,
        &quot;videoTitle&quot;: &quot;cloud city updated&quot;
      },
    
      {
        
          &quot;src&quot;: [&quot; https://storage.googleapis.com/gweb-uniblog-publish-prod/original_videos/Gemini3flash_threeuniquevariations.mp4 &quot;],
        
        &quot;alt&quot;: &quot;Gemini 3 Flash demo showing design variations in UI&quot;,
        &quot;isVideo&quot;: true,
        &quot;videoTitle&quot;: &quot;Gemini 3 Flash three unique variations&quot;
      }
    
  ]">
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
</uni-image-carousel>

  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }">
        <p data-block-key="qapzx">We’ve received a tremendous response from companies using Gemini 3 Flash. Companies like JetBrains, Bridgewater Associates, and Figma are already using it to transform their businesses, recognizing how its inference speed, efficiency and reasoning capabilities perform on par with larger models. Gemini 3 Flash is available today to enterprises via Vertex AI and Gemini Enterprise.</p>
      </div>
  

  
    

















<uni-image-carousel section-header="Gemini 3 Flash: frontier intelligence built for speed" images="[
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-jetb.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-jetb.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;JetBrains customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-aia-.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-aia-.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Bridgewater customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-figm.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-figm.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Figma customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-curs.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-curs.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Cursor customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-warp.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-warp.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Warp customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-harv.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-harv.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Harvey customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-astr.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-astr.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Astrocade customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-pres.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-pres.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Presentations.ai customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-repl.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-repl.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Replit customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      },
    
      {
        
          
          
          &quot;src&quot;: [&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-lati.max-1080x1080.format-webp.webp&quot;,&quot;https://storage.googleapis.com/gweb-uniblog-publish-prod/images/gemini-3Flash_blog_quote-lati.max-1080x1080.format-webp.webp&quot;],
        
        &quot;alt&quot;: &quot;Latitude customer testimonial quote&quot;,
        &quot;isVideo&quot;: false,
        &quot;videoTitle&quot;: &quot;&quot;
      }
    
  ]">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</uni-image-carousel>

  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }"><h2 data-block-key="qapzx">For everyone: Gemini 3 Flash is rolling out globally</h2><p data-block-key="5hmpf">Gemini 3 Flash is now the default model in the Gemini app, replacing 2.5 Flash. That means all of our Gemini users globally will get access to the Gemini 3 experience at no cost, giving their everyday tasks a major upgrade.</p><p data-block-key="1f9e7">Because of Gemini 3 Flash’s incredible multimodal reasoning capabilities, you can use it to help you see, hear and understand any type of information faster. For example, you can ask Gemini to understand your videos and images and turn that content into a helpful and actionable plan in just a few seconds.</p></div>
  

  
    

















<uni-image-carousel section-header="Gemini 3 Flash: frontier intelligence built for speed" images="[
    
      {
        
          &quot;src&quot;: [&quot; https://storage.googleapis.com/gweb-uniblog-publish-prod/original_videos/Gem3_Golf_Demo_No_Audio_16x9.mp4 &quot;],
        
        &quot;alt&quot;: &quot;Gemini 3 golf swing demo video&quot;,
        &quot;isVideo&quot;: true,
        &quot;videoTitle&quot;: &quot;Gemini 3 golf demo&quot;
      },
    
      {
        
          &quot;src&quot;: [&quot; https://storage.googleapis.com/gweb-uniblog-publish-prod/original_videos/Pictionary_vFinal_Blog.mp4 &quot;],
        
        &quot;alt&quot;: &quot;Gemini 3 Flash Pictionary demo&quot;,
        &quot;isVideo&quot;: true,
        &quot;videoTitle&quot;: &quot;Gemini 3 Flash Pictionary&quot;
      },
    
      {
        
          &quot;src&quot;: [&quot; https://storage.googleapis.com/gweb-uniblog-publish-prod/original_videos/Gemini_Flash3.0_LearningDemo_16x9_JW_v6_NoAudio.mp4 &quot;],
        
        &quot;alt&quot;: &quot;Gemini 3 Flash learning demo&quot;,
        &quot;isVideo&quot;: true,
        &quot;videoTitle&quot;: &quot;Gemini 3 Flash learning demo&quot;
      }
    
  ]">
  
    
      
    
  
    
      
    
  
    
      
    
  
</uni-image-carousel>

  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }">
        <p data-block-key="qapzx">Or you can quickly build fun, useful apps from scratch using your voice without prior coding knowledge. Just dictate to Gemini on the go, and it can transform your unstructured thoughts into a functioning app in minutes.</p>
      </div>
  

  
    
  
    




  <uni-youtube-player-article index="17" thumbnail-alt="Food prototype using Gemini 3 Flash" subtitle="Describe an idea using Gemini 3 Flash and turn it into a working prototype in minutes." video-id="8IYYMRdz2h4" video-type="video" image="Gemini3_Flash_Food_Thumbnail" video-image-url-lazy="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/Gemini3_Flash_Food_Thumbnail.width-100.format-webp.webp" video-image-url-mobile="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/Gemini3_Flash_Food_Thumbnail.width-700.format-webp.webp" video-image-url-desktop="https://storage.googleapis.com/gweb-uniblog-publish-prod/images/Gemini3_Flash_Food_Thumbnail.width-1000.format-webp.webp">
  </uni-youtube-player-article>











  


  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }"><p data-block-key="qapzx">Gemini 3 Flash is also starting to roll out as the default model for AI Mode in Search with access to everyone around the world.</p><p data-block-key="5fmab">Building on the reasoning capabilities of Gemini 3 Pro, AI Mode with Gemini 3 Flash is more powerful at parsing the nuances of your question. It considers each aspect of your query to serve thoughtful, comprehensive responses that are visually digestible — pulling real-time local information and helpful links from across the web. The result effectively combines research with immediate action: you get an intelligently organized breakdown alongside specific recommendations — at the speed of Search.</p><p data-block-key="fba77">This shines when tackling complex goals with multiple considerations like trying to plan a last-minute trip or learning complex educational concepts quickly.</p></div>
  

  
    
  
    




  <uni-youtube-player-article index="19" thumbnail-alt="Demo of Gemini 3 Flash in AI Mode" subtitle="Gemini 3 Flash brings the incredible reasoning capabilities of Gemini 3 to Search, without compromising speed, so you can tackle your most complicated questions." video-id="rPXBDSf-Hwg" video-type="video">
  </uni-youtube-player-article>











  


  

  
    <div data-component="uni-article-paragraph" role="presentation" data-analytics-module="{
           &quot;module_name&quot;: &quot;Paragraph&quot;,
           &quot;section_header&quot;: &quot;Gemini 3 Flash: frontier intelligence built for speed&quot;
         }"><h2 data-block-key="qapzx">Try Gemini 3 Flash today</h2><p data-block-key="avrm2">Gemini 3 Flash is available now in preview via the <a href="https://ai.google.dev/gemini-api/docs/models#gemini-3-flash">Gemini API</a> in Google AI Studio, <a href="https://antigravity.google/">Google Antigravity,</a> <a href="https://cloud.google.com/vertex-ai?e=48754805">Vertex AI</a> and <a href="https://cloud.google.com/gemini-enterprise?e=48754805">Gemini Enterprise</a>. You can also access it through other developer tools like <a href="https://developers.googleblog.com/gemini-3-flash-is-now-available-in-gemini-cli/">Gemini CLI</a> and <a href="https://android-developers.googleblog.com/2025/12/build-smarter-apps-with-gemini-3-flash">Android Studio</a>. It’s also starting to roll out to everyone in the <a href="https://gemini.google.com/">Gemini app</a> and <a href="https://www.google.com/search?udm=50&amp;aep=11">AI Mode</a> in Search, bringing fast access to next-generation intelligence at no cost.</p><p data-block-key="e3atd">We’re looking forward to seeing what you bring to life with this expanded family of models: Gemini 3 Pro, Gemini 3 Deep Think and now, Gemini 3 Flash.</p></div>
  


            
            

            
              




            
          </div>
  </article></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Coursera to combine with Udemy (217 pts)]]></title>
            <link>https://investor.coursera.com/news/news-details/2025/Coursera-to-Combine-with-Udemy-to-Empower-the-Global-Workforce-with-Skills-for-the-AI-Era/default.aspx</link>
            <guid>46301346</guid>
            <pubDate>Wed, 17 Dec 2025 12:45:40 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://investor.coursera.com/news/news-details/2025/Coursera-to-Combine-with-Udemy-to-Empower-the-Global-Workforce-with-Skills-for-the-AI-Era/default.aspx">https://investor.coursera.com/news/news-details/2025/Coursera-to-Combine-with-Udemy-to-Empower-the-Global-Workforce-with-Skills-for-the-AI-Era/default.aspx</a>, See on <a href="https://news.ycombinator.com/item?id=46301346">Hacker News</a></p>
Couldn't get https://investor.coursera.com/news/news-details/2025/Coursera-to-Combine-with-Udemy-to-Empower-the-Global-Workforce-with-Skills-for-the-AI-Era/default.aspx: Error: Request failed with status code 403]]></description>
        </item>
        <item>
            <title><![CDATA[Is Mozilla trying hard to kill itself? (641 pts)]]></title>
            <link>https://infosec.press/brunomiguel/is-mozilla-trying-hard-to-kill-itself</link>
            <guid>46299934</guid>
            <pubDate>Wed, 17 Dec 2025 09:37:24 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://infosec.press/brunomiguel/is-mozilla-trying-hard-to-kill-itself">https://infosec.press/brunomiguel/is-mozilla-trying-hard-to-kill-itself</a>, See on <a href="https://news.ycombinator.com/item?id=46299934">Hacker News</a></p>
<div id="readability-page-1" class="page"><div><p>In an interview with “The Verge”, the new Mozilla CEO, Enzor-DeMeo, IMHO hints that axing adblockers is something that, at the very least, was on the table in some form and at some point. From <a href="https://www.theverge.com/tech/845216/mozilla-ceo-anthony-enzor-demeo" rel="nofollow">the article</a>:</p>

<blockquote><p>He says he could begin to block ad blockers in Firefox and estimates that’d bring in another $150 million, but he doesn’t want to do that. It feels off-mission.</p></blockquote>

<p>It may be just me, but I read this as “I don't want to 😜 😜 but I'll kill AdBlockers in Firefox for buckerinos 😂”. This disappoints and saddens me a lot, and I hope I'm wrong.</p>

<p>I've been using Firefox before it was called that. Heck, I even used the Mozilla Application Suite back in the day. It was its commitment to open standards and the open web, and its powerful add-on system, that attracted me to its software.</p>

<p>Honestly, that's what's been keeping me. I think that's also what's been keeping their loyal base of users with the project, the geeks and nerds that care about privacy. It's the same group of people who helped it get very popular at one point.</p>

<p>Killing one of its advantages over the Chromium engine, being able to have a fucking adblocker that's actually useful, and that nowadays is a fucking security feature due to malvertising, will be another nail in the coffin, IMHO. The core community will feel disenfranchised, and this may have negative consequences for the project. You know why? Because these are some of the people that the <em>normies</em> turn to when they want tech advice.</p>

<p>For fuck sake, for-profit side of Mozilla, get a damn grip!</p>

<p><a href="https://infosec.press/brunomiguel/tag:Mozilla" rel="nofollow"><span>#</span><span>Mozilla</span></a> <a href="https://infosec.press/brunomiguel/tag:Firefox" rel="nofollow"><span>#</span><span>Firefox</span></a> <a href="https://infosec.press/brunomiguel/tag:AdBlocker" rel="nofollow"><span>#</span><span>AdBlocker</span></a> <a href="https://infosec.press/brunomiguel/tag:OpenSource" rel="nofollow"><span>#</span><span>OpenSource</span></a> <a href="https://infosec.press/brunomiguel/tag:FOSS" rel="nofollow"><span>#</span><span>FOSS</span></a></p>
</div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[AI's real superpower: consuming, not creating (136 pts)]]></title>
            <link>https://msanroman.io/blog/ai-consumption-paradigm</link>
            <guid>46299552</guid>
            <pubDate>Wed, 17 Dec 2025 08:34:00 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://msanroman.io/blog/ai-consumption-paradigm">https://msanroman.io/blog/ai-consumption-paradigm</a>, See on <a href="https://news.ycombinator.com/item?id=46299552">Hacker News</a></p>
<div id="readability-page-1" class="page"><section><span>October 30, 2025</span><p>Everyone's using AI wrong. Including me, until last month.</p>
<p>We ask AI to write emails, generate reports, create content. But that's like using a supercomputer as a typewriter. The real breakthrough happened when I flipped my entire approach.</p>
<p>AI's superpower isn't creation. It's consumption.</p>
<h2 id="the-creation-trap">The creation trap</h2>
<p>Here's how most people use AI:</p>
<ul>
<li>"Write a blog post about engineering leadership"</li>
<li>"Generate code for this feature"</li>
<li>"Create a summary of this meeting"</li>
</ul>
<p>Makes sense. These tasks save time. But they're thinking too small.</p>
<p>My Obsidian vault contains:
→ 3 years of daily engineering notes
→ 500+ meeting reflections
→ Thousands of fleeting observations about building software
→ Every book highlight and conference insight I've captured</p>
<p>No human could read all of this in a lifetime. AI consumes it in seconds.</p>
<h2 id="the-consumption-breakthrough">The consumption breakthrough</h2>
<p>Last month I connected my Obsidian vault to AI. The questions changed completely:</p>
<p>Instead of "Write me something new"
I ask "What have I already discovered?"</p>
<p>Real examples from this week:</p>
<p><strong>"What patterns emerge from my last 50 one-on-ones?"</strong>
AI found that performance issues always preceded tool complaints by 2-3 weeks. I'd never connected those dots.</p>
<p><strong>"How has my thinking about technical debt evolved?"</strong>
Turns out I went from seeing it as "things to fix" to "information about system evolution" around March 2023. Forgotten paradigm shift.</p>
<p><strong>"Find connections between Buffer's API design and my carpeta.app architecture"</strong>
Surfaced 12 design decisions I'm unconsciously repeating. Some good. Some I need to rethink.</p>
<h2 id="your-knowledge-compounds-but-only-if-accessible">Your knowledge compounds, but only if accessible</h2>
<p>Every meeting, every shower thought, every debugging session teaches you something. But that knowledge is worthless if you can't retrieve it.</p>
<p>Traditional search fails because you need to remember exact words. Your brain fails because it wasn't designed to store everything.</p>
<p>AI changes the retrieval game:
→ Query by concept, not keywords
→ Find patterns across years, not just documents
→ Connect ideas that were separated by time and context</p>
<p>The constraint was never writing. Humans are already good at creating when they have the right inputs.</p>
<p>The constraint was always consumption. Reading everything. Remembering everything. Connecting everything.</p>
<h2 id="building-your-consumption-system">Building your consumption system</h2>
<p>My setup is deceptively simple:</p>
<ol>
<li>Everything goes into Obsidian (meetings, thoughts, reflections)</li>
<li>AI has access to the entire vault</li>
<li>I query my past self like a research assistant</li>
</ol>
<p>But the magic isn't in the tools. It's in the mindset shift.</p>
<p>Stop thinking of AI as a creator. Start thinking of it as the ultimate reader of your experience.</p>
<p>Every note becomes a future insight. Every reflection becomes searchable wisdom. Every random observation might be the missing piece for tomorrow's problem.</p>
<h2 id="the-compound-effect">The compound effect</h2>
<p>After two months of this approach:</p>
<p>→ I solve problems faster by finding similar past situations
→ I make better decisions by accessing forgotten context
→ I see patterns that were invisible when scattered across time</p>
<p>Your experience is your competitive advantage. But only if you can access it.</p>
<p>Most people are sitting on goldmines of insight, locked away in notebooks, random files, and fading memories. AI turns that locked vault into a queryable database of your own expertise.</p>
<h2 id="the-real-revolution">The real revolution</h2>
<p>We're still thinking about AI like it's 2023. Writing assistants. Code generators. Content creators.</p>
<p>The real revolution is AI as the reader of everything you've ever thought.</p>
<p>And that changes everything about how we should capture knowledge today.</p>
<p>Start documenting. Not for others. For your future self and the AI that will help you remember what you've forgotten you know.</p>
<hr>
<p><em>This piece originally appeared in my <a href="https://mikesanroman.substack.com/" target="_blank" rel="noopener">weekly newsletter</a>. Subscribe for insights on thinking differently about work, technology, and what's actually possible.</em></p></section></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Tesla reports another Robotaxi crash (143 pts)]]></title>
            <link>https://electrek.co/2025/12/15/tesla-reports-another-robotaxi-crash-even-with-supervisor/</link>
            <guid>46297702</guid>
            <pubDate>Wed, 17 Dec 2025 02:52:22 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://electrek.co/2025/12/15/tesla-reports-another-robotaxi-crash-even-with-supervisor/">https://electrek.co/2025/12/15/tesla-reports-another-robotaxi-crash-even-with-supervisor/</a>, See on <a href="https://news.ycombinator.com/item?id=46297702">Hacker News</a></p>
<div id="readability-page-1" class="page"><div>
					
<figure>

	<img width="1600" height="765" src="https://electrek.co/wp-content/uploads/sites/3/2025/10/Tesla-Robotaxi-hero.png?w=1600" alt="Tesla Robotaxi hero" srcset="https://i0.wp.com/electrek.co/wp-content/uploads/sites/3/2025/10/Tesla-Robotaxi-hero.png?w=320&amp;quality=82&amp;strip=all&amp;ssl=1 320w, https://i0.wp.com/electrek.co/wp-content/uploads/sites/3/2025/10/Tesla-Robotaxi-hero.png?w=640&amp;quality=82&amp;strip=all&amp;ssl=1 640w, https://i0.wp.com/electrek.co/wp-content/uploads/sites/3/2025/10/Tesla-Robotaxi-hero.png?w=1024&amp;quality=82&amp;strip=all&amp;ssl=1 1024w, https://i0.wp.com/electrek.co/wp-content/uploads/sites/3/2025/10/Tesla-Robotaxi-hero.png?w=1500&amp;quality=82&amp;strip=all&amp;ssl=1 1500w" decoding="async" fetchpriority="high">
	</figure>

<p>Tesla has reported yet another crash involving its Robotaxi fleet in Austin to the NHTSA. The new data keeps the program’s accident rate alarmingly high compared to human drivers, even as the company prepares to <a target="_blank" rel="noreferrer noopener" href="https://electrek.co/2025/12/09/tesla-ceo-elon-musk-claims-driverless-robotaxis-coming-to-austin-in-3-weeks/">remove human safety supervisors from the vehicles</a>.</p>



<p>As we have been tracking in our <a href="https://electrek.co/2025/11/17/tesla-robotaxi-had-3-more-crashes-now-7-total/" target="_blank" rel="noreferrer noopener">previous coverage of the Robotaxi pilot</a> in Austin, Tesla is required to report crashes involving its automated driving systems (ADS) to the NHTSA under a Standing General Order.</p>



<p>For months, we’ve seen these reports trickle in from Tesla’s small pilot fleet in Texas. In November, we reported that the fleet had reached <a href="https://electrek.co/2025/11/17/tesla-robotaxi-had-3-more-crashes-now-7-total/" target="_blank" rel="noreferrer noopener">7 total crashes</a> as of September.</p>



<p>Now, a new report filed by Tesla reveals an 8th crash occurred in October 2025.</p>	
	



<p>According to the filing, the incident took place on October [Day Redacted], 2025, in Austin. The valid report (Report ID: 13781-11986) lists the “Highest Injury Severity Alleged” as “No Injured Reported,” but details are scarce because, as is typical for Tesla, the narrative description of the crash has been redacted to hide proprietary information.</p>



<p>We have been highlighting how Tesla often abuses NHTSA’s capability to redact much of the information in the crash reports, especially the ‘Narrative’ section, which explains precisely what happened in the incident.</p>



<p>It’s possible that Tesla’s Robotaxis are not responsible for some of these crashes, but we wouldn’t know because Tesla redacts most information.</p>



<p>In this new filing for the accident that happened in October, Tesla went even further as it even refrains from answering some of the sections. Instead, it says “see the narrative,” which again is redacted.</p>



<p>Here’s the updated list of Tesla Robotaxi crashes:</p>



<figure><table><thead><tr><td><strong>Report ID</strong></td><td><strong>Incident Date</strong></td><td><strong>City</strong></td><td><strong>State</strong></td><td><strong>Crash With</strong></td><td><strong>Highest Injury Severity Alleged</strong></td></tr></thead><tbody><tr><td>13781-11986</td><td>OCT-2025</td><td>Austin</td><td>TX</td><td>Other, see Narrative</td><td>No Injured Reported</td></tr><tr><td>13781-11787</td><td>SEP-2025</td><td>Austin</td><td>TX</td><td>Animal</td><td>No Injured Reported</td></tr><tr><td>13781-11786</td><td>SEP-2025</td><td>Austin</td><td>TX</td><td>Non-Motorist: Cyclist</td><td>Property Damage. No Injured Reported</td></tr><tr><td>13781-11784</td><td>SEP-2025</td><td>Austin</td><td>TX</td><td>Passenger Car</td><td>Property Damage. No Injured Reported</td></tr><tr><td>13781-11687</td><td>SEP-2025</td><td>Austin</td><td>TX</td><td>Other Fixed Object</td><td>Property Damage. No Injured Reported</td></tr><tr><td>13781-11507</td><td>JUL-2025</td><td>Austin</td><td>TX</td><td>SUV</td><td>Property Damage. No Injured Reported</td></tr><tr><td>13781-11459</td><td>JUL-2025</td><td>Austin</td><td>TX</td><td>Other Fixed Object</td><td>Minor W/O Hospitalization</td></tr><tr><td>13781-11375</td><td>JUL-2025</td><td>Austin</td><td>TX</td><td>SUV</td><td>Property Damage. No Injured Reported</td></tr></tbody></table></figure>



<p>We do know that the crash involved “Other” as the conflict partner, and the vehicle was “Proceeding Straight” at the time.</p>



<h3 id="h-tesla-robotaxi-crash-rate">Tesla Robotaxi Crash Rate</h3>



<p>While a few fender benders might not seem like headline news, it becomes significant when you look at the math.</p>



<p>Last month, Tesla confirmed the fleet had traveled roughly 250,000 miles. With 7 reported crashes at the time, <a href="https://electrek.co/2025/11/17/tesla-robotaxi-had-3-more-crashes-now-7-total/" target="_blank" rel="noreferrer noopener">Tesla’s Robotaxi was crashing roughly once every 40,000 miles </a>(extrapolating from the previously disclosed Robotaxi mileage).</p>



<p>For comparison, the average human driver in the US crashes about once every 500,000 miles.</p>



<p>This means Tesla’s “autonomous” vehicle, which is supposed to be the future of safety, is crashing 10x more often than a human driver.</p>



<p>While Tesla’s Robotaxi fleet reportedly increased in November, with the number of cars spotted going up to 29, there’s no evidence that the Robotaxi mileage increased. In fact, the utilization rate indicates Tesla is running only a few vehicles at a time – meaning that mileage might have actually gone down.</p>



<p>And that is not even the scariest part.</p>



<h3 id="h-the-supervisor-paradox">The Supervisor Paradox</h3>



<p>The most critical detail that gets lost in the noise is that these crashes are happening with a human safety supervisor in the driver’s seat (for highway trips) or passenger seat, with a finger on a kill switch.</p>



<p>These employees are trained to intervene and take control of the vehicle if the software makes a mistake. </p>



<p>If the car is crashing this frequently with a human babysitter trying to prevent accidents, imagine what the crash rate would be without them.</p>



<p>Yet, that is exactly what Tesla is doing.</p>



<p>Elon Musk recently claimed that Tesla would <a target="_blank" rel="noreferrer noopener" href="https://electrek.co/2025/12/09/tesla-ceo-elon-musk-claims-driverless-robotaxis-coming-to-austin-in-3-weeks/">remove safety monitors from the Robotaxi fleet</a> in Austin within “three weeks.”</p>



<p>Yesterday, we reported that <a href="https://electrek.co/2025/12/14/tesla-robotaxi-spotted-without-a-safety-driver-austin-musk-confirms-testing-begins/">a Tesla Robotaxi was spotted for the first time without anyone in the front seat</a>s, and Musk confirmed that Tesla started testing without a supervisor.</p>



<h3 id="h-electrek-s-take">Electrek’s Take</h3>



<p>This is becoming hard to watch.</p>



<p>We have <a href="https://electrek.co/2025/12/10/elon-musk-waymo-never-had-chance-against-tesla/" target="_blank" rel="noreferrer noopener">Waymo operating fully driverless</a> commercial services in multiple cities with over 100 million miles of data showing they are safer than humans. They are not without their issues, but they are at least sharing data that is encouraging, including not redacting the NTHSA crash reporting.</p>




	<p>Meanwhile, Tesla is struggling to keep a small test fleet in Austin from hitting things, even with professional safety drivers on board.</p>



<p>Removing the safety supervisors when your crash rate is already orders of magnitude worse than the average human seems reckless. It feels like another case of prioritizing the “optics” of autonomy over the actual safety required to deploy it.</p>



<p>If Tesla pulls the supervisors while the data looks like this, it’s no longer a pilot program. It’s a gamble. And it’s not just gambling on its stock price, it’s gambling with everyone’s safety.</p>




	<p>
				<a target="_blank" rel="nofollow" href="https://news.google.com/publications/CAAqBwgKMKqD-Qow6c_gAg?hl=en-US&amp;gl=US&amp;ceid=US:en">
			<em>Add Electrek to your Google News feed.</em>&nbsp;
					</a>
			</p>
	<p><em>FTC: We use income earning auto affiliate links.</em> <a href="https://electrek.co/about/#affiliate">More.</a></p>				</div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[I ported JustHTML from Python to JavaScript with Codex CLI and GPT-5.2 in hours (222 pts)]]></title>
            <link>https://simonwillison.net/2025/Dec/15/porting-justhtml/</link>
            <guid>46295771</guid>
            <pubDate>Tue, 16 Dec 2025 22:48:56 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://simonwillison.net/2025/Dec/15/porting-justhtml/">https://simonwillison.net/2025/Dec/15/porting-justhtml/</a>, See on <a href="https://news.ycombinator.com/item?id=46295771">Hacker News</a></p>
<div id="readability-page-1" class="page"><div data-permalink-context="/2025/Dec/15/porting-justhtml/">

<p>15th December 2025</p>



<p>I <a href="https://simonwillison.net/2025/Dec/14/justhtml/">wrote about JustHTML yesterday</a>—Emil Stenström’s project to build a new standards compliant HTML5 parser in pure Python code using coding agents running against the comprehensive html5lib-tests testing library. Last night, purely out of curiosity, I decided to try <strong>porting JustHTML from Python to JavaScript</strong> with the least amount of effort possible, using Codex CLI and GPT-5.2. It worked beyond my expectations.</p>
<h4 id="tl-dr">TL;DR</h4>
<p>I built <a href="https://github.com/simonw/justjshtml">simonw/justjshtml</a>, a dependency-free HTML5 parsing library in JavaScript which passes 9,200 tests from the html5lib-tests suite and imitates the API design of Emil’s JustHTML library.</p>
<p>It took two initial prompts and a few tiny follow-ups. <a href="https://simonwillison.net/2025/Dec/11/gpt-52/">GPT-5.2</a> running in <a href="https://github.com/openai/codex">Codex CLI</a> ran uninterrupted for several hours, burned through 1,464,295 input tokens, 97,122,176 cached input tokens and 625,563 output tokens and ended up producing 9,000 lines of fully tested JavaScript across 43 commits.</p>
<p>Time elapsed from project idea to finished library: about 4 hours, during which I also bought and decorated a Christmas tree with family and watched the latest Knives Out movie.</p>
<h4 id="some-background">Some background</h4>
<p>One of the most important contributions of the HTML5 specification ten years ago was the way it precisely specified how <em>invalid</em> HTML should be parsed. The world is full of invalid documents and having a specification that covers those means browsers can treat them in the same way—there’s no more “undefined behavior” to worry about when building parsing software.</p>
<p>Unsurprisingly, those invalid parsing rules are pretty complex! The free online book <a href="https://htmlparser.info/">Idiosyncrasies of the HTML parser</a> by Simon Pieters is an excellent deep dive into this topic, in particular <a href="https://htmlparser.info/parser/">Chapter 3. The HTML parser</a>.</p>
<p>The Python <a href="https://github.com/html5lib/html5lib-python">html5lib</a> project started the <a href="https://github.com/html5lib/html5lib-tests">html5lib-tests</a> repository with a set of implementation-independent tests. These have since become the gold standard for interoperability testing of HTML5 parsers, and are used by projects such as <a href="https://github.com/servo/servo">Servo</a> which used them to help build <a href="https://github.com/servo/html5ever">html5ever</a>, a “high-performance browser-grade HTML5 parser” written in Rust.</p>
<p>Emil Stenström’s <a href="https://github.com/EmilStenstrom/justhtml">JustHTML</a> project is a pure-Python implementation of an HTML5 parser that passes the full html5lib-tests suite. Emil <a href="https://friendlybit.com/python/writing-justhtml-with-coding-agents/">spent a couple of months</a> working on this as a side project, deliberately picking a problem with a comprehensive existing test suite to see how far he could get with coding agents.</p>
<p>At one point he had the agents rewrite it based on a close inspection of the Rust html5ever library. I don’t know how much of this was direct translation versus inspiration (here’s Emil’s <a href="https://news.ycombinator.com/item?id=46264195#46267059">commentary on that</a>)—his project has 1,215 commits total so it appears to have included a huge amount of iteration, not just a straight port.</p>
<p>My project <strong>is</strong> a straight port. I instructed Codex CLI to build a JavaScript version of Emil’s Python code.</p>
<h4 id="the-process-in-detail">The process in detail</h4>
<p>I started with a bit of mise en place. I checked out two repos and created an empty third directory for the new project:</p>
<div><pre><span>cd</span> <span>~</span>/dev
git clone https://github.com/EmilStenstrom/justhtml
git clone https://github.com/html5lib/html5lib-tests
mkdir justjshtml
<span>cd</span> justjshtml</pre></div>
<p>Then I started Codex CLI for GPT-5.2 like this:</p>

<p>That <code>--yolo</code> flag is a shortcut for <code>--dangerously-bypass-approvals-and-sandbox</code>, which is every bit as dangerous as it sounds.</p>
<p>My first prompt told Codex to inspect the existing code and use it to build a specification for the new JavaScript library:</p>
<blockquote>
<p><code>We are going to create a JavaScript port of ~/dev/justhtml - an HTML parsing library that passes the full ~/dev/html5lib-tests test suite. It is going to have a similar API to the Python library but in JavaScript. It will have no dependencies other than raw JavaScript, hence it will work great in the browser and node.js and other environments. Start by reading ~/dev/justhtml and designing the user-facing API for the new library - create a spec.md containing your plan.</code></p>
</blockquote>
<p>I reviewed the spec, which included a set of proposed milestones, and told it to add another:</p>
<blockquote>
<p><code>Add an early step to the roadmap that involves an initial version that parses a simple example document that is valid and returns the right results. Then add and commit the spec.md file.</code></p>
</blockquote>
<p>Here’s <a href="https://github.com/simonw/justjshtml/blob/19b8eb1f2ca80f428a3c40862d5ec05d36e5166b/spec.md">the resulting spec.md file</a>. My request for that initial version became “Milestone 0.5” which looked like this:</p>
<blockquote>
<p><strong>Milestone 0.5 — End-to-end smoke parse (single valid document)</strong></p>
<ul>
<li>Implement the smallest end-to-end slice so the public API is real early:
<ul>
<li>
<code>new JustHTML("&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;")</code> returns a tree with the expected tag structure and text nodes.</li>
<li>
<code>doc.toText()</code> returns <code>"Hello"</code> and <code>doc.errors</code> is empty for this valid input.</li>
</ul>
</li>
<li>Add <code>scripts/smoke.js</code> (no deps) that runs the example and asserts the expected structure/output.</li>
<li>Gate: <code>node scripts/smoke.js</code> passes.</li>
</ul>
</blockquote>
<p>Then I told it:</p>
<blockquote>
<p><code>Implement Milestone 0.5</code></p>
</blockquote>
<p>And off it went. The resulting code appeared to work so I said:</p>
<blockquote>
<p><code>Configure GitHub Actions test.yml to run that on every commit, then commit and push</code></p>
</blockquote>
<p>I ran <code>git init</code> and created a private GitHub repository for this project at this point, and set up the local directory to push to that remote.</p>
<p>Here’s <a href="https://github.com/simonw/justjshtml/commit/48497cbd05584c88af757a0736a2ee447468b6b3">that initial push</a>. Then I told it:</p>
<blockquote>
<p><code>OK do the rest, commit and push often</code></p>
</blockquote>
<p>And that was almost it!</p>
<p>I set my laptop to not fall asleep and left it to its devices while we went off to buy a Christmas tree. The “commit and push often” meant I could monitor its progress on my phone by refreshing <a href="https://github.com/simonw/justjshtml/commits/main">the commit log on GitHub</a>.</p>
<p>I was running this against my $20/month ChatGPT Plus account, which has a five hour token allowance window for Codex CLI. That ran out at 6:35pm and Codex paused, so I waited until the reset point at 7:14pm and typed:</p>
<blockquote>
<p><code>Keep going</code></p>
</blockquote>
<p>At 9:30pm it declared itself done with the following summary message:</p>
<pre><code>• What’s Done

  - html5lib-tests now run in CI and pass: tokenizer 6810/6810, tree 1770/1782
    (12 skipped: #script-on), serializer 230/230, encoding 82/83 (1 skipped:
    scripted) (.github/workflows/test.yml:1).
  - Public API expanded: stream() (src/stream.js:1), CSS selectors query()/
    matches() (src/selector.js:1), and toMarkdown() (src/markdown.js:1), all
    exported via src/index.js:1.
  - Added no-deps unit scripts for selectors/stream/markdown (scripts/run-
    selector-tests.js:1, scripts/run-stream-tests.js:1, scripts/run-markdown-
    tests.js:1) and wired them into CI.
  - Fixed TreeBuilder so &lt;br&gt; no longer closes &lt;p&gt; (src/treebuilder.js:647).
</code></pre>
<p>As a finishing touch, I had it add a playground interface so I could try out the new library in my browser. I prompted:</p>
<blockquote>
<p><code>Add a playground.html in the top level folder which loads the necessary ES modules from ./src/... and implements the exact same functionality as seen on https://tools.simonwillison.net/justhtml but using the JavaScript library instead of Pyodide</code></p>
</blockquote>
<p>It fetched my <a href="https://tools.simonwillison.net/justhtml">existing JustHTML playground page</a> (<a href="https://simonwillison.net/2025/Dec/14/justhtml/#first-impressions-of-justhtml">described here</a>) using <code>curl</code> and built a new <code>playground.html</code> file that loaded the new JavaScript code instead. This worked <em>perfectly</em>.</p>

<p>I enabled GitHub Pages for my still-private repo which meant I could access the new playground at this URL:</p>
<p><a href="https://simonw.github.io/justjshtml/playground.html">https://simonw.github.io/justjshtml/playground.html</a></p>
<p><img src="https://static.simonwillison.net/static/2025/justjshtml-playground.jpg" alt="Screenshot of JustJSHTML Playground web application. Header reads &quot;JustJSHTML Playground&quot; with subtitle &quot;A dependency-free JavaScript HTML5 parser - GitHub&quot;. Below is a status bar showing &quot;JavaScript Environment&quot; with a green &quot;Ready&quot; badge. The main input area has &quot;Paste HTML&quot; and &quot;Fetch from URL&quot; buttons, with a text area containing HTML code: &quot;<!DOCTYPE html> <html> <head> <title>Example Page</title> </head> <body> <header> <nav> <ul>&quot;. A &quot;Playground Mode&quot; section shows buttons for &quot;CSS Selector Query&quot;, &quot;Pretty Print HTML&quot;, &quot;Tree Structure&quot;, &quot;Stream Events&quot;, &quot;Extract Text&quot;, and &quot;To Markdown&quot; (highlighted in purple). Below is a text field labeled &quot;CSS Selector (optional - leave empty for whole document):&quot; with placeholder &quot;e.g., article, main, .content (or leave empty)&quot; and a green &quot;Convert to Markdown&quot; button. The Output section has a teal header with &quot;Whole document&quot; badge and displays converted markdown: &quot;Example Page&quot; followed by &quot;- [Home](/)&quot; &quot;- [About](/about)&quot; &quot;- [Contact](/contact)&quot;."></p>
<p>All it needed now was some documentation:</p>
<blockquote>
<p><code>Add a comprehensive README with full usage instructions including attribution plus how this was built plus how to use in in HTML plus how to use it in Node.js</code></p>
</blockquote>
<p>You can <a href="https://github.com/simonw/justjshtml/blob/f3a33fdb29bf97846fd017185edc8cf82783032e/README.md">read the result here</a>.</p>
<p>We are now at eight prompts total, running for just over four hours and I’ve decorated for Christmas and watched <a href="https://en.wikipedia.org/wiki/Wake_Up_Dead_Man">Wake Up Dead Man</a> on Netflix.</p>
<p>According to Codex CLI:</p>
<blockquote>
<p><code>Token usage: total=2,089,858 input=1,464,295 (+ 97,122,176 cached) output=625,563 (reasoning 437,010)</code></p>
</blockquote>
<p>My <a href="https://www.llm-prices.com/#it=2089858&amp;cit=97122176&amp;ot=625563&amp;sel=gpt-5.2">llm-prices.com calculator</a> estimates that at $29.41 if I was paying for those tokens at API prices, but they were included in my $20/month ChatGPT Plus subscription so the actual extra cost to me was zero.</p>
<h4 id="what-can-we-learn-from-this-">What can we learn from this?</h4>
<p>I’m sharing this project because I think it demonstrates a bunch of interesting things about the state of LLMs in December 2025.</p>
<ul>
<li>Frontier LLMs really can perform complex, multi-hour tasks with hundreds of tool calls and minimal supervision. I used GPT-5.2 for this but I have no reason to believe that Claude Opus 4.5 or Gemini 3 Pro would not be able to achieve the same thing—the only reason I haven’t tried is that I don’t want to burn another 4 hours of time and several million tokens on more runs.</li>
<li>If you can reduce a problem to a robust test suite you can set a coding agent loop loose on it with a high degree of confidence that it will eventually succeed. I called this <a href="https://simonwillison.net/2025/Sep/30/designing-agentic-loops/">designing the agentic loop</a> a few months ago. I think it’s the key skill to unlocking the potential of LLMs for complex tasks.</li>
<li>Porting entire open source libraries from one language to another via a coding agent works extremely well.</li>
<li>Code is so cheap it’s practically free. Code that <em>works</em> continues to carry a cost, but that cost has plummeted now that coding agents can check their work as they go.</li>
<li>We haven’t even <em>begun</em> to unpack the etiquette and ethics around this style of development. Is it responsible and appropriate to churn out a direct port of a library like this in a few hours while watching a movie? What would it take for code built like this to be trusted in production?</li>
</ul>
<p>I’ll end with some open questions:</p>

<ul>
<li>Does this library represent a legal violation of copyright of either the Rust library or the Python one?</li>
<li>Even if this is legal, is it ethical to build a library in this way?</li>
<li>Does this format of development hurt the open source ecosystem?</li>
<li>Can I even assert copyright over this, given how much of the work was produced by the LLM?</li>
<li>Is it responsible to publish software libraries built in this way?</li>
<li>How much better would this library be if an expert team hand crafted it over the course of several months?</li>
</ul>


</div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[No AI* Here – A Response to Mozilla's Next Chapter (446 pts)]]></title>
            <link>https://www.waterfox.com/blog/no-ai-here-response-to-mozilla/</link>
            <guid>46295268</guid>
            <pubDate>Tue, 16 Dec 2025 22:07:49 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://www.waterfox.com/blog/no-ai-here-response-to-mozilla/">https://www.waterfox.com/blog/no-ai-here-response-to-mozilla/</a>, See on <a href="https://news.ycombinator.com/item?id=46295268">Hacker News</a></p>
<div id="readability-page-1" class="page"><div> <p>Mozilla’s new CEO recently announced their <a href="https://blog.mozilla.org/en/mozilla/leadership/mozillas-next-chapter-anthony-enzor-demeo-new-ceo/">vision for the future</a>: positioning Mozilla as “the world’s most trusted software company” with AI at its centre. As someone who has spent nearly 15 years building and maintaining Waterfox, I understand the existential pressure Mozilla faces. Their lunch is being eaten by AI browsers. Alphabet themselves reportedly see the writing on the wall, developing what appears to be a new browser separate from Chrome. The threat is real, and I have genuine sympathy for their position.</p>
<p>But I believe Mozilla is making a fundamental mistake.</p>
<h2 id="the-asterisk-matters">The Asterisk Matters</h2>
<p>Let’s be clear about what we’re talking about. “AI” has become a catch-all term that to me, obscures more than it reveals. Machine learning technologies like the <a href="https://github.com/browsermt/bergamot-translator">Bergamot translation project</a> offer real, tangible utility. Bergamot is transparent in what it does (translate text locally, period), auditable (you can inspect the model and its behavior), and has clear, limited scope, even if the internal neural network logic isn’t strictly deterministic.</p>
<p>Large language models are something else entirely˟. They are black boxes. You cannot audit them. You cannot truly understand what they do with your data. You cannot verify their behaviour. And Mozilla wants to put them at the heart of the browser and that doesn’t sit well.</p>
<p>But it’s important to note I do find LLMs have utility, measurably so. But here I am talking in the context of a web browser and the fundamental scepticism I have toward it in that context.</p>
<h2 id="what-is-a-browser-for">What Is a Browser For?</h2>
<p>A browser is meant to be a user agent, more specifically, <em>your</em> agent on the web. It represents you, acts on your behalf, and executes your instructions. It’s called a user agent for a reason.</p>
<p>When you introduce a potential LLM layer between the user and the web, you create something different: “a user agent user agent” of sorts. The AI becomes the new user agent, mediating and interpreting between you and the browser. It reorganises your tabs. It rewrites your history. It makes decisions about what you see and how you see it, based on logic you cannot examine or understand.</p>
<p>Mozilla promises that “AI should always be a choice - something people can easily turn off.” That’s fine. But how do you keep track of what a black box actually does when it’s turned on? How do you audit its behaviour? How do you know it’s not quietly reshaping your browsing experience in ways you haven’t noticed?</p>
<p>Even if you can disable individual AI features, the cognitive load of monitoring an opaque system that’s supposedly working on your behalf would be overwhelming. Now, I truly believe and trust that Mozilla will do what they think is best for the user; but I’m not convinced it will be.</p>
<p>This isn’t paranoia, because after all, “It will evolve into a modern AI browser and support a portfolio of new and trusted software additions.” It’s a reasonable response to fundamentally untrustworthy technology being positioned as the future of web browsing.</p>
<h2 id="mozillas-dilemma">Mozilla’s Dilemma?</h2>
<p>I get it. Mozilla is facing an existential crisis. AI browsers are proliferating. The market is shifting. Revenue diversification from search is urgent. Firefox’s market share continues to decline. The pressure to “do something” must be immense, and I understand that.</p>
<p>But there’s a profound irony in their response. Mozilla speaks about trust, transparency, and user agency while simultaneously embracing technology that undermines all three principles. They promise AI will be optional, but that promise acknowledges they’re building AI so deeply into Firefox that an opt-out mechanism becomes necessary in the first place.</p>
<p>Mozilla’s strength has always come from the technical community - developers, power users, privacy advocates. These are the people who understand what browsers should be and what they’re for. Yet Mozilla seems convinced they need to chase the average user, the mainstream market that Chrome already dominates.</p>
<p>That chase has been failing for over a decade. Firefox’s market share has declined steadily as Mozilla added features their core community explicitly didn’t want. Now they’re doubling down on that strategy, going after “average Joe” users while potentially alienating the technical community that has been their foundation.</p>
<h2 id="what-waterfox-offers-instead">What Waterfox Offers Instead</h2>
<p>Waterfox exists because some users want a browser that simply works well at being a browser. The UI is mature - arguably, it has been a solved for problem for years. The customisation features are available and apparent. The focus is on performance and web standards.</p>
<p>In many ways, browsers are operating systems of their own, and a browser’s job is to be a good steward of that environment. AI, in its current form and in my opinion does not match that responsibility.</p>
<p>And yes, yes - disabling features is all well and good, but at the end of the day, if these AI features are black boxes, how are we to keep track of what they actually do? The core browsing experience should be one that fully puts the user in control, not one where you’re constantly monitoring an inscrutable system that claims to be helping you.</p>
<p>Waterfox will not include LLMs. Full stop. At least and most definitely not in their current form or for the foreseeable future.</p>
<h3 id="a-note-on-other-forks-and-governance">A Note on other Forks and Governance</h3>
<p>The Firefox fork ecosystem includes several projects that tout their independence from Mozilla. Some strip out more features than Waterfox does, some make bolder design choices.</p>
<p>But here’s what often gets overlooked - many of these projects operate without any formal governance structure, privacy policies, or terms of service. There’s no legal entity, no accountability mechanism, no recourse if promises are broken. Open source gives developers the freedom to fork code and make claims, but it doesn’t automatically make those claims trustworthy.</p>
<p>When it comes to something as critical as a web browser - software that mediates your most sensitive online interactions - the existence of a responsible organisation with clear policies becomes crucial. Waterfox maintains formal policies and a legal entity, not because it’s bureaucratic overhead, but because it creates accountability that many browser projects simply don’t have.</p>
<p>You deserve to know who is responsible for the software you rely on daily and how decisions about your privacy are made. The existence of formal policies, even imperfect ones, represents a commitment that your interests matter and that there’s someone to hold accountable.</p>
<p>You may think, so what? And fair enough, I can’t change your mind on that, but Waterfox’s governance has allowed it to do something no other fork has (and likely will not do) - trust from other large, imporant third parties which in turn has given Waterfox users access to protected streaming services via Widevine. It’s a small thing, but to me it showcases the power of said governance.</p>
<h2 id="on-inevitability">On Inevitability</h2>
<p>Some will argue that AI browsers are inevitable, that we’re fighting against the tide of history. Perhaps. AI browsers may eat the world.
But the web, despite having core centralised properties, is fundamentally decentralised. There will always be alternatives. If AI browsers dominate and then falter, if users discover they want something simpler and more trustworthy, Waterfox will still be here, marching patiently along.
We’ve been here before. When Firefox abandoned XUL extensions, Waterfox Classic preserved them. When Mozilla started adding telemetry and Pocket and sponsored content, Waterfox stripped it out. When the technical community asked for a browser that simply respected them, Waterfox delivered.</p>
<p>I’ll keep doing that. Not because it’s the most profitable path or because it’s trendy, but because it’s what users who value independence and transparency actually need.</p>
<p>The browser’s job is to serve you, not to think for you. That core Waterfox principle hasn’t changed, and it won’t.</p>
<hr>
<p>* The asterisk acknowledges that “AI” has become a catch-all term. Machine learning tools like local translation engines (Bergamot) are valuable and transparent. Large language models, in their current black-box form, are neither.</p>
<p>˟ As is my understanding, but please feel free to correct me if that isn’t correct.</p> </div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[MIT professor shot at his Massachusetts home dies (237 pts)]]></title>
            <link>https://www.bbc.com/news/articles/cly08y25688o</link>
            <guid>46295071</guid>
            <pubDate>Tue, 16 Dec 2025 21:52:26 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://www.bbc.com/news/articles/cly08y25688o">https://www.bbc.com/news/articles/cly08y25688o</a>, See on <a href="https://news.ycombinator.com/item?id=46295071">Hacker News</a></p>
<div id="readability-page-1" class="page"><div data-component="text-block"><p>A Massachusetts university professor who was shot at his home has died, campus officials say. </p><p>Nuno F Gomes Loureiro, 47, a nuclear science and engineering professor from Portugal, was shot "multiple times" on Monday and died on Tuesday morning in hospital, according to Brookline police and Massachusetts Institute of Technology (MIT) officials.</p><p>Police said officers responded to a call for gunshots at an apartment at about 8:30pm local time. Loureiro was taken by ambulance to a Boston hospital, where he died on Tuesday morning. </p><p>No one is in custody and police are treating the incident as "an active and ongoing homicide investigation",  the Norfolk County District Attorney's Office said.</p></div><div data-component="text-block"><p>CBS News, the BBC's US media partner, reported that a neighbour said he heard "three loud bangs" Monday evening and thought somebody in the apartment building was kicking in a door. </p><p>Long-time resident Anne Greenwald told CBS that the professor had a young family and went to school nearby.</p><p>Loureiro majored in Physics at Instituto Superior Técnico in Lisbon in 2000 and obtained a Phd in physics at Imperial College London in 2005, according to his faculty web page.</p></div><div data-component="text-block"><p>The theoretical physicist and fusion scientist was known for his award-winning research in magnetised plasma dynamics. </p><p>Magnetised plasma dynamics is the study of the state of matter in which the motion of charged particles is influenced by the presence of an external magnetic field, according to Nature.</p><p>Loureiro joined MIT's faculty in 2016 and was named director of MIT's Plasma Science and Fusion Center in 2024.</p><p>His research addressed "complex problems lurking at the center of fusion vacuum chambers and at the edges of the universe", according to the university's obituary. </p><p>He also studied how to harness clean "fusion power" to combat climate change, CBS said.</p><p>"Our deepest sympathies are with his family, students, colleagues, and all those who are grieving," an MIT spokesperson said in a statement provided to the BBC.</p><p>The university added that "focused outreach and conversations" are taking place within the MIT community to offer care and support for those who knew the professor.</p><p>The centre's preceding director, Dennis Whyte, described Loureiro as both a brilliant scientist and a brilliant person.</p><p>"He shone a bright light as a mentor, friend, teacher, colleague and leader, and was universally admired for his articulate, compassionate manner," Mr Whyte told MIT News. </p><p>Deepto Chakrabarty, the head of MIT's department of physics, echoed those sentiments and said that Loureiro was a champion of plasma physics and that his recent research was "a particularly exciting new scientific direction".</p><p><i id="correction-16-december:-an-earlier-version-of-this-story-incorrectly-defined-the-kind-of-plasma-that-professor-loureiro-researched.">Correction 16 December: An earlier version of this story incorrectly defined the kind of plasma that Professor Loureiro researched.</i></p></div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[AI will make formal verification go mainstream (745 pts)]]></title>
            <link>https://martin.kleppmann.com/2025/12/08/ai-formal-verification.html</link>
            <guid>46294574</guid>
            <pubDate>Tue, 16 Dec 2025 21:14:49 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://martin.kleppmann.com/2025/12/08/ai-formal-verification.html">https://martin.kleppmann.com/2025/12/08/ai-formal-verification.html</a>, See on <a href="https://news.ycombinator.com/item?id=46294574">Hacker News</a></p>
<div id="readability-page-1" class="page"><div id="content">
                

                
                <p>Published by Martin Kleppmann on 08 Dec 2025.</p>
                

                <p>Much has been said about the effects that AI will have on software development, but there is an
angle I haven’t seen talked about: I believe that AI will bring formal verification, which for
decades has been a bit of a fringe pursuit, into the software engineering mainstream.</p>

<p>Proof assistants and proof-oriented programming languages such as <a href="https://rocq-prover.org/">Rocq</a>,
<a href="https://isabelle.in.tum.de/">Isabelle</a>, <a href="https://lean-lang.org/">Lean</a>,
<a href="https://fstar-lang.org/">F*</a>, and <a href="https://agda.readthedocs.io/">Agda</a> have been around for a long
time. They make it possible to write a formal specification that some piece of code is supposed to
satisfy, and then mathematically prove that the code <em>always</em> satisfies that spec (even on weird
edge cases that you didn’t think of testing). These tools have been used to develop some large
formally verified software systems, such as an <a href="https://sel4.systems/">operating system kernel</a>,
a <a href="https://compcert.org/">C compiler</a>, and a
<a href="https://project-everest.github.io/">cryptographic protocol stack</a>.</p>

<p>At present, formal verification is mostly used by research projects, and it is
<a href="https://hillelwayne.com/post/why-dont-people-use-formal-methods/">uncommon</a> for industrial software
engineers to use formal methods (even those working on classic high-assurance software such as
medical devices and aircraft). The reason is that writing those proofs is both very difficult
(requiring PhD-level training) and very laborious.</p>

<p>For example, as of 2009, the formally verified seL4 microkernel consisted of 8,700 lines of C code,
but proving it correct required 20 person-years and
<a href="https://www.sigops.org/s/conferences/sosp/2009/papers/klein-sosp09.pdf">200,000 lines</a> of Isabelle
code – or 23 lines of proof and half a person-day for every single line of implementation. Moreover,
there are maybe a few hundred people in the world (wild guess) who know how to write such proofs,
since it requires a lot of arcane knowledge about the proof system.</p>

<p>To put it in simple economic terms: for most systems, the expected cost of bugs is lower than the
expected cost of using the proof techniques that would eliminate those bugs. Part of the reason is
perhaps that bugs are a negative externality: it’s not the software developer who bears the cost of
the bugs, but the users. But even if the software developer were to bear the cost, formal
verification is simply very hard and expensive.</p>

<p>At least, that was the case until recently. Now, LLM-based coding assistants are getting pretty good
not only at writing implementation code, but also at
<a href="https://www.nature.com/articles/s41586-025-09833-y">writing</a>
<a href="https://www.galois.com/articles/claude-can-sometimes-prove-it">proof scripts</a> in
<a href="https://arxiv.org/pdf/2503.14183v1">various languages</a>. At present, a human with specialist
expertise still has to guide the process, but it’s not hard to extrapolate and imagine that process
becoming fully automated in the next few years. And when that happens, it will totally change the
economics of formal verification.</p>

<p>If formal verification becomes vastly cheaper, then we can afford to verify much more software. But
on top of that, AI also creates a <em>need</em> to formally verify more software: rather than having humans
review AI-generated code, I’d much rather have the AI prove to me that the code it has generated is
correct. If it can do that, I’ll take AI-generated code over handcrafted code (with all its
artisanal bugs) any day!</p>

<p>In fact, I would argue that writing proof scripts is one of the best applications for LLMs. It
doesn’t matter if they hallucinate nonsense, because the proof checker will reject any invalid proof
and force the AI agent to retry. The proof checker is a small amount of code that is itself
verified, making it virtually impossible to sneak an invalid proof past the checker.</p>

<p>That doesn’t mean software will suddenly be bug-free. As the verification process itself becomes
automated, the challenge will move to correctly defining the specification: that is, how do you know
that the properties that were proved are actually the properties that you cared about? Reading and
writing such formal specifications still requires expertise and careful thought. But writing the
spec is vastly easier and quicker than writing the proof by hand, so this is progress.</p>

<p>I could also imagine AI agents helping with the process of writing the specifications, translating
between formal language and natural language. Here there is the potential for subtleties to be lost
in translation, but this seems like a manageable risk.</p>

<p>I find it exciting to think that we could just specify in a high-level, declarative way the
properties that we want some piece of code to have, and then to vibe code the implementation along
with a proof that it satisfies the specification. That would totally change the nature of software
development: we wouldn’t even need to bother looking at the AI-generated code any more, just like we
don’t bother looking at the machine code generated by a compiler.</p>

<p>In summary: 1. formal verification is about to become vastly cheaper; 2. AI-generated code needs
formal verification so that we can skip human review and still be sure that it works; 3. the
precision of formal verification counteracts the imprecise and probabilistic nature of LLMs. These
three things taken together mean formal verification is likely to go mainstream in the foreseeable
future. I suspect that soon the limiting factor will not be the technology, but the culture change
required for people to realise that formal methods have become viable in practice.</p>


                <div>
                    <p>If you found this post useful, please
                    <a href="https://www.patreon.com/martinkl">support me on Patreon</a>
                    so that I can write more like it!</p>
                    <p>
                    To get notified when I write something new,
                    <a href="https://bsky.app/profile/martin.kleppmann.com">follow me on Bluesky</a> or
                    <a href="https://nondeterministic.computer/@martin">Mastodon</a>,
                    or enter your email address:
                    </p>

                    

                    <p>
                    I won't give your address to anyone else, won't send you any spam, and you can unsubscribe at any time.
                    </p>
                </div>

                
            </div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Ty: A fast Python type checker and LSP (732 pts)]]></title>
            <link>https://astral.sh/blog/ty</link>
            <guid>46294289</guid>
            <pubDate>Tue, 16 Dec 2025 20:52:45 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://astral.sh/blog/ty">https://astral.sh/blog/ty</a>, See on <a href="https://news.ycombinator.com/item?id=46294289">Hacker News</a></p>
<div id="readability-page-1" class="page"><article><p><strong>TL;DR:</strong> <a href="https://github.com/astral-sh/ty">ty</a> is an <strong>extremely fast Python type checker and
language server</strong>, written in Rust, and designed as an alternative to tools like mypy, Pyright, and
Pylance.</p>
<p>Today, we're announcing the Beta release of <a href="https://github.com/astral-sh/ty">ty</a>. We now use ty
exclusively in our own projects and are ready to recommend it to motivated users for production use.</p>
<hr>
<p>At Astral, we build high-performance developer tools for the Python ecosystem. We're best known for
<a href="https://github.com/astral-sh/uv">uv</a>, our Python package manager, and
<a href="https://github.com/astral-sh/ruff">Ruff</a>, our linter and formatter.</p>
<p>Today, we're announcing the Beta release of the next tool in the Astral toolchain: <strong>ty, an
extremely fast Python type checker and language server</strong>, written in Rust.</p>
<div><p><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 430 117"><g aria-roledescription="group mark container" fill="none" stroke-miterlimit="10"><g aria-roledescription="axis" aria-label="X-axis for a linear scale with values from 0 to 50"><g pointer-events="none"><path stroke="rgba(127,127,127,0.25)" d="M341.5 100.5"></path></g><g pointer-events="none"><text text-anchor="middle" transform="translate(61.5 115.5)" font-family="Roboto Mono,monospace" font-size="12">0s</text><text text-anchor="middle" transform="translate(201.5 115.5)" font-family="Roboto Mono,monospace" font-size="12">20s</text><text text-anchor="middle" transform="translate(341.5 115.5)" font-family="Roboto Mono,monospace" font-size="12">40s</text></g></g><g aria-roledescription="axis" aria-label="Y-axis for a discrete scale with 4 values: ty, Pyrefly, Pyright, mypy"><g pointer-events="none"><text text-anchor="end" transform="translate(51.5 16.5)" font-family="Roboto Mono,monospace" font-size="12" font-weight="bold">ty</text><text text-anchor="end" transform="translate(51.5 41.5)" font-family="Roboto Mono,monospace" font-size="12">Pyrefly</text><text text-anchor="end" transform="translate(51.5 66.5)" font-family="Roboto Mono,monospace" font-size="12">Pyright</text><text text-anchor="end" transform="translate(51.5 91.5)" font-family="Roboto Mono,monospace" font-size="12">mypy</text></g></g><g aria-roledescription="rect mark container"><path aria-label="Sum of time: 2.186; tool: ty" aria-roledescription="bar" d="M61 6h15.302v13H61Z"></path><path aria-label="Sum of time: 5.32; tool: Pyrefly" aria-roledescription="bar" d="M61 31h37.24v13H61Z"></path><path aria-label="Sum of time: 19.623; tool: Pyright" aria-roledescription="bar" d="M61 56h137.361v13H61Z"></path><path aria-label="Sum of time: 45.662; tool: mypy" aria-roledescription="bar" d="M61 81h319.634v13H61Z"></path></g><g aria-roledescription="text mark container"><text aria-label="Sum of time: 5.32; tool: Pyrefly; timeFormat: 5.32s" aria-roledescription="text mark" transform="translate(104.24 41.5)" font-family="Roboto Mono,monospace" font-size="12">5.32s</text><text aria-label="Sum of time: 19.623; tool: Pyright; timeFormat: 19.62s" aria-roledescription="text mark" transform="translate(204.361 66.5)" font-family="Roboto Mono,monospace" font-size="12">19.62s</text><text aria-label="Sum of time: 45.662; tool: mypy; timeFormat: 45.66s" aria-roledescription="text mark" transform="translate(386.634 91.5)" font-family="Roboto Mono,monospace" font-size="12">45.66s</text></g><g aria-roledescription="text mark container"><text aria-label="Sum of time: 2.186; tool: ty; timeFormat: 2.19s" aria-roledescription="text mark" transform="translate(82.302 16.5)" font-family="Roboto Mono,monospace" font-size="12" font-weight="bold">2.19s</text></g></g></svg></p><p><span>Type checking the<!-- --> <a target="_blank" rel="noreferrer" href="https://github.com/home-assistant/core">home-assistant</a> <!-- -->project on the command-line, without caching (<a href="https://github.com/astral-sh/ruff/blob/7f7485d608d2da19a0632a1238f2d4be551f612f/scripts/ty_benchmark/README.md" target="_blank" rel="noreferrer">M4</a>).</span></p></div>
<p>ty was designed from the ground up to power a language server. The entire ty architecture is built
around "incrementality", enabling us to selectively re-run only the necessary computations when a
user (e.g.) edits a file or modifies an individual function. This makes live updates extremely fast
in the context of an editor or long-lived process.</p>
<div><p><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 429 92"><g aria-roledescription="group mark container" fill="none" stroke-miterlimit="10"><g aria-roledescription="axis" aria-label="X-axis for a linear scale with values from 0.0 to 2.8"><g pointer-events="none"><path stroke="rgba(127,127,127,0.25)" d="M311.5 75.5"></path></g><g pointer-events="none"><text text-anchor="middle" transform="translate(61.5 90.5)" font-family="Roboto Mono,monospace" font-size="12">0s</text><text text-anchor="middle" transform="translate(186.5 90.5)" font-family="Roboto Mono,monospace" font-size="12">1s</text><text text-anchor="middle" transform="translate(311.5 90.5)" font-family="Roboto Mono,monospace" font-size="12">2s</text></g></g><g aria-roledescription="axis" aria-label="Y-axis for a discrete scale with 3 values: ty, Pyright, Pyrefly"><g pointer-events="none"><text text-anchor="end" transform="translate(51.5 16.5)" font-family="Roboto Mono,monospace" font-size="12" font-weight="bold">ty</text><text text-anchor="end" transform="translate(51.5 41.5)" font-family="Roboto Mono,monospace" font-size="12">Pyright</text><text text-anchor="end" transform="translate(51.5 66.5)" font-family="Roboto Mono,monospace" font-size="12">Pyrefly</text></g></g><g aria-roledescription="rect mark container"><path aria-label="Sum of time: 0.0044956; tool: ty" aria-roledescription="bar" d="M61 6h.562v13H61Z"></path><path aria-label="Sum of time: 0.3704936; tool: Pyright" aria-roledescription="bar" d="M61 31h46.312v13H61Z"></path><path aria-label="Sum of time: 2.6047441; tool: Pyrefly" aria-roledescription="bar" d="M61 56h325.593v13H61Z"></path></g><g aria-roledescription="text mark container"><text aria-label="Sum of time: 0.3704936; tool: Pyright; timeFormat: 370.5ms" aria-roledescription="text mark" transform="translate(113.312 41.5)" font-family="Roboto Mono,monospace" font-size="12">370.5ms</text><text aria-label="Sum of time: 2.6047441; tool: Pyrefly; timeFormat: 2.60s" aria-roledescription="text mark" transform="translate(392.593 66.5)" font-family="Roboto Mono,monospace" font-size="12">2.60s</text></g><g aria-roledescription="text mark container"><text aria-label="Sum of time: 0.0044956; tool: ty; timeFormat: 4.5ms" aria-roledescription="text mark" transform="translate(67.562 16.5)" font-family="Roboto Mono,monospace" font-size="12" font-weight="bold">4.5ms</text></g></g></svg></p><p><span>Re-computing diagnostics in the language server after editing a file in the<!-- --> <a target="_blank" rel="noreferrer" href="https://github.com/pytorch/pytorch">PyTorch</a> <!-- -->project (<a href="https://github.com/astral-sh/ruff/blob/7f7485d608d2da19a0632a1238f2d4be551f612f/scripts/ty_benchmark/README.md" target="_blank" rel="noreferrer">M4</a>).</span></p></div>
<p>You can install ty today with <code>uv tool install ty@latest</code>, or via our
<a href="https://marketplace.visualstudio.com/items?itemName=astral-sh.ty">VS Code extension</a>.</p>
<p>Like Ruff and uv, ty's implementation was grounded in some of our core product principles:</p>
<ol>
<li>
<p><strong>An obsessive focus on performance.</strong> Without caching, ty is consistently between 10x and 60x
faster than mypy and Pyright. When run in an editor, the gap is even more dramatic. As an
example, after editing a load-bearing file in the PyTorch repository, ty recomputes diagnostics
in 4.7ms: 80x faster than Pyright (386ms) and 500x faster than Pyrefly (2.38 seconds). ty is very
fast!</p>
</li>
<li>
<p><strong>Correct, pragmatic, and ergonomic.</strong> With features like
<a href="https://docs.astral.sh/ty/features/type-system/#intersection-types">first-class intersection types</a>,
<a href="https://docs.astral.sh/ty/features/type-system/#top-and-bottom-materializations">advanced type narrowing</a>,
and
<a href="https://docs.astral.sh/ty/features/type-system/#reachability-based-on-types">sophisticated reachability analysis</a>,
ty pushes forward the state of the art in Python type checking, providing more accurate feedback
and <a href="https://docs.astral.sh/ty/features/type-system/#gradual-guarantee">avoiding assumptions</a>
about user intent that often lead to false positives. Our goal with ty is not only to build a
faster type checker; we want to build a better type checker, and one that balances correctness
with a deep focus on the end-user experience.</p>
</li>
<li>
<p><strong>Built in the open.</strong> ty was built by our core team alongside dozens of active contributors
under the MIT license, and the same goes for our
<a href="https://marketplace.visualstudio.com/items?itemName=astral-sh.ty">editor extensions</a>. You can
run ty anywhere that you write Python (including in the <a href="https://play.ty.dev/">browser</a>).</p>
</li>
</ol>
<p>Even compared to other Rust-based language servers like Pyrefly, ty can run orders of magnitude
faster when performing incremental updates on large projects.</p>
<div><p><video width="100%" preload="none" autoplay="" loop="" muted="" controls="" playsinline=""><source src="https://astral.sh/static/MP4/TyPyTorch.mp4" type="video/mp4">Your browser does not support the video tag.</video></p><p><span>Editing a central file in the<!-- --> <a href="https://github.com/pytorch/pytorch" target="_blank" rel="noreferrer">PyTorch</a> <!-- -->repository with<!-- --> <a href="https://github.com/astral-sh/ty" target="_blank" rel="noreferrer">ty</a> <!-- -->(left) and<!-- --> <a href="https://github.com/facebook/pyrefly" target="_blank" rel="noreferrer">Pyrefly</a> <!-- -->(right). ty's incremental architecture is designed to make live updates extremely fast.</span></p></div>
<p>ty also includes a
<a href="https://docs.astral.sh/ty/features/diagnostics/">best-in-class diagnostic system</a>, inspired by the
Rust compiler's own world-class error messages. A single ty diagnostic can pull in context from
multiple files at once to explain not only what's wrong, but why (and, often, how to fix it).</p>
<div><div><p><span><span></span><img alt="ty diagnostic showing an invalid assignment error to a TypedDict key with reference to the item declaration" srcset="https://astral.sh/_next/image?url=%2Fstatic%2FPNG%2FTyDiagnostic3Light.png&amp;w=3840&amp;q=75 1x" src="https://astral.sh/_next/image?url=%2Fstatic%2FPNG%2FTyDiagnostic3Light.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="intrinsic" loading="lazy" data-old-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"></span></p><p><span><span></span><img alt="ty diagnostic showing an invalid assignment error to a TypedDict key with reference to the item declaration" srcset="https://astral.sh/_next/image?url=%2Fstatic%2FPNG%2FTyDiagnostic3Dark.png&amp;w=3840&amp;q=75 1x" src="https://astral.sh/_next/image?url=%2Fstatic%2FPNG%2FTyDiagnostic3Dark.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="intrinsic" loading="lazy" data-old-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"></span></p></div><p><span>When assigning an invalid value to a dictionary key,<!-- --> <a href="https://github.com/astral-sh/ty" target="_blank" rel="noreferrer">ty</a> <!-- -->surfaces both the type mismatch at the assignment site and the corresponding item declaration.</span></p></div>
<p>Diagnostic output is the primary user interface for a type checker; we prioritized our diagnostic
system from the start (with both humans and agents in mind) and view it as a first-class feature in
ty.</p>
<div><div><p><span><span></span><img alt="ty diagnostic showing an unresolved import error for tomllib module with reference to Python version configuration" srcset="https://astral.sh/_next/image?url=%2Fstatic%2FPNG%2FTyDiagnostic2Light.png&amp;w=3840&amp;q=75 1x" src="https://astral.sh/_next/image?url=%2Fstatic%2FPNG%2FTyDiagnostic2Light.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="intrinsic" loading="lazy" data-old-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"></span></p><p><span><span></span><img alt="ty diagnostic showing an unresolved import error for tomllib module with reference to Python version configuration" srcset="https://astral.sh/_next/image?url=%2Fstatic%2FPNG%2FTyDiagnostic2Dark.png&amp;w=3840&amp;q=75 1x" src="https://astral.sh/_next/image?url=%2Fstatic%2FPNG%2FTyDiagnostic2Dark.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="intrinsic" loading="lazy" data-old-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"></span></p></div><p><span>When importing an unresolved module,<!-- --> <a href="https://github.com/astral-sh/ty" target="_blank" rel="noreferrer">ty</a> <!-- -->surfaces both the unresolved import at the import site and the corresponding Python version configuration.</span></p></div>
<p>If you use VS Code, Cursor, or a similar editor, we recommend installing the
<a href="https://marketplace.visualstudio.com/items?itemName=astral-sh.ty">ty VS Code extension</a>. The ty
language server supports <a href="https://docs.astral.sh/ty/features/language-server/">all the capabilities</a>
that you'd expect for a modern language server (Go to Definition, Symbol Rename, Auto-Complete,
Auto-Import, Semantic Syntax Highlighting, Inlay Hints, etc.), and runs in any editor that
implements the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>.</p>
<p>Following the Beta release, our immediate priority is supporting early adopters. From there, we're
working towards a Stable release next year, with the gap between the
<a href="https://github.com/astral-sh/ty/milestone/2">Beta</a> and
<a href="https://github.com/astral-sh/ty/milestone/4">Stable</a> milestones largely focusing on: (1) stability
and bug fixes, (2) completing the long tail of features in the
<a href="https://github.com/astral-sh/ty/issues/1889">Python typing specification</a>, and (3) first-class
support for popular third-party libraries like <a href="https://pypi.org/project/pydantic/">Pydantic</a> and
<a href="https://pypi.org/project/Django/">Django</a>.</p>
<p>On a longer time horizon, though, ty will power semantic capabilities across the Astral toolchain:
dead code elimination, unused dependency detection, SemVer-compatible upgrade enforcement, CVE
reachability analysis, type-aware linting, and more (including some that are too ambitious to say
out loud just yet).</p>
<p>We want to make Python the most productive programming ecosystem on Earth. Just as with
<a href="https://github.com/astral-sh/ruff">Ruff</a> and <a href="https://github.com/astral-sh/uv">uv</a>, our commitment
from here is that ty will get significantly better every week by working closely with our users.
Thank you for building with us.</p>
<h3><span id="acknowledgements"></span>Acknowledgements<!-- --> <a href="#acknowledgements">#</a></h3>
<p>ty is the most sophisticated product we've built, and its design and implementation have surfaced
some of the hardest technical problems we've seen at Astral. Working on ty requires a deep
understanding of type theory, Python runtime semantics, and how the Python ecosystem actually uses
Python.</p>
<p>I'd like to thank all those that contributed directly to the development of ty, including:
<a href="https://github.com/dcreager">Douglas Creager</a>, <a href="https://github.com/AlexWaygood">Alex Waygood</a>,
<a href="https://github.com/sharkdp">David Peter</a>, <a href="https://github.com/MichaReiser">Micha Reiser</a>,
<a href="https://github.com/BurntSushi">Andrew Gallant</a>, <a href="https://github.com/Gankra">Aria Desires</a>,
<a href="https://github.com/carljm">Carl Meyer</a>, <a href="https://github.com/zanieb">Zanie Blue</a>,
<a href="https://github.com/ibraheemdev">Ibraheem Ahmed</a>,
<a href="https://github.com/dhruvmanila">Dhruv Manilawala</a>, <a href="https://github.com/oconnor663">Jack O'Connor</a>,
<a href="https://github.com/zsol">Zsolt Dollenstein</a>, <a href="https://github.com/mtshiba">Shunsuke Shibayama</a>,
<a href="https://github.com/MatthewMckee4">Matthew Mckee</a>, <a href="https://github.com/ntBre">Brent Westbrook</a>,
<a href="https://github.com/UnboundVariable">UnboundVariable</a>,
<a href="https://github.com/Glyphack">Shaygan Hooshyari</a>, <a href="https://github.com/thejchap">Justin Chapman</a>,
<a href="https://github.com/InSyncWithFoo">InSync</a>, <a href="https://github.com/Bhuminjay-Soni">Bhuminjay Soni</a>,
<a href="https://github.com/abhijeetbodas2001">Abhijeet Prasad Bodas</a>,
<a href="https://github.com/RasmusNygren">Rasmus Nygren</a>, <a href="https://github.com/lipefree">lipefree</a>,
<a href="https://github.com/ericmarkmartin">Eric Mark Martin</a>, <a href="https://github.com/TomerBin">Tomer Bin</a>,
<a href="https://github.com/lucach">Luca Chiodini</a>, <a href="https://github.com/brandtbucher">Brandt Bucher</a>,
<a href="https://github.com/dylwil3">Dylan Wilson</a>, <a href="https://github.com/tyralla">Eric Jolibois</a>,
<a href="https://github.com/felixscherz">Felix Scherz</a>, <a href="https://github.com/leandrobbraga">Leandro Braga</a>,
<a href="https://github.com/nickkuang">Renkai Ge</a>, <a href="https://github.com/brainwane">Sumana Harihareswara</a>,
<a href="https://github.com/TaKO8Ki">Takayuki Maeda</a>, <a href="https://github.com/maxmynter">Max Mynter</a>,
<a href="https://github.com/med1844">med1844</a>, <a href="https://github.com/woodruffw">William Woodruff</a>,
<a href="https://github.com/kiran-4444">Chandra Kiran G</a>, <a href="https://github.com/DetachHead">DetachHead</a>,
<a href="https://github.com/esadek">Emil Sadek</a>, <a href="https://github.com/j178">Jo</a>,
<a href="https://github.com/jorenham">Joren Hammudoglu</a>, <a href="https://github.com/mahmoud">Mahmoud Saada</a>,
<a href="https://github.com/mmlb">Manuel Mendez</a>, <a href="https://github.com/markzding">Mark Z. Ding</a>,
<a href="https://github.com/silamon">Simon Lamon</a>, <a href="https://github.com/suneettipirneni">Suneet Tipirneni</a>,
<a href="https://github.com/fgiacome">Francesco Giacometti</a>,
<a href="https://github.com/adamaaronson">Adam Aaronson</a>, <a href="https://github.com/alpaylan">Alperen Keleş</a>,
<a href="https://github.com/charliecloudberry">charliecloudberry</a>,
<a href="https://github.com/danparizher">Dan Parizher</a>, <a href="https://github.com/danielhollas">Daniel Hollas</a>,
<a href="https://github.com/dsherret">David Sherret</a>, <a href="https://github.com/mdqst">Dmitry</a>,
<a href="https://github.com/ercbot">Eric Botti</a>, <a href="https://github.com/eruditmorina">Erudit Morina</a>,
<a href="https://github.com/frgfm">François-Guillaume Fernandez</a>,
<a href="https://github.com/fabridamicelli">Fabrizio Damicelli</a>,
<a href="https://github.com/Guillaume-Fgt">Guillaume-Fgt</a>, <a href="https://github.com/hugovk">Hugo van Kemenade</a>,
<a href="https://github.com/JosiahKane">Josiah Kane</a>, <a href="https://github.com/LoicRiegel">Loïc Riegel</a>,
<a href="https://github.com/Mathemmagician">Ramil Aleskerov</a>, <a href="https://github.com/s-rigaud">Samuel Rigaud</a>,
<a href="https://github.com/soof-golan">Soof Golan</a>, <a href="https://github.com/Usul-Dev">Usul-Dev</a>,
<a href="https://github.com/decorator-factory">decorator-factory</a>, <a href="https://github.com/omahs">omahs</a>, and
<a href="https://github.com/fatelei">wangxiaolei</a>.</p>
<p>We'd also like to thank the <a href="https://github.com/salsa-rs/salsa">Salsa</a> team (especially
<a href="https://github.com/nikomatsakis">Niko Matsakis</a>, <a href="https://github.com/davidbarsky">David Barsky</a>,
and <a href="https://github.com/veykril">Lukas Wirth</a>) for their support and collaboration; the
<a href="https://github.com/elixir-lang/elixir">Elixir</a> team (especially
<a href="https://github.com/josevalim">José Valim</a>, <a href="https://www.irif.fr/~gc/">Giuseppe Castagna</a>, and
<a href="https://gldubc.github.io/">Guillaume Duboc</a>), whose work strongly influenced our approach to
gradual types and intersections; and a few members of the broader Python typing community:
<a href="https://github.com/erictraut">Eric Traut</a>, <a href="https://github.com/JelleZijlstra">Jelle Zijlstra</a>,
<a href="https://github.com/grievejia">Jia Chen</a>, <a href="https://github.com/samwgoldman">Sam Goldman</a>,
<a href="https://github.com/hauntsaninja">Shantanu Jain</a>, and <a href="https://github.com/stroxler">Steven Troxler</a>.</p>
<p>Finally, on a personal level, I'd like to highlight the core team
(<a href="https://github.com/AlexWaygood">Alex</a>, <a href="https://github.com/BurntSushi">Andrew</a>,
<a href="https://github.com/Gankra">Aria</a>, <a href="https://github.com/carljm">Carl</a>,
<a href="https://github.com/sharkdp">David</a>, <a href="https://github.com/dhruvmanila">Dhruv</a>,
<a href="https://github.com/dcreager">Doug</a>, <a href="https://github.com/ibraheemdev">Ibraheem</a>,
<a href="https://github.com/oconnor663">Jack</a>, and <a href="https://github.com/MichaReiser">Micha</a>), who created ty
from nothing and pushed it to be great from Day 1.</p></article></div>]]></description>
        </item>
        <item>
            <title><![CDATA[No Graphics API (747 pts)]]></title>
            <link>https://www.sebastianaaltonen.com/blog/no-graphics-api</link>
            <guid>46293062</guid>
            <pubDate>Tue, 16 Dec 2025 19:20:17 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://www.sebastianaaltonen.com/blog/no-graphics-api">https://www.sebastianaaltonen.com/blog/no-graphics-api</a>, See on <a href="https://news.ycombinator.com/item?id=46293062">Hacker News</a></p>
<div id="readability-page-1" class="page"><div id="page" role="main">
        
          
            
<article id="sections" data-page-sections="6741ad819bc40a3797cb7348">
  
  
    
    


  
  





<div data-content-field="main-content" data-item-id="" data-test="page-section" data-section-theme="" data-section-id="6741ad819bc40a3797cb734a" data-controller="SectionWrapperController" data-current-styles="{
&quot;imageOverlayOpacity&quot;: 0.15,
&quot;backgroundWidth&quot;: &quot;background-width--full-bleed&quot;,
&quot;sectionHeight&quot;: &quot;section-height--medium&quot;,
&quot;horizontalAlignment&quot;: &quot;horizontal-alignment--center&quot;,
&quot;verticalAlignment&quot;: &quot;vertical-alignment--middle&quot;,
&quot;contentWidth&quot;: &quot;content-width--wide&quot;,
&quot;sectionAnimation&quot;: &quot;none&quot;,
&quot;backgroundMode&quot;: &quot;image&quot;
}" data-current-context="{
&quot;video&quot;: {
&quot;playbackSpeed&quot;: 0.5,
&quot;filter&quot;: 1,
&quot;filterStrength&quot;: 0,
&quot;zoom&quot;: 0,
&quot;videoSourceProvider&quot;: &quot;none&quot;
},
&quot;backgroundImageId&quot;: null,
&quot;backgroundMediaEffect&quot;: null,
&quot;divider&quot;: null,
&quot;typeName&quot;: &quot;blog-basic-grid&quot;
}" data-animation="none">
  <article id="article-">
  
    
    
    
    <div data-layout-label="Post Body" data-type="item" id="item-6741ad819bc40a3797cb7340"><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1735829877825_13469">
  <h2>Introduction</h2><p>My name is Sebastian Aaltonen. I have been writing graphics code for 30 years. I shipped my first 3d accelerated game in 1999. Since then I have been working with almost every gaming console generation (Nokia N-Gage, Nintendo DS/Switch, Sony Playstation/Portable, Microsoft Xbox) and every PC graphics API (DirectX, OpenGL, Vulkan). For the last 4 years I have been building a new renderer for HypeHype targeting WebGPU, Metal (Mac &amp; iOS) and Vulkan (Android). During my career I have been building several Ubisoft internal engines, optimizing Unreal Engine 4 and leading the Unity DOTS graphics team. I am a member of the Vulkan Advisory Panel and an Arm Ambassador.</p><p>This blog post includes lots of low level hardware details. When writing this post I used “GPT5 Thinking” AI model to cross reference public Linux open source drivers to confirm my knowledge and to ensure no NDA information is present in this blog post. Sources: AMD RDNA ISA documents and GPUOpen, Nvidia PTX ISA documents, Intel PRM, Linux open source GPU drivers (Mesa, Freedreno, Turnip, Asahi) and vendor optimization guides/presentations. The blog post has been screened by several industry insiders before the public release.</p><h2>Low-level graphics APIs change the industry</h2><p>Ten years ago, a significant shift occurred in real-time computer graphics with the introduction of new low-level PC graphics APIs. AMD had won both Xbox One (2013) and Playstation 4 (2013) contracts. Their new Graphics Core Next (GCN) architecture became the de-facto lead development platform for AAA games. PC graphics APIs at that time, DirectX 11 and OpenGL 4.5, had heavy driver overhead and were designed for single threaded rendering. AAA developers demanded higher performance APIs for PC. DICE joined with AMD to create a low level AMD GCN specific API for the PC called Mantle. As a response, Microsoft, Khronos and Apple started developing their own low-level APIs: DirectX 12, Vulkan and Metal were born.</p><p>The initial reception of these new low-level APIs was mixed. Synthetic benchmarks and demos showed substantial performance increases, but performance gains couldn’t be seen in major game engines such as Unreal and Unity. At Ubisoft, our teams noticed that porting existing DirectX 11 renderers to DirectX 12 often resulted in performance regression. Something wasn’t right.</p><p>Existing high-level APIs featured minimal persistent state, with fine-grained state setters and individual data inputs bound to the shader just prior to draw call submission. New low-level APIs aimed to make draw calls cheaper by ahead-of-time bundling shader pipeline state and bindings into persistent objects. GPU architectures were highly heterogeneous back in the day. Doing the data remapping, validation, and uploading ahead of time was a big gain. However, the rendering hardware interfaces (RHI) of existing game engines were designed for fine grained immediate mode rendering, while the new low-level APIs required bundling data in persistent objects.</p><p>To address this incompatibility, a new low-level graphics remapping layer grew beneath the RHI. This layer assumed the complexity previously handled by the OpenGL and DirectX 11 graphics drivers, tracking resources and managing mappings between the fine-grained dynamic user-land state and the persistent low-level GPU state. Graphics programmers started specializing into two distinct roles: low-level graphics programmers, who focused on the new low-level “driver” layer and the RHI, and high-level graphics programmers, who built visual graphics algorithms on top of the RHI. Visual programming was also getting more complex due to physically based lighting models, compute shaders and later ray-tracing.&nbsp;</p><h2>Modern APIs?</h2><p>DirectX 12, Vulkan, and Metal are often referred to as “modern APIs”. These APIs are now 10 years old. They were initially designed to support GPUs that are now 13 years old, an incredibly long time in GPU history. Older GPU architectures were optimized for traditional vertex and pixel shader tasks rather than the compute-intensive generic workloads prevalent today. They had vendor specific binding models and data paths. Hardware differences had to be wrapped under the same API. Ahead-of-time created persistent objects were crucial in offloading the mapping, uploading, validation and binding costs.</p><p>In contrast, the console APIs and Mantle were exclusively designed for AMD's GCN architecture, a forward-thinking design for its time. GCN boasted a comprehensive read/write cache hierarchy and scalar registers capable of storing texture and buffer descriptors, effectively treating everything as memory. No complex API for remapping the data was required, and significantly less ahead-of-time work was needed. The console APIs and Mantle had much less API complexity due to targeting a single modern GPU architecture.</p><p>A decade has passed, and GPUs have undergone a significant evolution. All modern GPU architectures now feature complete cache hierarchies with coherent last-level caches. CPUs can write directly to GPU memory using PCIe REBAR or UMA and 64-bit GPU pointers are directly supported in shaders. Texture samplers are bindless, eliminating the need for a CPU driver to configure the descriptor bindings. Texture descriptors can be directly stored in arrays within the GPU memory (often called descriptor heaps). If we were to design an API tailored for modern GPUs today, it wouldn’t need most of these persistent “retained mode” objects. The compromises that DirectX 12.0, Metal 1 and Vulkan 1.0 had to make are not needed anymore. We could simplify the API drastically.</p><p>The past decade has revealed the weaknesses of the modern APIs. The PSO permutation explosion is the biggest problem we need to solve. Vendors (Valve, Nvidia, etc) have massive cloud servers storing terabytes of PSOs for each different architecture/driver combination. User's local PSO cache size can exceed 100GB. No wonder the gamers are complaining that loading takes ages and stutter is all over the place.</p><h2>The history of GPUs and APIs</h2><p>Before we talk about stripping the API surface, we need to understand why graphics APIs were historically designed this way. OpenGL wasn't intentionally slow, nor was Vulkan intentionally complex. 10-20 years ago GPU hardware was highly diverse and undergoing rapid evolution. Designing a cross-platform API for such a diverse set of hardware required compromises.</p><p>Let’s start with a classic: The 3dFX Voodoo 2 12MB (1998) was a three chip design: A single rasterizer chip connected to a 4MB framebuffer memory and two texture sampling chips, each connected to their own 4MB texture memory. There was no geometry pipeline and no programmable shaders. CPU sent pre-transformed triangle vertices to the rasterizer. The rasterizer had a configurable blending equation to control how the vertex colors and the two texture sampler results were combined together. Texture samplers could not read each-other’s memory or the framebuffer. Thus there was no support for multiple render passes. Since the hardware was incapable of window composition, it had a loopback cable to connect your dedicated 2d video card. 3d rendering only worked in exclusive fullscreen mode. A 3d graphics card was a highly specialized piece of hardware, with little in common with the current GPUs and their massive programmable SIMD arrays. Hardware of this era had a massive impact on DirectX (1995) and OpenGL (1992) design. Backwards compatibility played a huge role. APIs improved iteratively. These 30 year old API designs still impact the way we write software today.</p>
</div><div data-test="image-block-inline-outer-wrapper" data-aspect-ratio="57.3346116970278" data-block-type="5" id="block-yui_3_17_2_1_1732357558950_5657">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-stretch="false" data-src="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg" data-image="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg" data-image-dimensions="1200x688" data-image-focal-point="0.5,0.5" alt="" data-load="false" elementtiming="system-image-block" src="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg" width="1200" height="688" sizes="(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw" onload="this.classList.add(&quot;loaded&quot;)" srcset="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg?format=100w 100w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg?format=300w 300w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg?format=500w 500w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg?format=750w 750w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/7411bc9f-22bc-4ca8-b664-78c2edaa6684/voodoo2.jpg?format=2500w 2500w" loading="lazy" decoding="async" data-loader="sqs">

            </p>
          </div>
        
          
        

        
          
          <figcaption>
            <p data-rte-preserve-empty="true">3dFX Voodoo 2 12MB (1998): Individual processors and traces between them and their own memory chips (four 1MB chips for each processor) are clearly visible. Image © TechPowerUp.</p>
          </figcaption>
        
      
        </figure>
      

    </div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765887159238_91097">
  <p>Nvidia’s Geforce 256 coined the term GPU. It had a geometry processor in addition to the rasterizer. The geometry processor, rasterizer and texture sampling units were all integrated in the same die and shared memory. DirectX 7 introduced two new concepts: render target textures and uniform constants. Multipass rendering meant that texture samplers could read the rasterizer output, invalidating the 3dFX Voodoo 2 separate memory design.</p><p>The geometry processor API featured uniform data inputs for transform matrices (float4x4), light positions, and colors (float4). GPU implementations varied among manufacturers, many opting to embed a small constant memory block within the geometry engine. But this wasn’t the only way to do it. In the OpenGL API each shader had its own persistent uniforms. This design enabled the driver to embed constants directly in the shader's instruction stream, an API peculiarity that still persists in OpenGL 4.6 and ES 3.2 today.</p><p>GPUs back then didn’t have generic read &amp; write caches. Rasterizer had screen local cache for blending and depth buffering and texture samplers leaned on linearly interpolated vertex UVs for data prefetching. When shaders were introduced in DirectX 8 shader model 1.0 (SM 1.0), the pixel shader stage didn’t support calculating texture UVs. UVs were calculated at vertex granularity, interpolated by the hardware and passed directly to the texture samplers.&nbsp;</p><p>DirectX 9 brought a substantial increase in shader instruction limits, but shader model 2.0 didn’t expose any new data paths. Both vertex and pixel shaders still operated as 1:1 input:output machines, allowing users to only customize the transform math of the vertex position and attributes and the pixel color. Programmable load and store were not supported. The fixed-function input blocks persisted: vertex fetch, uniform (constant) memory and texture sampler. Vertex shader was a separate execution unit. It gained new features like the ability to index constants (limited to float4 arrays) but still lacked texture sampling support.</p><p>DirectX 9 shader model 3.0 increased the instruction limit to 65536 making it difficult for humans to write and maintain shader assembly anymore. Higher level shading languages were born: HLSL (2002) and GLSL (2002-2004). These languages adapted the 1:1 elementwise transform design. Each shader invocation operated on a single data element: vertex or pixel. Framework-style shader design heavily affected the graphics API design in the following years. It was a nice way to abstract hardware differences back in the day, but is showing scaling pains today.&nbsp;</p><p>DirectX 11 was a significant shift in the data model, introducing support for compute shaders, generic read-write buffers and indirect drawing. The GPU could now fully feed itself. The inclusion of generic buffers enabled shader programs to access and modify programmable memory locations, which forced hardware vendors to implement generic cache hierarchies. Shaders evolved beyond simple 1:1 data transformations, marking the end of specialized, hardcoded data paths. GPU hardware started to shift towards a generic SIMD design. SIMD units were now executing all the different shader types: vertex, pixel, geometry, hull, domain and compute. Today the framework has 16 different shader entry points. This adds a lot of API surface and makes composition difficult. As a result GLSL and HLSL still don’t have a flourishing library ecosystem.</p><p>DirectX 11 featured a whole zoo of buffer types, each designed to accommodate specific hardware data path peculiarities: typed SRV &amp; UAV, byte address SRV &amp; UAV, structured SRV &amp; UAV, append &amp; consume (with counter), constant, vertex, and index buffers. Like textures, buffers in DirectX utilize an opaque descriptor. Descriptors are hardware specific (commonly 128-256 bit) data blobs encoding the size, format, properties and data address of the resource in GPU memory. DirectX 11 GPUs leveraged their texture samplers for buffer load (gather) operations. This was natural since the sampler already had a type conversion hardware and a small read-only data cache. Typed buffers supported the same formats as textures, and DirectX used the same SRV (shader resource view) abstraction for both textures and buffers.</p><p>The use of opaque buffer descriptors meant that the buffer format was not known at shader compile time. This was fine for read-only buffers as they were handled by the texture sampler. Read-write buffer (UAV in DirectX) was initially limited to 32-bit and 128-bit (vec4) types. Subsequent API and hardware revisions gradually addressed typed UAV load limitations, but the core issues persisted: a descriptor requires an indirection (contains a pointer), compiler optimizations are limited (data type is known only at runtime), format conversion hardware introduces latency (vs raw L1$&nbsp;load), expand at load reserves registers for longer time (vs expand at use), descriptor management adds CPU driver complexity, and the API is complex (ten different buffer types).</p><p>In DirectX 11 the structured buffers were the only buffer type allowing an user defined struct type. All other buffer types represented a homogeneous array of simple scalar/vector elements. Unfortunately, structured buffers were not layout compatible with other buffer types. Users were not allowed to have structured buffer views to typed buffers, byte address buffers, or vertex/index buffers. The reason was that structured buffers had special AoSoA swizzle optimization under the hood, which was important for older vec4 architectures. This hardware specific optimization limited the structured buffer usability.</p><p>DirectX 12 made all buffers linear in memory, making them compatible with each other. SM 6.2 also added load&lt;T&gt; syntactic sugar for the byte address buffer, allowing clean struct loading syntax from arbitrary offset. All the old buffer types are still supported for backwards compatibility reasons and all the buffers still use opaque descriptors. HLSL is still missing support for 64-bit GPU pointers. In contrast, the Nvidia CUDA computing platform (2007) fully leaned on 64-bit pointers, but its popularity was initially limited to academic use. Today it is the leading AI platform and is heavily affecting the hardware design.</p><p>Support for 16-bit registers and 16-bit math was disorganized when DirectX 12 launched. Microsoft initially made a questionable decision to not backport DirectX 12 to Windows 7. Shader binaries targeting Windows 8 supported 16-bit types, but most gamers continued using Windows 7. Developers didn’t want to ship two sets of shaders. OpenGL lowp/mediump specification was also messy. Bit depths were not properly standardized. Mediump was a popular optimization in mobile games, but most PC drivers ignored it, making game developer’s life miserable. AAA games mostly ignored 16-bit math until PS4 Pro launched in 2016 with double rate fp16 support.</p><p>With the rise of AI, ray-tracing, and GPU-driven rendering, GPU vendors started focusing on optimizing their raw data load paths and providing larger and faster generic caches. Routing loads though the texture sampler (type conversion) added too much latency, as dependent load chains are common in modern shaders. Hardware got native support for narrow 8-bit, 16-bit, and 64-bit types and pointers.</p><p>Most vendors ditched their fixed function vertex fetch hardware, emitting standard raw load instructions in the vertex shader instead. Fully programmable vertex fetch allowed developers to write new algorithms such as clustered GPU-driven rendering. Fixed function hardware transistor budget could be used elsewhere.</p><p>Mesh shaders represent the culmination of rasterizer evolution, eliminating the need for index deduplication hardware and post-transform caches. In this paradigm, all inputs are treated as raw memory. The user is responsible for dividing the mesh into self-contained meshlets that internally share vertices. This process is often done offline. The GPU no longer needs to do parallel index deduplication for each draw call, saving power and transistors. Given that gaming accounts for only 10% of Nvidia's revenue today, while AI represents 90% and ray-tracing continues to grow, it is likely only a matter of time before the fixed function geometry hardware is stripped to bare minimum and drivers automatically convert vertex shaders to mesh shaders.</p><p>Mobile GPUs are tile-based renderers. Tilers bin the individual triangles to small tiles (commonly between 16x16 to 64x64 pixels) . Mesh shaders are too coarse grained for this purpose. Binning meshlets to tiny tiles would cause significant geometry overshading. There’s no clear convergence path. We still need to support the vertex shader path.</p><p>10 years ago when DirectX 12.0, Vulkan 1.0 and Metal 1.0 arrived, the existing GPU hardware didn’t widely support bindless resources. APIs adapted complex binding models to abstract the hardware differences. DirectX allowed indexing up to 128 resources per stage, Vulkan and Metal didn’t initially support descriptor indexing at all. Developers had to continue using traditional workarounds to reduce the bindings change overhead, such as packing textures into atlases and merging meshes together. The GPU hardware has evolved significantly during the past decade and converged to generic bindless SIMD design.</p><p>Let’s investigate how much simpler the graphics API and the shader language would become if we designed them solely for modern bindless hardware.</p><h2>Modern GPU memory management</h2><p>Let’s start our journey discussing memory management. Legacy graphics APIs abstracted the GPU memory management completely. Abstraction was necessary, as old GPUs had split memories and/or special data paths with various cache coherency concerns. When DirectX 12 and Vulkan arrived 10 years ago, the GPU hardware had matured enough to expose placement heaps to the user. Consoles had already exposed memory for a few generations and developers requested similar flexibility for PC and mobile. Apple introduced placement heaps 4 years after Vulkan and DirectX 12 in Metal 2.</p><p>Modern APIs require the user to enumerate the heap types to find out what kind of memory the GPU driver has to offer. It’s a good practice to preallocate memory in big chunks and suballocate it using a user-land allocator. However, there’s a design flaw in Vulkan: You have to create your texture/buffer object first. Then you can ask which heap types are compatible with the new resource. This forces the user into a lazy allocation pattern, which can cause performance hitches and memory spikes at runtime. This also makes it difficult to wrap a GPU memory allocation into a cross-platform library. AMD VMA, for example, creates both the Vulkan-specific buffer/texture object in addition to allocating memory. We want to fully separate these concerns.</p><p>Today the CPU has full visibility into the GPU memory. Integrated GPUs have UMA, and modern discrete GPUs have PCIe Resizable BAR. The whole GPU heap can be mapped. Vulkan heap API naturally supports CPU mapped GPU heaps. DirectX 12 got support in 2023 (HEAP_TYPE_GPU_UPLOAD).</p><p>CUDA has a simple design for GPU memory allocation: The GPU malloc API takes the size as input and returns a mapped CPU pointer. The GPU free API frees the memory. CUDA doesn’t support CPU mapped GPU memory. The GPU reads the CPU memory though the PCIe bus. CUDA also supports GPU memory allocations, but they can’t be directly written by the CPU.</p><p>We combine CUDA malloc design with CPU mapped GPU memory (UMA/ReBAR). It's the best of both worlds: The data is fast for the CPU to write and fast for the GPU to read, yet we maintain the clean, easy to use design.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_55741"><pre><code>// Allocate GPU memory for array of 1024 uint32
uint32* numbers = gpuMalloc(1024 * sizeof(uint32));

// Directly initialize (CPU mapped GPU pointer)
for (int i = 0; i &lt; 1024; i++) numbers[i] = random();

gpuFree(numbers);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_55803">
  <p>Default gpuMalloc alignment is 16 bytes (vec4 alignment). If you need wider alignment use gpuMalloc(size, alignment) overload. My example code uses gpuMalloc&lt;T&gt; wrapper, doing gpuMalloc(elements * sizeof(T), alignof(T)). </p><p>Writing data directly into GPU memory is optimal for small data like draw arguments, uniforms and descriptors. For large persistent data, we still want to perform a copy operation. GPUs store textures in a swizzled layout similar to Morton-order to improve cache locality. DirectX 11.3 and 12 tried to standardize the swizzle layout, but couldn’t get all GPU manufacturers onboard. The common way to perform texture swizzling is to use a driver provided copy command. The copy command reads linear texture data from a CPU mapped “upload” heap and writes to a swizzled layout in a private GPU heap. Every modern GPU also has lossless delta color compression (DCC). Modern GPUs copy engines are capable of DCC compression and decompression. DCC and Morton swizzle are the main reasons we want to copy textures into a private GPU heap. Recently, GPUs have also added generic lossless memory compression for buffer data. If the memory heap is CPU mapped, the GPU can’t enable vendor specific lossless compression, as the CPU wouldn’t know how to read or write it. A copy command must be used to compress the data.</p><p>We need a memory type parameter in the GPU malloc function to add support for private GPU memory. The standard memory type should be CPU mapped GPU memory (write combined CPU access). It is fast for the GPU to read, and the CPU can directly write to it just like it was a CPU memory pointer. GPU-only memory is used for textures and big GPU-only buffers. The CPU can’t directly write to these GPU pointers. The user writes the data to CPU mapped GPU memory first and then issues a copy command, which transforms the data to optimal compressed format. Modern texture samplers and display engines can read compressed GPU data directly, so there’s no need for subsequent data layout transforms (see chapter: Modern barriers). The uploaded data is ready to use immediately.</p><p>We have two types of GPU pointers, a CPU mapped virtual address and a GPU virtual address. The GPU can only dereference GPU addresses. All pointers in GPU data structures must use GPU addresses. CPU mapped addresses are only used for CPU writes. CUDA has an API to transform a CPU mapped address to a GPU address (cudaHostGetDevicePointer). Metal 4 buffer object has two getters: .contents (CPU mapped address) and .gpuAddress (GPU address). Since the gpuMalloc API returns a pointer, not a managed object handle (like Metal), we choose the CUDA approach (gpuHostToDevicePointer). This API call is not free. The driver likely implements it using a hash map (if other than base addresses need to be translated, we need a tree). Preferably we call the address translation once per allocation and cache in a user land struct (void *cpu, void *gpu). This is the approach my userland GPUBumpAllocator uses (see appendix for full implementation).</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_119073"><pre><code>// Load a mesh using a 3rd party library
auto mesh = createMesh("mesh.obj");
auto upload = uploadBumpAllocator.allocate(mesh.byteSize); // Custom bump allocator (wraps a gpuMalloc ptr)
mesh.load(upload.cpu);

// Allocate GPU-only memory and copy into it
void* meshGpu = gpuMalloc(mesh.byteSize, MEMORY_GPU);
gpuMemCpy(commandBuffer, meshGpu, upload.gpu);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_120697">
  <p>Vulkan recently got a new extension called VK_EXT_host_image_copy. The driver implements a direct CPU to GPU image copy operation, performing the hardware specific texture swizzle on CPU. This extension is currently only available on UMA architectures, but there’s no technical reason why it’s not available on PCIe ReBAR as well. Unfortunately this API doesn’t support DCC. It would be too expensive to perform DCC compression on the CPU. The extension is mainly useful for block compressed textures, as they don’t require DCC. It can’t universally replace hardware copy to GPU private memory.</p><p>There’s also a need for a third memory type, CPU-cached, for readback purposes. This memory type is slower for the GPU to write due to cache coherency with the CPU. Games only use readback seldomly. Common use cases are screenshots and virtual texturing readback. GPGPU algorithms such as AI training and inference lean on efficient communication between the CPU and the GPU.</p><p>When we mix the simplicity of CUDA malloc with CPU-mapped GPU memory we get a flexible and fast GPU memory allocation system with minimal API surface. This is an excellent starting point for a minimalistic modern graphics API.</p><h2>Modern data</h2><p>CUDA, Metal and OpenCL leverage C/C++ shader languages featuring 64-bit pointer semantics. These languages support loading and storing of structs from/to any appropriately aligned GPU memory location. The compiler handles behind-the-scenes optimizations, including wide loads (combine), register mappings, and bit extractions. Many modern GPUs offer free instruction modifiers for extracting 8/16-bit portions of a register, allowing the compiler to pack 8-bit and 16-bit values into a single register. This keeps the shader code clean and efficient.</p><p>If you load a struct of eight 32-bit values, the compiler will most likely emit two 128-bit wide loads (each filling 4 registers), a 4x reduction in load instruction count. Wide loads are significantly faster, especially if the struct contains narrow 8 and 16-bit fields. GPUs are ALU dense and have big register files, but compared to CPUs their memory paths are relatively slow. A CPU often has two load ports each doing a load per cycle. On a modern GPU we can achieve one SIMD load per 4 cycles. Wide load + unpack in the shader is often the most efficient way to handle data.&nbsp;</p><p>Compact 8-16 bit data has been traditionally stored in texel buffers (Buffer&lt;T&gt;) in DirectX games. Modern GPUs are optimized for compute workloads. Raw buffer load instructions nowadays have up to 2x higher throughput and up to 3x lower latency than texel buffers. Texel buffers are no longer the optimal choice on modern GPUs. Texel buffers do not support structured data, the user is forced to split their data into SoA layout in multiple texel buffers. Each texel buffer has its own descriptor, which must be loaded before the data can be accessed. This consumes resources (SGPRs, descriptor cache slots) and adds startup latency compared to using a single 64-bit raw pointer. SoA data layout also results in significantly more cache misses for non-linear index lookups (examples: material, texture, triangle, instance, bone id). Texel buffers offer free conversion of normalized ([0,1] and [-1,1]) types to floating point registers. It’s true that there’s no ALU cost, but you lose wide load support (combine loads) and the instruction goes through the slow texture sampler hardware path. Narrow texel buffer loads also add register bloat. RGBA8_UNORM load to vec4 allocates four vector registers immediately. The sampler hardware will eventually write the value to these registers. Compilers try to maximize the distance of load→use by moving load instructions in the beginning of the shader. This hides the load latency by ALU and allows overlapping multiple loads. If we instead use wide raw loads, our uint8x4 data consumes just a single 32-bit register. We unpack the 8-bit channels on use. The register life time is much shorter. Modern GPUs can directly access 16-bit low/high halves of registers without unpack, and some can even do 8-bit (AMD SDWA modifier). Packed double rate math makes 2x16 bit conversion instructions faster. Some GPU architectures (Nvidia, AMD) can also do 64-bit pointer raw loads directly from VRAM into groupshared memory, further reducing the register bloat needed for latency hiding. By using 64-bit pointers, game engines benefit from AI hardware optimizations.</p><p>Pointer based systems make memory alignment explicit. When you are allocating a buffer object in DirectX or Vulkan, you need to query the API for alignment. Buffer bind offsets must also be properly aligned. Vulkan has an API for querying the bind offset alignment and DirectX has fixed alignment rules. Alignment contract allows the low level shader compiler to emit optimal code  (such as aligned 4x32-byte wide loads). The DirectX ByteAddressBuffer abstraction has a design flaw: load2, load3 and load4 instructions only require 4-byte alignment. The new SM 6.2 load&lt;T&gt; also only requires elementwise alignment (half4 = 2, float4 = 4). Some GPU vendors (like Nvidia) have to split ByteAddressBuffer.load4 into four individual load instructions. The buffer abstraction can’t always shield the user from bad codegen. It makes bad codegen hard to fix. C/C++ based languages (CUDA, Metal) allow the user to explicitly declare struct alignment with the alignas attribute. We use alignas(16) in all our example code root structs.</p><p>By default, GPU writes are only visible to the threads inside the same thread group (= inside a compute unit). This allows non-coherent L1$ design. Visibility is commonly provided by barriers. If the user needs memory visibility between the groups in a single dispatch, they decorate the buffer binding with the [globallycoherent] attribute. The shader compiler emits coherent load/store instructions for accesses of that buffer. Since we use 64-bit pointers instead of buffer objects, we offer explicit coherent load/store instructions. The syntax is similar to atomic load/store. Similarly we can provide non-temporal load/store instructions that bypass the whole cache hierarchy.</p><p>Vulkan supports 64-bit pointers using the (2019) VK_KHR_buffer_device_address extension (<a href="https://docs.vulkan.org/samples/latest/samples/extensions/buffer_device_address/README.html"><span>https://docs.vulkan.org/samples/latest/samples/extensions/buffer_device_address/README.html</span></a>). Buffer device address extension is widely supported by all GPU vendors (including mobile), but is not a part of core Vulkan 1.4. The main issue with BDA is lack of pointer support in the GLSL and the HLSL shader languages. The user has to use raw 64-bit integers instead. A 64-bit integer can be cast to a struct. Structs are defined with custom BDA syntax. Array indexing requires declaring an extra BDA struct type with an array in it, if the user wants the compiler to generate the index addressing math. Debugging support is currently limited. Usability matters a lot and BDA will remain a niche until HLSL and GLSL support pointers natively. This is a stark contrast to CUDA, OpenCL and Metal, where native pointer support is a language core pillar and debugging works flawlessly.&nbsp;</p><p>DirectX 12 has no support for pointers in shaders. As a consequence, HLSL doesn’t allow passing arrays as function parameters. Simple things like having a material array inside UBO/SSBO requires hacking around with macros. It’s impossible to make reusable functions for reductions (prefix sum, sort, etc), since groupshared memory arrays can’t be passed between functions. You could of course declare a separate global array for each utility header/library, but the compiler will allocate groupshared memory for each of them separately, reducing occupancy. There’s no easy way to alias groupshared memory. GLSL has identical issues. Pointer based languages like CUDA and Metal MSL don’t have such issues with arrays. CUDA has a vast ecosystem of 3rd party libraries, and this ecosystem makes Nvidia the most valued company on the planet. Graphics shading languages need to evolve to meet modern standards. We need a library ecosystem too.</p><p>I will be using a C/C++ style shading language similar to CUDA and Metal MSL in my examples, with some HLSL-style system value (SV) semantics mixed in for the graphics specific bits and pieces.</p><h2>Root arguments</h2><p>Operating system threading APIs commonly provide a single 64-bit void pointer to the thread function. The operating system doesn’t care about the user’s data input layout. Let’s apply the same ideology to the GPU kernel data inputs. The shader kernel receives a single 64-bit pointer, which we cast to our desired struct (by the kernel function signature). Developers can use the same shared C/C++ header in both CPU and GPU side.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_282276"><pre><code>// Common header...
struct alignas(16) Data
{
    // Uniform data
    float16x4 color; // 16-bit float vector
    uint16x2 offset; // 16-bit integer vector
    const uint8* lut; // pointer to 8-bit data array

    // Pointers to in/out data arrays
    const uint32* input;
    uint32* output;
};

// CPU code...
gpuSetPipeline(commandBuffer, computePipeline);

auto data = myBumpAllocator.allocate&lt;Data&gt;(); // Custom bump allocator (wraps gpuMalloc ptr, see appendix)
data.cpu-&gt;color = {1.0f, 0.0f, 0.0f, 1.0f};
data.cpu-&gt;offset = {16, 0};
data.cpu-&gt;lut = luts.gpu + 64; // GPU pointers support pointer math (no need for offset API)
data.cpu-&gt;input = input.gpu;
data.cpu-&gt;output = output.gpu;

gpuDispatch(commandBuffer, data.gpu, uvec3(128, 1, 1));

// GPU kernel...
[groupsize = (64, 1, 1)]
void main(uint32x3 threadId : SV_ThreadID, const Data* data)
{
    uint32 value = data-&gt;input[threadId.x]; 
    // TODO: Code using color, offset, lut, etc...
    data-&gt;output[threadId.x] = value;
}</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_283855">
  <p>In the example code we use a simple linear bump allocator (myBumpAllocator) for allocating GPU arguments (see appendix for implementation). It returns a struct {void* cpu, void *gpu}. The CPU pointer is used for writing directly to persistently mapped GPU memory and the GPU pointer can be stored to GPU data structures or passed as dispatch command argument.&nbsp;</p><p>Most GPUs preload root uniforms (including 64-bit pointers) into constant or scalar registers just before launching a wave. This optimization remains viable: the draw/dispatch command carries the base data pointer. All the input uniforms (including pointers to other data) are found at small fixed offsets from the base pointer. Since shaders are pre-compiled and further optimized into device-specific microcode during the PSO creation, drivers have ample opportunity to set up register preloading and similar root data optimizations. Users should put the most important data in the beginning of the root struct as root data size is limited in some architectures. Our root struct has no hard size limit. The shader compiler will emit standard (scalar/uniform) memory loads for the remaining fields. The root data pointer provided to the shader is const. Shader can’t modify the root input data, as it might be still used by the command processor for preloading data to new waves. Output is done through non-const pointers (see Data::output in above example). By forcing the root data to be const, we also allow GPU drivers to perform their special uniform data path optimizations. </p><p>Do we need a special uniform buffer type? Modern shader compilers perform automatic uniformity analysis. If all inputs to an instruction are uniform, the output is also uniform. Uniformity propagates over the shader. All modern architectures have scalar registers/loads or a similar construct (SIMD1 on Intel). Uniformity analysis is used to convert vector loads into scalar loads, which saves registers and reduces latency. Uniformity analysis doesn’t care about the buffer type (UBO vs SSBO). The resource must be readonly (this is why you should always decorate SSBO with readonly attribute in GLSL or prefer SRV over UAV in DirectX 12). The compiler also needs to be able to prove that the pointer is not aliased. The C/C++ const keyword means that data can’t be modified though this pointer, it doesn’t guarantee that other read-write pointers might alias the same memory region. C99 added the restrict keyword for this purpose and CUDA kernels use it frequently. Root pointers in Metal are no-alias (restrict) by default, and so are buffer objects in Vulkan and DirectX 12. We should adopt the same convention to give the compiler more freedom to do optimizations. </p><p>The shader compiler is not always able to prove address uniformity at compile time. Modern GPUs opportunistically optimize dynamic uniform address loads. If the memory controller detects that all lanes of a vector load instruction have a uniform address, it emits a single lane load instead of a SIMD wide gather. The result is replicated to all lanes. This optimization is transparent, and doesn’t affect shader code generation or register allocation. Dynamically uniform data is a much smaller performance hit than it used to be in the past, especially when combined with the new fast raw load paths.</p><p>Some GPU vendors (ARM Mali and Qualcomm Adreno) take the uniformity analysis a step further. The shader compiler extracts uniform loads and uniform math. A scalar preamble runs before the shader. Uniform memory loads and math is executed once for the whole draw/dispatch and the results are stored in special hardware constant registers (the same registers used by root constants).</p><p>All of the above optimizations together provide a better way of handling uniform data than the classic 16KB/64KB uniform/constant buffer abstraction. Many GPUs still have special uniform registers for root constants, system values and the preamble (see above paragraph).</p><h2>Texture bindings</h2><p>Ideally, texture descriptors would behave like any other data in GPU memory, allowing them to be freely mixed in structs with other data. However, this level of flexibility isn't universally supported by all modern GPUs. Fortunately bindless texture sampler designs have converged over the last decade, with only two primary methods remaining: 256-bit raw descriptors and the indexed descriptor heap.</p><p>AMDs raw descriptor method loads 256-bit descriptors directly from GPU memory into the compute unit’s scalar registers. Eight subsequent 32-bit scalar registers contain a single descriptor. During the SIMD texture sample instruction, the shader core sends a 256-bit texture descriptor and per-lane UVs to the sampler unit. This provides the sampler all the data it needs to address and load texels without any indirections. The drawback is that the 256-bit descriptor takes a lot of register space and needs to be resent to the sampler for each sample instruction.</p><p>The indexed descriptor heap approach uses 32-bit indices (20 bits for old Intel iGPUs). 32-bit indices are trivial to store in structs, load into standard SIMD registers and efficient to pass around. During a SIMD sample instruction, the shader core sends the texture index and the per-lane UVs to the sampler unit. The sampler fetches the descriptor from the descriptor heap: heap base address + texture index * stride (256-bits in modern GPUs). The texture heap base address is either abstracted by the driver (Vulkan and Metal) or provided by the user (SetDescriptorHeaps in DirectX 12). Changing the texture heap base address may result in an internal pipeline barrier (on older hardware). On modern GPUs the texture heap 64-bit base address is often part of each sample instruction data, allowing sampling from multiple heaps seamlessly (64-bit base + 32-bit offset per lane). The sampler unit has a tiny internal descriptor cache to avoid indirect reads after the first access. Descriptor caches must be invalidated whenever the descriptor heap is modified.</p><p>A few years ago it looked like AMDs scalar register based texture descriptors were the winning formula in the long run. Scalar registers are more flexible than a descriptor heap, allowing descriptors to be embedded inside GPU data structures directly. But there’s a downside. Modern GPU workloads such as ray-tracing and deferred texturing (Nanite) lean on non-uniform texture indices. The texture heap index is not uniform over a SIMD wave. A 32-bit heap index is just 4 bytes, we can send it per lane. In contrast, a 256-bit descriptor is 32 bytes. It is not feasible to fetch and send a full 256-bit descriptor per lane. Modern Nvidia, Apple and Qualcomm GPUs support per-lane descriptor index mode in their sample instructions, making the non-uniform case more efficient. The sampler unit performs an internal loop if required. Inputs/outputs to/from sampler units are sent once, regardless of the heap index coherence. AMDs scalar register based descriptor architecture requires the shader compiler to generate a scalarization loop around the texture sample instruction. This costs extra ALU cycles and requires sending and receiving (partially masked) sampler data multiple times. It’s one of the reasons why Nvidia is faster in ray-tracing than AMD. ARM and Intel use 32-bit heap indices too (like Nvidia, Qualcomm and Apple), but their latest architectures don’t yet have a per-lane heap index mode. They emit a similar scalarization loop as AMD for the non-uniform index case.</p><p>All of these differences can be wrapped under an unified texture descriptor heap abstraction. The de-facto texture descriptor size is 256 bits (192 bits on Apple for a separate texture descriptor, sampler is the remaining 32 bits). The texture heap can be presented as a homogeneous array of 256-bit descriptor blobs. Indexing is trivial. DirectX 12 shader model 6.6 provides a texture heap abstraction like this, but doesn’t allow direct CPU or compute shader write access to the descriptor heap memory. A set of APIs are used for creating descriptors and copying descriptors from the CPU to the GPU. The GPU is not allowed to write the descriptors. Today, we can remove this API abstraction completely by allowing direct CPU and GPU write to the descriptor heap. All we need is a simple (user-land) driver helper function for creating a 256-bit (uint64[4]) hardware specific descriptor blob. Modern GPUs have UMA or PCIe ReBAR. The CPU can directly write descriptor blobs into GPU memory. Users can also use compute shaders to copy or generate descriptors. The shader language has a descriptor creation intrinsic too. It returns a hardware specific uint64x4 descriptor blob (analogous to the CPU API). This approach cuts the API complexity drastically and is both faster and more flexible than the DirectX 12 descriptor update model. Vulkan’s VK_EXT_descriptor_buffer (<a href="https://www.khronos.org/blog/vk-ext-descriptor-buffer"><span>https://www.khronos.org/blog/vk-ext-descriptor-buffer</span></a>) extension (2022) is similar to my proposal, allowing direct CPU and GPU write. It is supported by most vendors, but unfortunately is not part of the Vulkan 1.4 core spec.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_380784"><pre><code>// App startup: Allocate a texture descriptor heap (for example 65536 descriptors)
GpuTextureDescriptor *textureHeap = gpuMalloc&lt;GpuTextureDescriptor&gt;(65536);

// Load an image using a 3rd party library
auto pngImage = pngLoad("cat.png");
auto uploadMemory = uploadBumpAllocator.allocate(pngImage.byteSize); // Custom bump allocator (wraps gpuMalloc ptr)
pngImage.load(uploadMemory.cpu);

// Allocate GPU memory for our texture (optimal layout with metadata)
GpuTextureDesc textureDesc { .dimensions = pngImage.dimensions, .format = FORMAT_RGBA8_UNORM, .usage = SAMPLED };
GpuTextureSizeAlign textureSizeAlign = gpuTextureSizeAlign(textureDesc);
void *texturePtr = gpuMalloc(textureSizeAlign.size, textureSizeAlign.align, MEMORY_GPU);
GpuTexture texture = gpuCreateTexture(textureDesc, texturePtr);

// Create a 256-bit texture view descriptor and store it
textureHeap[0] = gpuTextureViewDescriptor(texture, { .format = FORMAT_RGBA8_UNORM });

// Batched upload: begin
GpuCommandBuffer uploadCommandBuffer = gpuStartCommandRecording(queue);

// Copy all textures here!
gpuCopyToTexture(uploadCommandBuffer, texturePtr, uploadMemory.gpu, texture);
// TODO other textures...

// Batched upload: end
gpuBarrier(uploadCommandBuffer, STAGE_TRANSFER, STAGE_ALL, HAZARD_DESCRIPTORS);
gpuSubmit(queue, { uploadCommandBuffer });

// Later during rendering...
gpuSetActiveTextureHeapPtr(commandBuffer, gpuHostToDevicePointer(textureHeap));</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_380844">
  <p>It is almost possible to get rid of the CPU side texture object (GpuTexture) completely. Unfortunately the triangle rasterizer units of all modern GPUs are not yet bindless. The CPU driver needs to prepare command packets to bind render targets, depth-stencil buffers, clear and resolve. These APIs don’t use the 256-bit GPU texture descriptor. We need driver specific extra CPU data (stored in the GpuTexture object).</p><p>The simplest way to reference a texture in a shader is to use a 32-bit index. A single index can also represent the starting offset of a range of descriptors. This offers a straightforward way to implement the DirectX 12 descriptor table abstraction and the Vulkan descriptor set abstraction without an API. We also get an elegant solution to the fast material switch use case: All we need is a single 64-bit GPU pointer, pointing to a material data struct (containing material properties + 32-bit texture heap start index). Vulkan vkCmdBindDescriptorSets and DirectX 12 SetGraphicsRootDescriptorTable are relatively fast API calls, but they are nowhere as fast as writing a single 64-bit pointer to persistently mapped GPU memory. A lot of complexity is removed by not needing to create, update and delete resource binding API objects. CPU time is also saved as the user no longer needs to maintain a hash map of descriptor sets, a common approach to solve the immediate vs retained mode discrepancy in game engines.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_412508"><pre><code>// Common header...
struct alignas(16) Data
{
    uint32 srcTextureBase;
    uint32 dstTexture;
    float32x2 invDimensions;
};

// GPU kernel...
const Texture textureHeap[];

[groupsize = (8, 8, 1)]
void main(uint32x3 threadId : SV_ThreadID, const Data* data)
{
    Texture textureColor = textureHeap[data-&gt;srcTextureBase + 0];
    Texture textureNormal = textureHeap[data-&gt;srcTextureBase + 1];
    Texture texturePBR = textureHeap[data-&gt;srcTextureBase + 2];

    Sampler sampler = {.minFilter = LINEAR, .magFilter = LINEAR}; // Embedded sampler (Metal-style)

    float32x2 uv = float32x2(threadId.xy) * data-&gt;invDimensions;

    float32x4 color = sample(textureColor, sampler, uv);
    float32x4 normal = sample(textureNormal, sampler, uv);
    float32x4 pbr = sample(texturePBR, sampler, uv);

    float32x4 lit = calculateLighting(color, normal, pbr);

    TextureRW dstTexture = TextureRW(textureHeap[data-&gt;dstTexture]);
    dstTexture[threadId.xy] = lit;
}</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_412569">
  <p>Metal 4 manages the texture descriptor heap automatically. Texture objects have .gpuResourceID, which is a 64-bit heap index (Xcode GPU debugger reveals small values such as 0x3). You can directly write texture IDs into GPU structs, as you would use texture indices in DirectX SM 6.6 and Vulkan (descriptor buffer extension). As the heap management in Metal is automatic, users can’t allocate texture descriptors in contiguous ranges. It’s a common practice to store a 32-bit index to the first texture in the range and calculate the indices for other textures in the set (see above code example). Metal doesn’t support this. The user has to write a 64-bit texture handle for each texture separately. To address a set of 5 textures, you need 40 bytes in Metal (5 * 64-bit). Vulkan and DirectX 12 only need 4 bytes (1 * 32-bit). Apple GPU hardware is able to implement SM 6.6 texture heaps. The limitation is the Metal API (software).</p><p>Texel buffers can be still supported for backwards compatibility. DirectX 12 stores texel buffer descriptors in the same heap with texture descriptors. A texel buffer functions similarly to a 1d texture (unfiltered tfetch path). Since texel buffers would be mainly used for backwards compatibility, driver vendors wouldn’t need to jump over the hoops to replace them with faster code paths such as raw memory loads behind the scenes. I am not a big fan of driver background threads and shader replacements.</p><p>Non-uniform texture index needs to use NonUniformResourceIndex notation similar to GLSL and HLSL. This tells the low level GPU shader compiler to emit a special texture instruction with per-lane heap index, or a scalarization loop for GPUs that only support uniform descriptors. Since buffers are not descriptors, we never need NonUniformResourceIndex for buffers. We simply pass a 64-bit pointer per lane. It works on all modern GPUs. No scalarization loop, no mess. Additionally, the language should natively support ptr[index] notation for memory loads, where the index is 32-bits. Some GPUs support raw memory load instructions with 32-bit per lane offset. It reduces the register pressure. Feedback to GPU vendors: Please add the missing 64-bit shared base + 32-bit per lane offset raw load instruction and 16-bit uv(w) texture load instructions, if your architecture is still missing them.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_449566"><pre><code>const Texture textureHeap[];

[groupsize = (8, 8, 1)]
void main(uint32x3 threadId : SV_ThreadID, const Data* data)
{
    // Non-uniform "buffer data" is not an issue with pointer semantics! 
    Material* material = data-&gt;materialMap[threadId.xy];

    // Non-uniform texture heap index
    uint32 textureBase = NonUniformResourceIndex(material.textureBase);

    Texture textureColor = textureHeap[textureBase + 0];
    Texture textureNormal = textureHeap[textureBase + 1];
    Texture texturePBR = textureHeap[textureBase + 2];

    Sampler sampler = {.minFilter = LINEAR, .magFilter = LINEAR};

    float32x2 uv = float32x2(threadId.xy) * data-&gt;invDimensions;

    float32x4 color = sample(textureColor, sampler, uv);
    float32x4 normal = sample(textureNormal, sampler, uv);
    float32x4 pbr = sample(texturePBR, sampler, uv);
    
    color *= material.color;
    pbr *= material.pbr;

    // Rest of the shader
}</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_449626">
  <p>Modern bindless texturing lets us remove all texture binding APIs. A global indexable texture heap makes all textures visible to all shaders. Texture data still needs to be loaded into GPU memory by copy commands (to enable DCC and Morton swizzle). Texture descriptor creation still needs a thin GPU specific user land API. The texture heap can be exposed directly to both the CPU and the GPU as a raw GPU memory array, removing most of the texture heap API complexity compared to DirectX 12 SM 6.6.</p><h2>Shader pipelines</h2><p>Since our shader root data is just a single 64-bit pointer and our textures are just 32-bit indices, the shader pipeline creation becomes dead simple. There’s no need to define texture bindings, buffer bindings, bind groups (descriptor sets, argument buffers) or the root signature.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_464986"><pre><code>auto shaderIR = loadFile("computeShader.ir");
GpuPipeline computePipeline = gpuCreateComputePipeline(shaderIR);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_465047">
  <p>DirectX 12 and Vulkan utilize complex APIs to bind and set up root signatures, push descriptors, push constants, and descriptor sets. A modern GPU driver essentially constructs a single struct into GPU memory and passes its pointer to the command processor. We have shown that such API complexity is unnecessary. The user simply writes the root struct into persistently mapped GPU memory and passes a 64-bit GPU pointer directly to the draw/dispatch function. Users can also include 64-bit pointers and 32-bit texture heap indices inside their structs to build any indirect data layout that fits their needs. Root bindings APIs and the whole DX12 buffer zoo can be replaced efficiently with 64-bit pointers.​​ This simplifies the shader pipeline creation drastically. We don’t need to define the data layout at all. We successfully removed a massive chunk of API complexity while providing more flexibility to the user.</p><h2>Static constants</h2><p>Vulkan, Metal and WebGPU have a concept of static (specialization) constants, locked in at shader pipeline creation. The driver's internal shader compiler applies these constants as literals in the input shader IR and does constant propagation and dead code elimination pass afterward. This can be used to create multiple permutations of the same shader at pipeline creation, reducing the time and storage required for offline compiling all the shader permutations.</p><p>Vulkan and Metal have a set of APIs and a special shader syntax for describing the shader specialization constants and their values. It would be nicer to simply provide a C struct that matches the constant struct defined in the shader side. That would require minimal API surface and would bring important improvements.</p><p>Vulkan’s specialization constants have a design flaw. Specialization constants can’t modify the descriptor set layouts. Data inputs and outputs are fixed. The user could hack around the limitation by implementing an uber-layout containing all potential inputs/outputs and skip updating unused descriptors, but this is cumbersome and sub-optimal. Our proposed design doesn’t have the same problem. One can simply branch by a constant (the other side is dead code eliminated) and reinterpret the shader data input pointer as a different struct. One could also mimic the C++ inheritance data layout. Use a common layout for the beginning of the input struct and put specialized data at the end. Static polymorphism can be achieved cleanly. Runtime performance is identical to hand optimized shader. The specialization struct can also include GPU pointers, allowing the user to hardcode runtime memory locations, avoiding indirections. This has never been possible in a shader language before. Instead, the GPU vendors had to use background threads to analyze the shaders to do similar shader replacement optimizations at runtime, increasing the CPU cost and the driver complexity significantly.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_493029"><pre><code>// Common header...
struct alignas(16) Constants
{
    int32 qualityLevel;
    uint8* blueNoiseLUT;
};

// CPU code...
Constants constants { .qualityLevel = 2, blueNoiseLUT = blueNoiseLUT.gpu };

auto shaderIR = loadFile("computeShader.ir");
GpuPipeline computePipeline = gpuCreateComputePipeline(shaderIR, &amp;constants);

// GPU kernel...
[groupsize = (8, 8, 1)]
void main(uint32x3 threadId : SV_ThreadID, const Data* data, const Constants constants)
{
    if (constants.qualityLevel == 3)
    {
        // Dead code eliminated
    }
}</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_493089">
  <p>The shader permutation hell is one of the biggest issues in modern graphics today. Gamers are complaining about stutter, devs are complaining about offline shader compilation taking hours. This new design gives the user added flexibility. They can toggle between static and dynamic behavior inside the shader, making it easy to have a generic fallback and specialization on demand. This design reduces the number of shader permutations and the runtime stalls caused by pipeline creation.</p><h2>Barriers and fences</h2><p>The most hated feature in modern graphics APIs must be the barriers. Barriers serve two purposes: enforce producer-to-consumer execution dependencies and transition textures between layouts.</p><p>Many graphics programmers have an incorrect mental model about the GPU synchronization. A common belief is that GPU synchronization is based on fine-grained texture and buffer dependencies. In reality, modern GPU hardware doesn’t really care about individual resources. We spend lots of CPU cycles in userland preparing a list of individual resources and how their layouts change, but modern GPU drivers practically throw that list away. The abstraction doesn’t match reality.</p><p>Modern bindless architecture gives the GPU a lot of freedom. A shader can write to any 64-bit pointer or any texture in the global descriptor heap. The CPU doesn't know what decisions the GPU is going to make. How is it supposed to emit transition barriers for each affected resource? This is a clear mismatch between bindless architecture and classic CPU-driven rendering APIs today. Let’s investigate why the APIs were designed like this 10 years ago.&nbsp;</p><p>AMD GCN had a big influence on modern graphics API design. GCN was ahead of its time with async compute and bindless texturing (using scalar registers to store descriptors), but it also had crucial limitations in its delta color compression (DCC) and cache design. These limitations are a great example why the barrier model we have today is so complex. GCN didn’t have a coherent last-level cache. ROPs (raster operations = pixel shader outputs) had special non-coherent caches directly connected to the VRAM. The driver had to first flush the ROP caches to memory and then invalidate the L2$ to make pixel shader writes visible to shaders and samplers. The command processor also wasn’t a client of the L2$. Indirect arguments written in compute shaders weren’t visible to the command processor without invalidating the whole L2$ and flushing all dirty lines into VRAM. GCN 3 introduced delta color compression (DCC) for ROPs, but AMD’s texture samplers were not able to directly read DCC compressed textures or compressed depth buffers. The driver had to perform an internal decompress compute shader to eliminate the compression. The display engine could not read DCC compressed textures either. The common case of sampling a render target required two internal barriers and flushing all caches (wait for ROPs, flush ROP cache and L2$, run decompress compute shader, wait for compute).</p><p>AMD’s new RDNA architecture has several crucial improvements: It has a coherent L2$ covering all memory operations. ROPs and the command processor are clients of the L2$. The only non-coherent caches are the tiny L0$ and K$ (scalar cache) inside the compute units. A barrier now requires only flushing the outstanding writes in the tiny caches into the higher level cache. The driver no longer has to flush the last-level (L2) cache into the VRAM, making barriers significantly faster. RDNA’s improved display engine is capable of reading DCC compressed textures and a (de)compressor sits between the L2$ and the L0$ texture cache. There’s no need to decompress textures into VRAM before sampling, removing the need for texture layout transitions (compressed / uncompressed). All desktop and mobile GPU vendors have reached similar conclusions: Bandwidth is the bottleneck today. We should never waste bandwidth decoding resources into VRAM. Layout transitions are no longer needed.</p>
</div><div data-test="image-block-inline-outer-wrapper" data-block-type="5" id="block-yui_3_17_2_1_1765891714485_30775">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-stretch="false" data-src="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png" data-image="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png" data-image-dimensions="3448x1936" data-image-focal-point="0.5,0.5" alt="" data-load="false" elementtiming="system-image-block" src="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png" width="3448" height="1936" sizes="(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw" onload="this.classList.add(&quot;loaded&quot;)" srcset="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/985cf28c-1e47-4d47-b246-47da92a2ceb7/Screenshot+2025-12-16+at+15.38.28.png?format=2500w 2500w" loading="lazy" decoding="async" data-loader="sqs">

            </p>
          </div>
        
          
        

        
          
          <figcaption>
            <p data-rte-preserve-empty="true">AMD RDNA (2019): Improved cache hierarchy, DCC and display engine in the RDNA architecture. L2$ contains DCC compressed data. (De)compressor sits between L2$ and lower levels. L0$ (texture) is decompressed. Image © AMD.</p>
          </figcaption>
        
      
        </figure>
      

    </div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765891714485_31092">
  <p>Resource lists are the most annoying aspect of barriers in DirectX 12 and Vulkan. Users are expected to track the state of each resource individually, and tell the graphics API their previous and next state for each barrier. This was necessary on 10 year old GPUs as vendors hid various decompress commands under the barrier API. The barrier command functioned as the decompress command, so it had to know which resources required decompression. Today’s hardware doesn’t need texture layouts or decompress steps. Vulkan just got a new VK_KHR_unified_image_layouts (<a href="https://www.khronos.org/blog/so-long-image-layouts-simplifying-vulkan-synchronisation"><span>https://www.khronos.org/blog/so-long-image-layouts-simplifying-vulkan-synchronisation</span></a>) extension (2025), removing the image layout transitions from the barrier command. But it still requires the user to list individual textures and buffers. Why is this?</p><p>The main reason is legacy API and tooling compatibility. People are used to thinking about resource dependencies and the existing Vulkan and DirectX 12 validation layers are designed that way. However, the barrier command executed by the GPU contains no information about textures or buffers at all. The resource list is consumed solely by the driver.</p><p>Our modern driver loops through your resource list and populates a set of flags. Drivers no longer need to worry about resource layouts or last level cache coherency, but there still exists tiny non-coherent caches that need flushing in special cases. Modern GPUs flush the majority of the non-coherent caches automatically in every barrier. For example the AMD L0$ and K$ (scalar cache) are always flushed, since every pass writes some outputs and these outputs live in some of these caches. Fine grained tracking of all write addresses would be too expensive. Tiny non-coherent caches tend to be inclusive. Modified lines get flushed to the next cache level. This is fast and doesn’t produce VRAM traffic. Some architectures have special caches that are not automatically flushed. Examples: descriptor caches in the texture samplers (see above chapter), rasterizer ROP caches and HiZ caches. The command processor commonly runs ahead to reduce the wave spawn latency. If we write indirect arguments in a shader, we need to inform the GPU to stall the command processor prefetcher to avoid a race. The GPU doesn’t actually know whether your compute shader was writing into an indirect argument buffer or not. In DirectX 12 the buffer is transitioned to D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT and in Vulkan the consumer dependency has a special stage VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT. When a barrier has a resource transition like this or a stage dependency like this, the driver will include command processor prefetcher stall flag into the barrier.</p><p>A modern barrier design replaces the resource list with a single bitfield describing what happens to these special non-coherent caches. Special cases include: Invalidate texture descriptors, invalidate draw arguments and invalidate depth caches. These flags are needed when we generate draw arguments, write to the descriptor heap or write to a depth buffer with a compute shader. Most barriers don’t need special cache invalidation flags.</p><p>Some GPUs still need to decompress data in special cases. For example during a copy or a clear command (fast clear eliminate if clear color has changed). Copy and clear commands take the affected resource as a parameter. The driver can take necessary steps to decode the data if needed. We don’t need a resource list in our barrier for these special cases. Not all formats and usage flags support compression. The driver will keep the data uncompressed in these cases, instead of transitioning it back and forth, wasting bandwidth.&nbsp;</p><p>A standard UAV barrier (compute → compute) is trivial.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_569070"><pre><code>gpuBarrier(commandBuffer, STAGE_COMPUTE, STAGE_COMPUTE);</code></pre>

</div><div data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_569131">

<p>If you write to the texture descriptor heap (uncommon), you need to add a special flag.</p>




















  
  



</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_588768"><pre><code>gpuBarrier(commandBuffer, STAGE_COMPUTE, STAGE_COMPUTE, HAZARD_DESCRIPTORS);</code></pre>

</div><div data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_588829">

<p>A barrier between rasterizer output and pixel shader is a common case for offscreen render target → sampling. Our example has dependency stages set up in a way that the barrier doesn’t block vertex shaders, allowing vertex shading (and tile binning on mobile GPUs) to overlap with previous passes. A barrier with raster output stage (or later) as the producer automatically flushes non-coherent ROP caches if the GPU architecture needs that. We don’t need an explicit flag for it.</p>




















  
  



</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_608158"><pre><code>gpuBarrier(commandBuffer, STAGE_RASTER_COLOR_OUT | STAGE_RASTER_DEPTH_OUT, STAGE_PIXEL_SHADER);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_608218">
  <p>Users only describe the queue execution dependencies: producer and consumer stage masks. There’s no need to track the individual texture and buffer resource states, removing a lot of complexity and saving a significant amount of CPU time versus the current DirectX 12 and Vulkan designs. Metal 2 has a modern barrier design already: it doesn’t use resource lists.</p><p>Many GPUs have custom scratchpads memories: Groupshared memory inside each compute unit, tile memory, large shared scratchpads like the Qualcomm GMEM. These memories are managed automatically by the driver. Temporary scratchpads like groupshared memory are never stored to memory. Tile memories are stored automatically by the tile rasterizer (store op == store). Uniform registers are read-only and pre-populated before each draw call. Scratchpads and uniform registers don’t have cache coherency protocols and don’t interact with the barriers directly.</p><p>Modern GPUs support a synchronization command that writes a value to memory when a shader stage is finished, and a command that waits for a value to appear in memory location before a shader stage is allowed to begin (wait includes optional cache flush semantics). This is equivalent to splitting the barrier into two: the producer and the consumer. DirectX 12 split barriers and Vulkan event→wait are examples of this design. Splitting the barrier into consumer→producer allows putting independent work between them, avoiding draining the GPU.</p><p>Vulkan event→wait (and DX12 split barriers) see barely any use. The main reason is that normal barriers are already highly complicated, and developers want to avoid extra complexity. Driver support for split barriers also hasn’t been perfect in the past. Removing the resource lists simplifies the split barriers significantly. We can also make split barriers semantically similar to timeline semaphores: Signal command writes to a monotonically increasing 64-bit value (atomic max) and wait command waits for the value to be &gt;= N (greater equal). The counter is just a GPU memory pointer, no persistent API object is required. This provides us with a significantly simpler event→wait API.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_644705"><pre><code>gpuSignalAfter(commandBuffer, STAGE_RASTER_COLOR_OUT, gpuPtr, counter, SIGNAL_ATOMIC_MAX);
// Put independent work here
gpuWaitBefore(commandBuffer, STAGE_PIXEL_SHADER, gpuPtr, counter++, OP_GREATER_EQUAL);</code></pre>

</div><div data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_644766">

<p>This API is much simpler than the existing VkEvent API, yet offers improved flexibility. In the above example we implemented the timeline semaphore semantics, but we can implement other patterns too, such as waiting multiple producers using a bitmask: mark bits with SIGNAL_ATOMIC_OR and wait for all bits in a mask to be set (mask is an optional parameter in the gpuWaitBefore command).</p>




















  
  



</div><div data-test="image-block-inline-outer-wrapper" data-block-type="5" id="block-yui_3_17_2_1_1765891714485_29270">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-stretch="false" data-src="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png" data-image="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png" data-image-dimensions="3260x1730" data-image-focal-point="0.5,0.5" alt="" data-load="false" elementtiming="system-image-block" src="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png" width="3260" height="1730" sizes="(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw" onload="this.classList.add(&quot;loaded&quot;)" srcset="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/f044fea3-4dfc-4d7a-9400-2eb58f7ca5a3/Screenshot+2025-12-16+at+15.37.11.png?format=2500w 2500w" loading="lazy" decoding="async" data-loader="sqs">

            </p>
          </div>
        
          
        

        
          
          <figcaption>
            <p data-rte-preserve-empty="true">Cascading signal→wait with independent work between producer→consumer avoids GPU stalls. Image © Timothy Lottes.</p>
          </figcaption>
        
      
        </figure>
      

    </div><div data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765891714485_29587">

<p>GPU→CPU synchronization was initially messy in Vulkan and Metal. Users needed a separate fence object for each submit. N buffering was a common technique for reusing the objects. This is a similar usability issue as discussed above regarding VkEvent. DirectX 12 was the first API to solve the GPU→CPU synchronization cleanly with timeline semaphores. Vulkan 1.2 and Metal 2 adapted the same design later. A timeline semaphore needs only a single 64-bit monotonically increasing counter. This reduces complexity over the older Vulkan and Metal fence APIs, which many engines still use today.</p>




















  
  



</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_719605"><pre><code>#define FRAMES_IN_FLIGHT 2

GpuSemaphore frameSemaphore = gpuCreateSemaphore(0);
uint64 nextFrame = 1;

while (running)
{
    if (nextFrame &gt; FRAMES_IN_FLIGHT) 
    {
        gpuWaitSemaphore(frameSemaphore, nextFrame - FRAMES_IN_FLIGHT);
    }
    
    // Render the frame here

    gpuSubmit(queue, {commandBuffer}, frameSemaphore, nextFrame++);
}

gpuDestroySemaphore(frameSemaphore);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_719666">
  <p>Our proposed barrier design is a massive improvement over DirectX 12 and Vulkan. It reduces the API complexity significantly. Users no longer need to track individual resources. Our simple hazard tracking has queue + stage granularity. This matches what GPU hardware does today. Game engine graphics backends can be simplified and CPU cycles are saved.</p><h2>Command buffers</h2><p>Vulkan and DirectX 12 were designed to promote the pre-creation and reuse of resources. Early Vulkan examples recorded a single command buffer at startup, replaying it every frame. Developers quickly discovered that command buffer reuse was impractical. Real game environments are dynamic and the camera is in constant motion. The visible object set changes frequently.</p><p>Game engines ignored prerecorded command buffers entirely. Metal and WebGPU feature transient command buffers, which are created just before recording and disappear after GPU has finished rendering. This eliminates the need for command buffer management and prevents multiple submissions of the same commands. GPU vendors recommend one shot command buffers (a resettable command pool per frame in flight) in Vulkan too, as it simplifies the driver’s internal memory management (bump allocator vs heap allocator). The best practices match Metal and WebGPU design. Persistent command buffer objects can be removed. That API complexity didn’t provide anything worth using.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765889087118_737461"><pre><code>while (running)
`
    GpuCommandBuffer commandBuffer = gpuStartCommandRecording(queue);
    // Render frame here
}</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765889087118_737524">
  <h2>Graphics shaders</h2><p>Let’s start with a burning question: Do we need graphics shaders anymore? UE5 Nanite uses compute shaders to plot pixels using 64-bit atomics. High bits contain the pixel depth and low bits contain the payload. Atomic-min ensures that the closest surface remains. This technique was first presented at SIGGRAPH 2015 by Media Molecule Dreams (Alex Evans). Hardware rasterizer still has some advantages, like hierarchical/early depth-stencil tests. Nanite has to lean solely on coarse cluster culling, which results in extra overdraw with kitbashed content. Ubisoft (me and Ulrich Haar) presented this two-pass cluster culling algorithm at SIGGRAPH 2015. Ubisoft used cluster culling in combination with the hardware rasterizer for more fine grained culling. Today’s GPUs are bindless and much better suited for GPU-driven workloads like this. 10 years ago Ubisoft had to lean on virtual texturing (all textures in the same atlas) instead of bindless texturing. Despite many compute-only rasterizers today (Nanite, SDF sphere tracing,  DDA voxel tracing) the hardware rasterizer still remains the most used technique for rendering triangles in games today. It’s definitely worth discussing how to make the rasterization pipeline more flexible and easier to use.</p><p>The modern shader framework has grown to 16 shader entry points. We have eight entry points for rasterization (pixel, vertex, geometry, hull, domain, patch constant, mesh and amplification), and six for ray-tracing (ray generation, miss, closest hit, any hit, intersection and callable). In comparison, CUDA has a single entry point: kernel. This makes CUDA composable. CUDA has a healthy ecosystem of 3rd party libraries. New GPU hardware blocks such as the tensor cores (AI) are exposed as intrinsic functions. This is how it all started in the graphics land as well: texture sampling was our first intrinsic function. Today, texture sampling is fully bindless and doesn’t even require driver setup. This is the design developers prefer. Simple, easy to compose, and extend.</p><p>We recently got more intrinsics: inline raytracing and cooperative matrix (wave matrix in DirectX 12, subgroup matrix in Metal). I am hoping that this is the new direction. We should start tearing down the massive 16 shader framework and replacing it with intrinsics that can be composed in a flexible way.</p><p>Solving the shader framework complexity is a massive topic. To keep the scope of this blog post in check, I will today only discuss compute shaders and raster pipelines. I am going to be writing a followup about simplifying the shader framework, including modern topics such as ray-tracing, shader execution reordering (SER), dynamic register allocation extensions and Apple’s new L1$ backed register file (called dynamic caching).</p><h2>Raster pipelines</h2><p>There are two relevant raster pipelines today: Vertex+pixel and mesh+pixel. Mobile GPUs employing tile based deferred rendering (TBDR) perform per-triangle binning. Tile size is commonly between 16x16 to 64x64 pixels, making meshlets too coarse grained primitive for binning. Meshlet has no clear 1:1 lane to vertex mapping, there’s no straightforward way to run a partial mesh shader wave for selected triangles. This is the main reason mobile GPU vendors haven’t been keen to adapt the desktop centric mesh shader API designed by Nvidia and AMD. Vertex shaders are still important for mobile.</p><p>I will not be discussing geometry, hull, domain, and patch constant (tessellation) shaders. The graphics community widely considers these shader types as failed experiments. They all have crucial performance issues in their design. In all relevant use cases, you can run a compute prepass generating an index buffer to outperform these stages. Additionally, mesh shaders allow generating a compact 8-bit index buffer into on-chip memory, further increasing the performance gap over these legacy shader stages.</p><p>Our goal is to build a modern PSO abstraction with a minimal amount of baked state. One of the main critiques of Vulkan and DirectX 12 has been the pipeline permutation explosion. The less state we have inside the PSO, the less pipeline permutations we get. There are two main areas to improve: graphics shader data bindings and the rasterizer state.</p><h2>Graphics shader bindings&nbsp;</h2><p>Vertex+pixel shader pipeline needs several additional inputs compared to a compute kernel: vertex buffers, index buffer, rasterizer state, render target views and a depth-stencil view. Let’s start by discussing the shader visible data bindings.</p><p>Vertex buffer bindings are easy to solve: We simply remove them. Modern GPUs have fast raw load paths. Most GPU vendors have been emulating vertex fetch hardware already for several generations. Their low level shader compiler reads the user defined vertex layout and emits appropriate raw load instructions in the beginning of the vertex shader.&nbsp;</p><p>The vertex bindings declaration is another example of a special C/C++ API for defining a struct memory layout. It adds complexity and forces compiling multiple PSO permutations for different layouts. We simply replace the vertex buffers with standard C/C++ structs. No API is required.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_32538"><pre><code>// Common header...
struct Vertex
{
    float32x4 position;
    uint8x4 normal;
    uint8x4 tangent;
    uint16x2 uv;
};

struct alignas(16) Data
{
    float32x4x4 matrixMVP;
    const Vertex *vertices;
};

// CPU code...
gpuSetPipeline(commandBuffer, graphicsPipeline);

auto data = myBumpAllocator.allocate&lt;Data&gt;();
data.cpu-&gt;matrixMVP = camera.viewProjection * modelMatrix;
data.cpu-&gt;vertices = mesh.vertices;

gpuDrawIndexed(commandBuffer, data.gpu, mesh.indices, mesh.indexCount);

// Vertex shader...
struct VertexOut 
{
    float32x4 position : SV_Position;
    float16x4 normal;
    float32x2 uv;
};

VertexOut main(uint32 vertexIndex : SV_VertexID, const Data* data)
{
    Vertex vertex = data-&gt;vertices[vertexIndex];
    float32x4 position = data-&gt;matrixMVP * vertex.position;
    // TODO: Normal transform here
    return { .position = position, .normal = normal, .uv = vertex.uv };
}</code></pre>

</div><div data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_33528">

<p>The same is true for per-instance data and multiple vertex streams. We can implement them efficiently with raw memory loads. When we use raw load instructions, we can dynamically adjust the vertex stride, branch over secondary vertex buffer loads and calculate our vertex indices using custom formulas to implement clustered GPU-driven rendering, particle quad expansion, higher order surfaces, efficient terrain rendering and many other algorithms. Additional shader entry points and binding APIs are not needed. We can use our new static constant system to dead code eliminate vertex streams at pipeline creation or provide a static vertex stride if we so prefer. All the old optimization strategies still exist, but we can now mix and match techniques freely to match our renderer’s needs.&nbsp;</p>




















  
  



</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_47086"><pre><code>// Common header...
struct VertexPosition
{
    float32x4 position;
};

struct VertexAttributes
{
    uint8x4 normal;
    uint8x4 tangent;
    uint16x2 uv;
};

struct alignas(16) Instance
{
    float32x4x4 matrixModel;
}

struct alignas(16) Data
{
    float32x4x4 matrixViewProjection;
    const VertexPosition *vertexPositions;
    const VertexAttributes *vertexAttribues;
    const Instance *instances;
};

// CPU code...
gpuSetPipeline(commandBuffer, graphicsPipeline);

auto data = myBumpAllocator.allocate&lt;Data&gt;();
data.cpu-&gt;matrixViewProjection = camera.viewProjection;
data.cpu-&gt;vertexPositions = mesh.positions;
data.cpu-&gt;vertexAttributes = mesh.attributes;
data.cpu-&gt;instances = batcher.instancePool + instanceOffset; // pointer arithmetic is convenient

gpuDrawIndexedInstanced(commandBuffer, data.gpu, mesh.indices, mesh.indexCount, instanceCount);

// Vertex shader...
struct VertexOut 
{
    float32x4 position : SV_Position; // SV values are not real struct fields (doesn't affect the layout)
    float16x4 normal;
    float32x2 uv;
};

VertexOut main(uint32 vertexIndex : SV_VertexID, uint32 instanceIndex : SV_InstanceID, const Data* data)
{
    Instance instance = data-&gt;instances[SV_InstanceIndex];

    // NOTE: Splitting positions/attributes benefits TBDR GPUs (vertex shader is split in two parts)
    VertexPosition vertexPosition = data-&gt;vertexPositions[SV_VertexIndex];
    VertexAttributes vertexAttributes = data-&gt;vertexAttributes[SV_VertexIndex];

    float32x4x4 matrix = data-&gt;matrixViewProjection * instance.matrixModel;
    float32x4 position = matrix * vertexPosition.position;

    // TODO: Normal transform here

    return { .position = position, .normal = normal, .uv = vertexAttributes.uv };
}</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_47147">
  <p>The index buffer binding is still special. GPUs have index deduplication hardware. We don’t want to run the vertex shader twice for the same vertex. The index deduplication hardware packs the vertex waves eliminating duplicate vertices. Index buffering is still a crucial optimization today. Non-indexed geometry executes 3 vertex shader invocations (lanes) per triangle. A perfect grid has two triangles per cell, thus it only needs one vertex shader invocation per two triangles (ignoring the last row/column). Modern offline vertex cache optimizers output meshes with around 0.7 vertices per triangle efficiency. We can achieve around 4x to 6x reduction in vertex shading cost with index buffer in real world scenarios.</p><p>The index buffer hardware nowadays connects to the same cache hierarchy as all the other GPU units. Index buffer is simply an extra GPU pointer in the drawIndexed call. That’s the sole API surface we need for index buffering.</p><p>Mesh shaders lean on offline vertex deduplication. A common implementation shades one vertex per lane, and outputs it into on-chip memory. An 8-bit local index buffer tells the rasterizer which 3 vertices are used by each triangle. Since all the meshlet outputs are available at once and are already transformed in on-chip storage, there’s no need to deduplicate or pack vertices after triangle setup. This is why mesh shaders don’t need the index deduplication hardware or the post transform cache. All mesh shader inputs are raw data. No extra API surface is needed beyond the gpuDrawMeshlets command.</p><p>My example mesh shader uses 128 lane thread groups. Nvidia supports up to 126 vertices and 64 triangles per output meshlet. AMD supports 256 vertices and 128 triangles. The shader masks out excess lanes. Since there’s never more than 64 triangles, you might also opt for a 64 lane thread group for optimal triangle lane utilization and do a two iteration loop for vertex shading. My triangle fetch logic is just a single memory load instruction, wasting half of the lanes there isn’t a problem. I chose the extra parallelism for vertex shading instead. Optimal choices depend on your workload and the target hardware.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_68808"><pre><code>// Common header...
struct Vertex
{
    float32x4 position;
    uint8x4 normal;
    uint8x4 tangent;
    uint16x2 uv;
};

struct alignas(16) Meshlet
{
    uint32 vertexOffset;
    uint32 triangleOffset;
    uint32 vertexCount;
    uint32 triangleCount;
};

struct alignas(16) Data
{
    float32x4x4 matrixMVP;
    const Meshlet *meshlets;
    const Vertex *vertices;
    const uint8x4 *triangles;
};

// CPU code...
gpuSetPipeline(commandBuffer, graphicsMeshPipeline);

auto data = myBumpAllocator.allocate&lt;Data&gt;();
data.cpu-&gt;matrixMVP = camera.viewProjection * modelMatrix;
data.cpu-&gt;meshlets = mesh.meshlets;
data.cpu-&gt;vertices = mesh.vertices;
data.cpu-&gt;triangles = mesh.triangles;

gpuDrawMeshlets(commandBuffer, data.gpu, uvec3(mesh.meshletCount, 1, 1));

// Mesh shader...
struct VertexOut 
{
    float32x4 position : SV_Position;
    float16x4 normal;
    float32x2 uv;
};

[groupsize = (128, 1, 1)]
void main(uint32x3 groupThreadId : SV_GroupThreadID, uint32x3 groupId : SV_GroupID, const Data* data)
{
    Meshlet meshlet = data-&gt;meshlets[groupId.x];

    // Meshlet output allocation intrinsics
    VertexOut* outVertices = allocateMeshVertices&lt;VertexOut&gt;(meshlet.vertexCount);
    uint8x3* outIndices = allocateMeshIndices(meshlet.triangleCount);

    // Triangle indices (3x 8 bit)
    if (groupThreadId.x &lt; meshlet.triangleCount)
    {
        outIndices[groupThreadId.x] = triangles[meshlet.triangleOffset + groupThreadId.x].xyz;
    }

    // Vertices
    if (groupThreadId.x &lt; meshlet.vertexCount)
    {
        Vertex vertex = data-&gt;vertices[meshlet.vertexOffset + groupThreadId.x];
        float32x4 position = data-&gt;matrixMVP * vertex.position;
        // TODO: Normal transform here
        outVertices[groupThreadId.x] = { .position = position, .normal = normal, .uv = vertex.uv };
    }
}</code></pre>

</div><div data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_68869">

<p>Both vertex shaders and mesh shaders use pixel shaders. Rasterizer spawns pixel shader work based on triangle pixel coverage, HiZ, and early depth/stencil test results. Hardware can pack multiple triangles and multiple instances in the same pixel shader wave. Pixel shaders itself aren’t that special. Nowadays pixel shaders run on the same SIMD cores as all the other shader types. There are some special inputs available: interpolated vertex outputs, screen location, sample index and coverage mask, triangle id, triangle facing, etc. Special inputs are declared as kernel function parameters using the system value (: SV) semantics, similar to existing APIs.</p>




















  
  



</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_77331"><pre><code>// Pixel shader...
const Texture textureHeap[];

struct VertexIn // Matching vertex shader output struct layout
{
    float16x4 normal;
    float32x2 uv;
};

struct PixelOut 
{
    float16x4 color : SV_Color0;
};

PixelOut main(const VertexIn &amp;vertex, const DataPixel* data)
{
    Texture texture = textureHeap[data-&gt;textureIndex];
    Sampler sampler = {.minFilter = LINEAR, .magFilter = LINEAR};

    float32x4 color = sample(texture, sampler, vertex.uv);
    return { .color = color };
}</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_77392">
  <p>The removal of data bindings makes vertex and pixel shaders simpler to use. All of the complex data bindings APIs are replaced by a 64-bit GPU pointer. Users are able to write flexible vertex fetch code to avoid creating a PSO permutation per vertex layout.</p><h2>Rasterizer state</h2><p>Legacy APIs (OpenGL and DirectX 9) had fine grained commands for setting all the shader inputs and rasterizer states. The driver had to build shader pipelines on demand. Hardware specific rasterizer, blender, and input assembler command packets were constructed from the shadow state that combined all individual fine grained states. Vulkan 1.0 and DirectX 12 chose the fully opposite design. All state is baked in the PSO ahead of time. Only a select few states, such as viewport rect, scissor rect, and stencil values, can be changed dynamically. This resulted in a massive explosion of PSO permutations.</p><p>PSO creation is expensive, as it requires calling the GPU driver’s low-level shader compiler. PSO permutations consume a significant amount of storage and RAM. Changing the PSO is the most expensive state change. The small performance advantages that some vendors achieved by embedding render state directly into the shader microcode were overshadowed by the performance issues caused by significantly amplified pipeline creation, binding and data management costs everywhere. The pendulum swung too far to the opposite side.</p><p>Modern GPUs are ALU dense. Nvidia and AMD recently doubled their ALU rate with additional pipelines. Apple also doubled their fp32 pipelines in their M-series chips. Simple states resulting only in a constant replacement in the shader should not require pipeline duplication, even if it adds an extra ALU instruction or wastes an uniform register. Most shaders today are not ALU bound. The cost is often not measurable, but the benefits of having less permutations are significant. Vulkan 1.3 is a big step in the right direction. A lot of baked PSO states can now be set dynamically.</p><p>If we investigate deeper, we notice that all GPUs use command packets for configuring their rasterizer and depth-stencil units. These command packets are not directly tied to the shader microcode. We don’t need to modify the shader microcode to change the rasterizer and depth-stencil state. Metal has a separate depth-stencil state object and a separate command for applying it. A separate state object reduces the PSO permutations and reduces the expensive shader binding calls. Vulkan 1.3 dynamic state achieves similar PSO permutation reduction, but is more fine grained. Metal’s design is a better match for the actual hardware command packets. Bigger packets reduce the API bloat and overhead. DirectX 12 unfortunately still bundles most of the depth-stencil state inside the PSO (stencil ref and depth bias are the only dynamic state). In our design the depth-stencil state is a separate object.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_92642"><pre><code>GpuDepthStencilDesc depthStencilDesc = 
{
    .depthMode = DEPTH_READ | DEPTH_WRITE,
    .depthTest = OP_LESS_EQUAL,
    .depthBias = 0.0f,
    .depthBiasSlopeFactor = 0.0f,
    .depthBiasClamp = 0.0f,
    .stencilReadMask = 0xff,
    .stencilWriteMask = 0xff,
    .stencilFront =
    {
        .test = OP_ALWAYS,
        .failOp = OP_KEEP,
        .passOp = OP_KEEP,
        .depthFailOp = OP_KEEP,
        .reference = 0
    },
    .stencilBack =
    {
        .test = COMPARE_ALWAYS,
        .failOp = OP_KEEP,
        .passOp = OP_KEEP,
        .depthFailOp = OP_KEEP,
        .reference = 0
    }
};

// A minimal way to descibe the above (using C++ API struct default values):
GpuDepthStencilDesc depthStencilDesc = 
{
    .depthMode = DEPTH_READ | DEPTH_WRITE,
    .depthTest = OP_LESS_EQUAL,
};

GpuDepthStencilState depthStencilState = gpuCreateDepthStencilState(depthStencilDesc);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_92703">
  <p>Immediate mode (desktop) GPUs have similar command packets for configuring the alpha blender unit. If we were designing DirectX 13, we would simply split the blend state object out of the PSO and call it a day. But we are designing a cross platform API, and blending works completely differently on mobile GPUs.</p><p>Mobile GPUs (TBDR) have always supported programmable blending. A render tile fits into a scratchpad memory close to the compute unit (such as the groupshared memory), allowing pixel shaders a direct low latency read+write access to previously rasterized pixels. Most mobile GPUs don’t have any fixed function blending hardware. When a traditional graphics API is used, the driver's low level shader compiler adds blending instructions at the end of the shader. This is analogous to the vertex fetch code generation (described above). If we were designing an API solely for mobile GPUs, we would get rid of the blend state APIs completely, just like we got rid of the vertex buffers. Mobile centric APIs expose a framebuffer fetch intrinsic to efficiently obtain current pixel’s previous color. The user can write any blending formula they want, including complex formulas to implement advanced algorithms such as order independent transparency. The user can also write a generic parametrised formula to eliminate the PSO permutation explosion. As we can see, both the desktop and the mobile GPUs have their own ways to reduce the pipeline permutations regarding blending, the limitation is the current APIs.</p><p>Vulkan subpasses were designed to wrap framebuffer fetch into a cross platform API. This was another misstep in Vulkan design. Vulkan inherited a simple low level design from Mantle, but Vulkan was designed as an OpenGL replacement, so it had to target all mobile and desktop GPU architectures. Wrapping two entirely different architecture types under the same API isn’t easy. Subpasses ended up being a high level concept inside a low level API. A subpass could define an entire chain of render passes but pretend that it’s just a single render pass. Subpasses increased driver complexity and made the shader and renderpass APIs needlessly complex. Users were forced to create complex persistent multi-render pass objects ahead of time and pass those objects into shader pipeline creation. Shader pipelines became multi-pipelines under the hood (one pipeline per sub-pass). Vulkan added all of this complexity simply to avoid exposing the framebuffer fetch intrinsic to the shader language. To add insult to injury, the subpasses weren’t even good enough to solve the programmable blending. Pixel ordering is only preserved at pass boundaries. Subpasses were only useful for narrow 1:1 multi-pass use cases. Vulkan 1.3 scrapped the subpasses and introduced “dynamic rendering”. Users no longer need to create persistent render pass objects, just like in Metal, DirectX 12 and WebGPU. This is a great example of how a complex framework can be tempting for API designers, but developers prefer simple shader intrinsics. Game engines already support building different shaders to different platforms. Apple’s Metal examples do the same: Framebuffer fetch is used on iOS and a traditional multipass algorithm on Mac.</p><p>It’s apparent that we can’t abstract hardware differences regarding blending and framebuffer fetch. Vulkan 1.0 tried that and failed miserably. The correct solution is to provide the user a choice. They can choose to embed the blend state into the PSO. This works on all platforms and is the perfect approach for shaders that don’t suffer from blend state related pipeline permutation issues. Mobile GPU’s internal driver shader compiler adds the blending instructions in the end of the pixel shader as usual. On immediate mode (desktop) GPUs (and some mobile GPUs), the user can choose to use separate blend state objects. This reduces the amount of PSO permutations and makes it faster to change the blend state at runtime, as a full pipeline change is not needed (only a blend state configuration packet is sent).&nbsp;</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_105493"><pre><code>GpuBlendDesc blendDesc = 
{
    .colorOp = OP_ONE,
    .srcColorFactor = FACTOR_SRC_ALPHA,
    .dstColorFactor = FACTOR_ONE_MINUS_SRC_ALPHA,
    .alphaOp = OP_ONE,
    .srcAlphaFactor = FACTOR_SRC_ALPHA,
    .dstAlphaFactor = FACTOR_ONE_MINUS_SRC_ALPHA,
    .colorWriteMask = 0xf
};

// Create blend state object (needs feature flag)
GpuBlendState blendState = gpuCreateBlendState(blendDesc);

// Set dynamic blend state (needs feature flag)
gpuSetBlendState(commandBuffer, blendState);</code></pre>

</div><div data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_105554">

<p>On mobile GPUs the user can embed the blend state into the PSO as usual, or choose to use framebuffer fetch to write a custom blending formula. If the mobile developer wants to avoid compiling multiple PSO permutations for different alpha blending modes, they can write a general formula parametrized with dynamic draw struct inputs.</p>




















  
  



</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_110757"><pre><code>// Standard percentage blend formula (added automatically by internal shader compiler)
dst.rgb = src.rgb * src.a + dst.rgb * (1.0 - src.a);
dst.a = src.a * src.a + dst.a * (1.0 - src.a);

// Custom formula supporting all blend modes used by HypeHype
const BlendParameters&amp; p = data-&gt;blendParameters;
vec4 fs = src.a * vec4(p.sc_sa.xxx + p.sc_one.xxx, p.sa_sa + p.sa_one) + dst.rgba * vec4(p.sc_dc.xxx, sa_da);
vec4 fd = (1.0 - src.a) * vec4(p.dc_1msa.xxx, p.da_1msa) + vec4(p.dc_one.xxx, p.da_one);
dst.rgb = src.rgb * fs.rgb + dst.rgb * fd.rgb;
dst.a  = src.a * fs.a + dst.a * fd.a;</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_110818">
  <p>As the blend state is separated from the PSO, it’s possible we lose some automatic dead code optimizations. If the user wants to disable the color output, they traditionally use the colorWriteMask in the blend state. Since the blend state is burned in the PSO, the compiler can do dead code elimination based on it. To allow similar dead code optimizations, we have writeMask for each color target in the PSO.</p><p>Dual source blending is a special blend mode requiring two color outputs from the pixel shader. Dual source blending only supports a single render target. Since our blend state can be separate, we need to have a supportDualSourceBlending field in our PSO desc. When enabled, the shader compiler knows the second output is for dual source blending. The validation layer would complain if the output is not present. A pixel shader exporting two colors can be used without dual source blending (the second color is ignored), but there’s a small cost for exporting two colors.</p><p>The remaining rendering state in the PSO is minimal: primitive topology, render target and depth-stencil target formats, MSAA sample count and alpha to coverage. All of this state affects the generated shader microcode so it needs to stay in the PSO. We never want to rebuild the shader PSO microcode due to a state change. If an embedded blend state is used, it's also burned in the PSO. This leaves us with a simple raster state struct for PSO creation.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_122451"><pre><code>GpuRasterDesc rasterDesc = 
{
    .topology = TOPOLOGY_TRIANGLE_LIST,
    .cull = CULL_CCW,
    .alphaToCoverage = false,
    .supportDualSourceBlending = false,
    .sampleCount = 1`
    .depthFormat = FORMAT_D32_FLOAT,
    .stencilFormat = FORMAT_NONE,
    .colorTargets = 
    {
        { .format = FORMAT_RG11B10_FLOAT	},		// G-buffer with 3 render targets
        { .format = FORMAT_RGB10_A2_UNORM },
        { .format = FORMAT_RGBA8_UNORM }
    },
    .blendstate = GpuBlendDesc { ... }			// optional (embedded blend state, otherwise dynamic)
};

// A minimal way to descibe the above (using C++ API struct default values):
GpuRasterDesc rasterDesc = 
{
    .depthFormat = FORMAT_D32_FLOAT,
    .colorTargets = 
    {
        { .format = FORMAT_RG11B10_FLOAT	},
        { .format = FORMAT_RGB10_A2_UNORM },
        { .format = FORMAT_RGBA8_UNORM }
    },
};

// Pixel + vertex shader
auto vertexIR = loadFile("vertexShader.ir");
auto pixelIR = loadFile("pixelShader.ir");
GpuPipeline graphicsPipeline = gpuCreateGraphicsPipeline(vertexIR, pixelIR, rasterDesc);

// Mesh shader
auto meshletIR = loadFile("meshShader.ir");
auto pixelIR = loadFile("pixelShader.ir");
GpuPipeline graphicsMeshletPipeline = gpuCreateGraphicsMeshletPipeline(meshletIR, pixelIR, rasterDesc);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_122833">
  <p>HypeHype’s Vulkan shader PSO initialization backend code is 400 lines, and I would consider it compact compared to other engines I have been developing. Here, we managed to initialize a pixel + vertex shader with just 18 lines of code. It’s easy to read and understand. Yet, there’s no compromise on performance.&nbsp;</p><p>Rendering with the raster pipeline is similar to rendering with a compute pipeline. Instead of providing one data pointer, we provide two since there’s two kernel entry points: One for vertex shader and one for pixel shader. Metal has a separate set of data binding slots for vertex and pixel shaders. DirectX, Vulkan and WebGPU use a visibility mask (vertex, pixel, compute, etc) for each individual binding. Many engines choose to bind the same data to both vertex and pixel shader. This is a fine practice on DirectX, Vulkan and WebGPU as you can combine the mask bits, but doubles the binding calls on Metal. Our proposed approach using two data pointers is the best of both worlds. You can simply pass the same pointer twice if you want to use the same data in both the vertex and the pixel shader. Or you can provide independent data pointers, if you prefer full separation between the shader stages. The shader compiler does dead code elimination and constant/scalar preload optimizations separately for pixel and vertex shader. Neither data sharing nor data duplication results in bad performance. The user can choose whatever fits their design.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_128385"><pre><code>// Common header...
struct Vertex
{
    float32x4 position;
    uint16x2 uv;
};

struct alignas(16) DataVertex
{
    float32x4x4 matrixMVP;
    const Vertex *vertices;
};

struct alignas(16) DataPixel
{
    float32x4 color;
    uint32 textureIndex;
};

// CPU code...
gpuSetDepthStencilState(commandBuffer, depthStencilState);
gpuSetPipeline(commandBuffer, graphicsPipeline);

auto dataVertex = myBumpAllocator.allocate&lt;DataVertex&gt;();
dataVertex.cpu-&gt;matrixMVP = camera.viewProjection * modelMatrix;
dataVertex.cpu-&gt;vertices = mesh.vertices;

auto dataPixel = myBumpAllocator.allocate&lt;DataPixel&gt;();
dataPixel.cpu-&gt;color = material.color;
dataPixel.cpu-&gt;textureIndex = material.textureIndex;

gpuDrawIndexed(commandBuffer, dataVertex.gpu, dataPixel.gpu, mesh.indices, mesh.indexCount);

// Vertex shader...
struct VertexOut 
{
    float32x4 position : SV_Position; // SV values are not real struct fields (doesn't affect the layout)
    float32x2 uv;
};

VertexOut main(uint32 vertexIndex : SV_VertexID, const DataVertex* data)
{
    Vertex vertex = data.vertices[vertexIndex];
    float32x4 position = data-&gt;matrixMVP * vertex.position;
    return { .position = position, .uv = vertex.uv };
}

// Pixel shader...
const Texture textureHeap[];

struct VertexIn // Matching vertex shader output struct layout
{
    float32x2 uv;
};

PixelOut main(const VertexIn &amp;vertex, const DataPixel* data)
{
    Texture texture = textureHeap[data-&gt;textureIndex];
    Sampler sampler = {.minFilter = LINEAR, .magFilter = LINEAR};

    float32x4 color = sample(texture, sampler, vertex.uv);
    return { .color = color };
}</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_128446">
  <p>Our goal was to reduce the PSO permutation explosion by minimizing the remaining state inside the PSO. The depth-stencil can be separated on all architectures. The blend state separation is possible on desktop hardware, but most mobile hardware burns the blend equation at the end of the pixel shader microcode. Exposing the framebuffer fetch intrinsics directly to the user is a much better idea than Vulkan’s failed subpass approach. Users can write their own blend formulas unlocking new rendering algorithms, or they can author general parametrized blending formulas to reduce the PSO count.</p><h2>Indirect drawing</h2><p>Standard draw/dispatch commands utilize C/C++ function parameters to provide the arguments: thread group dimensions, index count, instance count, etc. Indirect draw calls allow the user to provide a GPU buffer + offset pair instead as the draw argument source, a crucial addition enabling GPU-driven rendering. Our version uses a single GPU pointer instead of the usual buffer object + offset pair, simplifying the API slightly.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_131320"><pre><code>gpuDispatchIndirect(commandBuffer, data.gpu, arguments.gpu);
gpuDrawIndexedInstancedIndirect(commandBuffer, dataVertex.gpu, dataPixel.gpu, arguments.gpu);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_131381">
  <p>All of our arguments are GPU pointers. Both the data and the arguments are indirect. This is a great improvement over existing APIs. DirectX 12, Vulkan and Metal don’t support indirect root arguments. The CPU has to provide them.</p><p>Indirect multidraw (MDI) should also be supported. The draw count comes from a GPU address. MDI parameters are: an array of root data (GPU pointer, for both vertex and pixel), an array of draw arguments (GPU pointer), and stride for the root data array (for both vertex and pixel). Stride = 0 naturally means that the same root data is replicated for each draw.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_145649"><pre><code>gpuDrawIndexedInstancedIndirectMulti(commandBuffer, dataVertex.gpu, sizeof(DataVertex), dataPixel.gpu, sizeof(DataPixel), arguments.gpu, drawCount.gpu);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_145709">
  <p>Vulkan’s multidraw doesn’t allow changing bindings per draw call. You can use gl_DrawID to index into a buffer which contains your draw data structs. This adds an indirection in the shader. You need to use either descriptor indexing or the new descriptor buffer extension to fetch textures. DirectX 12 ExecuteIndirect has a configurable command signature, allowing the user to manually setup a root constant per draw, but this doesn’t hit the fast path on all GPU command processors. ExecuteIndirect tier 1.1 (2024) added a new optional counter increment feature: D3D12_INDIRECT_ARGUMENT_TYPE_INCREMENTING_CONSTANT. This can be used to implement draw ID. SM6.8 (2024) finally added support for SV_StartInstanceLocation, allowing the user to directly embed a constant in the indirect draw arguments. Unlike SV_InstanceID, the new SV_StartInstanceLocation is uniform across the whole draw call, providing optimal codegen for indexed loads (uniform/scalar path). The data fetch still requires an indirection. GPU-generated root data is not supported.&nbsp;</p><p>If we generate draw arguments or root data on the GPU, we need to ensure that the command processor waits for the dispatch to finish. Modern command processors prefetch commands and their arguments to hide the latency. We have a flag in our barrier to prevent this. The best practice is to batch update all your draw arguments and root data to avoid fine-grained barriers.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_148980"><pre><code>gpuBarrier(commandBuffer, STAGE_COMPUTE, STAGE_COMPUTE, HAZARD_DRAW_ARGUMENTS);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_149113">
  <p>The lack of indirect shader selection is a significant limitation in the current PC and mobile graphics APIs. Indirect shader selection can be implemented using multi-pipelines similar to ray-tracing. Metal also supports indirect command creation (Nvidia has a similar Vulkan extension). An efficient way to skip over draw calls is a valuable subset. DirectX work graphs and CUDA dynamic parallelism allow a shader to spawn more waves on demand. Unfortunately, the APIs to access these hardware improvements is still highly platform specific and scattered in multiple shader entry points. There’s no clear standardization. My followup post will discuss the shader framework and cover this topic in depth.</p><p>Our proposed design makes indirect drawing extremely powerful. Both the shader root data and the draw parameters can be indirectly provided by the GPU. These advantages power up multi-draw, allowing clean and efficient per-draw data bindings with no hacks. The future of indirect drawing and the shader framework will be discussed in a followup post.</p><h2>Render passes</h2><p>The rasterizer hardware needs to be prepared for rendering before we can start drawing. Common operations include binding render target and depth-stencil views and clearing color and depth. Clear might trigger a fast clear elimination if the clear color is changed. This is transparently handled by the clear command. On mobile GPUs, tiles are stored from on-chip storage to VRAM during rendering. Vulkan, Metal and WebGPU use render pass abstraction for clearing, loading and storing the render target. DirectX 12 added render pass support in the 2018 update in order to optimize rendering on the latest Intel (Gen11) and the Qualcomm (Adreno 630) GPUs. The render pass abstraction doesn’t add notable API complexity, so it's an easy choice for a modern cross platform API.</p><p>DirectX12 has render target views and depth-stencil views, and separate descriptor heaps to store them. This is just an API abstraction. These heaps are simply CPU memory allocated by the driver. Render target and depth-stencil views are not GPU descriptors. The rasterizer API is not bindless. The CPU driver sets up the rasterizer using command packets. In Vulkan and Metal you pass the existing texture/view objects to the beginRenderPass directly. The driver gets the required information from the texture object behind the scenes. Our proposed GpuTexture object fits this job. Rasterization output is the main reason we still need a CPU-side texture object. We write texture descriptors directly into GPU memory. The CPU side driver can’t access those.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765890239746_152053"><pre><code>GpuRenderPassDesc renderPassDesc =
{
    .depthTarget = {.texture = deptStencilTexture, .loadOp = CLEAR, .storeOp = DONT_CARE, .clearValue = 1.0f},
    .stencilTarget = {.texture = deptStencilTexture, .loadOp = CLEAR, .storeOp = DONT_CARE, .clearValue = 0},
    .colorTargets =
    {
        {.texture = gBufferColor, .loadOp = LOAD, .storeOp = STORE, .clearColor = {0,0,0,0}},
        {.texture = gBufferNormal, .loadOp = LOAD, .storeOp = STORE, .clearColor = {0,0,0,0}},
        {.texture = gBufferPBR, .loadOp = LOAD, .storeOp = STORE, .clearColor = {0,0,0,0}}
    }
};

gpuBeginRenderPass(commandBuffer, renderPassDesc);
// Add draw calls here!
gpuEndRenderPass(commandBuffer);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765890239746_152114">
  <p>It would be nice to have bindless render passes, bindless/indirect (multi-)clear commands, indirect scissor/viewport rectangles (array), etc. Unfortunately many GPUs today still need the CPU driver to set up their rasterizer.</p><p>A note about barriers: Render pass begin/end commands don’t automatically emit barriers. The user can render multiple render passes&nbsp;simultaneously, if they write to disjoint render targets. A barrier between the raster output stage (or later) and the consumer stage will flush the tiny ROP caches if the GPU architecture needs it. Not having an automatic barrier between the render passes is also crucial for efficient depth prepass implementations (ROP caches are not flushed needlessly).</p>
</div><div data-test="image-block-inline-outer-wrapper" data-block-type="5" id="block-yui_3_17_2_1_1765891714485_24990">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-stretch="false" data-src="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png" data-image="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png" data-image-dimensions="3524x1996" data-image-focal-point="0.5,0.5" alt="" data-load="false" elementtiming="system-image-block" src="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png" width="3524" height="1996" sizes="(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw" onload="this.classList.add(&quot;loaded&quot;)" srcset="https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/6741ac845a0db27835868e3c/00e4b579-4b5b-4d09-854d-b89f04df7556/Screenshot+2025-12-16+at+15.33.03.png?format=2500w 2500w" loading="lazy" decoding="async" data-loader="sqs">

            </p>
          </div>
        
          
        

        
          
          <figcaption>
            <p data-rte-preserve-empty="true">GPU-based clay simulation and ray-tracing tech in Claybook (Sebastian Aaltonen, GDC 2018): I optimized the Unreal Engine 4 console barrier implementations (Xbox One, PS4) to allow render target overlap. The barrier stall is avoided.</p>
          </figcaption>
        
      
        </figure>
      

    </div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765891714485_25314">
  <h2>Prototype API</h2><p>My prototype API fits in one screen: 150 lines of code. The blog post is titled “No Graphics API”. That’s obviously an impossible goal today, but we got close enough. WebGPU has a smaller feature set and features a ~2700 line API (Emscripten C header). Vulkan header is ~20,000 lines, but it supports ray-tracing, and many other features our minimalistic API doesn’t yet support. We didn’t have to trade off performance to achieve the reduction in API complexity. For this feature set, our API offers more flexibility than existing APIs. A fully extended summer 2025 Vulkan 1.4 can do all the same things in practice, but is significantly more complex to use and has more API overhead.</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765888768382_375054"><pre><code>// Opaque handles
struct GpuPipeline;
struct GpuTexture;
struct GpuDepthStencilState;
struct GpuBlendState;
struct GpuQueue;
struct GpuCommandBuffer;
struct GpuSemaphore;

// Enums
enum MEMORY { MEMORY_DEFAULT, MEMORY_GPU, MEMORY_READBACK };
enum CULL { CULL_CCW, CULL_CW, CULL_ALL, CULL_NONE };
enum DEPTH_FLAGS { DEPTH_READ = 0x1, DEPTH_WRITE = 0x2 };
enum OP { OP_NEVER, OP_LESS, OP_EQUAL, OP_LESS_EQUAL, OP_GREATER, OP_NOT_EQUAL, OP_GREATER_EQUAL, OP_ALWAYS }; 
enum BLEND { BLEND_ADD, BLEND_SUBTRACT, BLEND_REV_SUBTRACT, BLEND_MIN, BLEND_MAX };
enum FACTOR { FACTOR_ZERO, FACTOR_ONE, FACTOR_SRC_COLOR, FACTOR_DST_COLOR, FACTOR_SRC_ALPHA, ... };
enum TOPOLOGY { TOPOLOGY_TRIANGLE_LIST, TOPOLOGY_TRIANGLE_STRIP, TOPOLOGY_TRIANGLE_FAN };
enum TEXTURE { TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_CUBE, TEXTURE_2D_ARRAY, TEXTURE_CUBE_ARRAY };
enum FORMAT { FORMAT_NONE, FORMAT_RGBA8_UNORM, FORMAT_D32_FLOAT, FORMAT_RG11B10_FLOAT, FORMAT_RGB10_A2_UNORM, ... };
enum USAGE_FLAGS { USAGE_SAMPLED, USAGE_STORAGE, USAGE_COLOR_ATTACHMENT, USAGE_DEPTH_STENCIL_ATTACHMENT, ... };
enum STAGE { STAGE_TRANSFER, STAGE_COMPUTE, STAGE_RASTER_COLOR_OUT, STAGE_PIXEL_SHADER, STAGE_VERTEX_SHADER, ... };
enum HAZARD_FLAGS { HAZARD_DRAW_ARGUMENTS = 0x1, HAZARD_DESCRIPTORS = 0x2, , HAZARD_DEPTH_STENCIL = 0x4 };
enum SIGNAL { SIGNAL_ATOMIC_SET, SIGNAL_ATOMIC_MAX, SIGNAL_ATOMIC_OR, ... };

// Structs
struct Stencil 
{
    OP test = OP_ALWAYS,
    OP failOp = OP_KEEP;
    OP passOp = OP_KEEP;
    OP depthFailOp = OP_KEEP;
    uint8 reference = 0;
};

struct GpuDepthStencilDesc 
{
    DEPTH_FLAGS depthMode = 0;
    OP depthTest = OP_ALWAYS;
    float depthBias = 0.0f;
    float depthBiasSlopeFactor = 0.0f;
    float depthBiasClamp = 0.0f;
    uint8 stencilReadMask = 0xff;
    uint8 stencilWriteMask = 0xff;
    Stencil stencilFront;
    Stencil stencilBack;
};

struct GpuBlendDesc
{
    BLEND colorOp = BLEND_ADD,
    FACTOR srcColorFactor = FACTOR_ONE;
    FACTOR dstColorFactor = FACTOR_ZERO;
    BLEND alphaOp = BLEND_ADD;
    FACTOR srcAlphaFactor = FACTOR_ONE;
    FACTOR dstAlphaFactor = FACTOR_ZERO;
    uint8 colorWriteMask = 0xf;
};

struct ColorTarget {
    FORMAT format = FORMAT_NONE;
    uint8 writeMask = 0xf;
};

struct GpuRasterDesc
{
    TOPOLOGY topology = TOPOLOGY_TRIANGLE_LIST;
    CULL cull = CULL_NONE;
    bool alphaToCoverage = false;
    bool supportDualSourceBlending = false;
    uint8 sampleCount = 1;
    FORMAT depthFormat = FORMAT_NONE;
    FORMAT stencilFormat = FORMAT_NONE;
    Span&lt;ColorTarget&gt; colorTargets = {};
    GpuBlendDesc* blendstate = nullptr; // optional embedded blend state
};

struct GpuTextureDesc
{ 
    TEXTURE type = TEXTURE_2D;
    uint32x3 dimensions;
    uint32 mipCount = 1;
    uint32 layerCount = 1;
    uint32 sampleCount = 1;
    FORMAT format = FORMAT_NONE; 
    USAGE_FLAGS usage = 0;
};

struct GpuViewDesc 
{
    FORMAT format = FORMAT_NONE;
    uint8 baseMip = 0;
    uint8 mipCount = ALL_MIPS;
    uint16 baseLayer = 0;
    uint16 layerCount = ALL_LAYERS;
};

struct GpuTextureSizeAlign { size_t size; size_t align; };
struct GpuTextureDescriptor { uint64[4] data; };

// Memory
void* gpuMalloc(size_t bytes, MEMORY memory = MEMORY_DEFAULT);
void* gpuMalloc(size_t bytes, size_t align, MEMORY memory = MEMORY_DEFAULT);
void gpuFree(void *ptr);
void* gpuHostToDevicePointer(void *ptr);

// Textures
GpuTextureSizeAlign gpuTextureSizeAlign(GpuTextureDesc desc);
GpuTexture gpuCreateTexture(GpuTextureDesc desc, void* ptrGpu);
GpuTextureDescriptor gpuTextureViewDescriptor(GpuTexture texture, GpuViewDesc desc);
GpuTextureDescriptor gpuRWTextureViewDescriptor(GpuTexture texture, GpuViewDesc desc);

// Pipelines
GpuPipeline gpuCreateComputePipeline(ByteSpan computeIR);
GpuPipeline gpuCreateGraphicsPipeline(ByteSpan vertexIR, ByteSpan pixelIR, GpuRasterDesc desc);
GpuPipeline gpuCreateGraphicsMeshletPipeline(ByteSpan meshletIR, ByteSpan pixelIR, GpuRasterDesc desc);
void gpuFreePipeline(GpuPipeline pipeline);

// State objects
GpuDepthStencilState gpuCreateDepthStencilState(GpuDepthStencilDesc desc);
GpuBlendState gpuCreateBlendState(GpuBlendDesc desc);
void gpuFreeDepthStencilState(GpuDepthStencilState state);
void gpuFreeBlendState(GpuBlendState state);

// Queue
GpuQueue gpuCreateQueue(/* DEVICE &amp; QUEUE CREATION DETAILS OMITTED */);
GpuCommandBuffer gpuStartCommandRecording(GpuQueue queue);
void gpuSubmit(GpuQueue queue, Span&lt;GpuCommandBuffer&gt; commandBuffers);

// Semaphores
GpuSemaphore gpuCreateSemaphore(uint64 initValue);
void gpuWaitSemaphore(GpuSemaphore sema, uint64 value);
void gpuDestroySemaphore(GpuSemaphore sema);

// Commands
void gpuMemCpy(GpuCommandBuffer cb, void* destGpu, void* srcGpu,);
void gpuCopyToTexture(GpuCommandBuffer cb, void* destGpu, void* srcGpu, GpuTexture texture);
void gpuCopyFromTexture(GpuCommandBuffer cb, void* destGpu, void* srcGpu, GpuTexture texture);

void gpuSetActiveTextureHeapPtr(GpuCommandBuffer cb, void *ptrGpu);

void gpuBarrier(GpuCommandBuffer cb, STAGE before, STAGE after, HAZARD_FLAGS hazards = 0);
void gpuSignalAfter(GpuCommandBuffer cb, STAGE before, void *ptrGpu, uint64 value, SIGNAL signal);
void gpuWaitBefore(GpuCommandBuffer cb, STAGE after, void *ptrGpu, uint64 value, OP op, HAZARD_FLAGS hazards = 0, uint64 mask = ~0);

void gpuSetPipeline(GpuCommandBuffer cb, GpuPipeline pipeline);
void gpuSetDepthStencilState(GpuCommandBuffer cb, GpuDepthStencilState state);
void gpuSetBlendState(GpuCommandBuffer cb, GpuBlendState state); 

void gpuDispatch(GpuCommandBuffer cb, void* dataGpu, uvec3 gridDimensions);
void gpuDispatchIndirect(GpuCommandBuffer cb, void* dataGpu, void* gridDimensionsGpu);

void gpuBeginRenderPass(GpuCommandBuffer cb, GpuRenderPassDesc desc);
void gpuEndRenderPass(GpuCommandBuffer cb);

void gpuDrawIndexedInstanced(GpuCommandBuffer cb, void* vertexDataGpu, void* pixelDataGpu, void* indicesGpu, uint32 indexCount, uint32 instanceCount);
void gpuDrawIndexedInstancedIndirect(GpuCommandBuffer cb, void* vertexDataGpu, void* pixelDataGpu, void* indicesGpu, void* argsGpu);
void gpuDrawIndexedInstancedIndirectMulti(GpuCommandBuffer cb, void* dataVxGpu, uint32 vxStride, void* dataPxGpu, uint32 pxStride, void* argsGpu, void* drawCountGpu);

void gpuDrawMeshlets(GpuCommandBuffer cb, void* meshletDataGpu, void* pixelDataGpu, uvec3 dim);
void gpuDrawMeshletsIndirect(GpuCommandBuffer cb, void* meshletDataGpu, void* pixelDataGpu, void *dimGpu);</code></pre>

</div><div data-sqsp-text-block-content="" data-block-type="2" data-border-radii="{&quot;topLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;topRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomLeft&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0},&quot;bottomRight&quot;:{&quot;unit&quot;:&quot;px&quot;,&quot;value&quot;:0.0}}" data-sqsp-block="text" id="block-yui_3_17_2_1_1765888768382_375116">
  <h2>Tooling</h2><p>How can we debug code that doesn’t bind buffer and texture objects and doesn’t call an API to describe the memory layout explicitly? C/C++ debuggers have been doing that for decades. There’s no special operating system APIs for describing your software’s memory layout. The debugger is able to follow 64-bit pointer chains and use the debug symbol data provided by your compiler. This includes the memory layouts of your structs and classes. CUDA and Metal use C/C++ based shading languages with full 64-bit pointer semantics. Both have robust debuggers that traverse pointer chains without issues. The texture descriptor heap is just GPU memory. The debugger can index it, load a texture descriptor, show the descriptor data and visualize the texels. All of this works already in the Xcode Metal debugger. Click on a texture or a sampler handle in any struct in any GPU address. Debugger will visualize it.</p><p>Modern GPUs virtualize memory. Each process has their own page table. The GPU capture has a separate replayer process with its own virtual address space. If the replayer would naively replay all the allocations, it would get a different GPU virtual address for each memory allocation. This was fine for legacy APIs as it wasn’t possible to directly store GPU addresses in your data structures. A modern API needs special replay memory allocation APIs that force the replayer to mirror the exact GPU virtual memory layout. DX12 and Vulkan BDA have public APIs for this: RecreateAt and VkMemoryOpaqueCaptureAddressAllocateInfo. Metal and CUDA debuggers do the same using internal undocumented APIs. A public API is preferable as it allows open source tools like RenderDoc to function.</p><p>Don’t raw pointers bring security concerns? Can’t you just read/write other apps' memory? This is not possible due to virtual memory. You can only access your own memory pages. If you accidentally use a stale pointer or overflow, you will get a page fault. Page faults are possible with existing buffer based APIs. DirectX 12 and Vulkan don’t clamp your storage (byteaddress/structured) buffer addresses. OOB causes a page fault. Users can also accidentally free a memory heap and continue using stale buffer or texture descriptors to get a page fault. Nothing really changes. An access to an unmapped region is a page fault and the application crashes. This is familiar to C/C++ programmers. If you want robustness, you can use ptr + size pairs. That’s exactly how WebGPU is implemented. The WebGPU shader compiler (Tint or Naga) emits an extra clamp instruction for each buffer access, including vertex accesses (index buffer value out of bounds). WebGL didn’t allow shading index buffer data with other data. WebGL scanned through the indices on the CPU side (making index buffer update very slow). Back then custom vertex fetch was not possible. The hardware page faulted before the shader even ran.</p><h2>Translation layers</h2><p>Being able to run existing software is crucial. Translation layers such as ANGLE, Proton and MoltenVK play a crucial role in the portability and deprecation process of legacy APIs. Let’s talk about translating DirectX 12, Vulkan and Metal to our new API.</p><p>MoltenVK (Vulkan to Metal translation layer) proves that Vulkan’s buffer centric API can be translated to Metal’s 64-bit pointer based ecosystem. MoltenVK translates Vulkan’s descriptor sets into Metal’s argument buffers. The generated argument buffers are standard GPU structs containing a 64-bit GPU pointer per buffer binding and a 64-bit texture ID per texture binding. We can do better by allocating a contiguous range of texture descriptors in our texture heap for each descriptor set, and storing a single 32-bit base index instead of a 64-bit texture ID for each texture binding. This is possible since our API has a user managed texture heap unlike Metal.</p><p>MoltenVK maps descriptor sets to Metal API root bind slots. We generate a root struct with up to eight 64-bit pointer fields, each pointing to a descriptor set struct (see above). Root constants are translated into value fields and root descriptors (root buffers) are translated into 64-bit pointers. The efficiency should be identical, assuming the GPU driver preloads our root struct fields into uniform/scalar registers (as discussed in the root arguments chapter).</p><p>Our API uses 64-bit pointer semantics like Metal. We can use the same techniques employed by MoltenVK to translate the buffer load/store instructions in the shader. MoltenVK also supports translating Vulkan’s new buffer device address extension.</p><p>Proton (DX12 to Vulkan translation layer) proves that DirectX 12 SM 6.6 descriptor heap can be translated to Vulkan’s new descriptor buffer extension. Proton also translates other DirectX 12 features to Vulkan. We have already shown that Vulkan to Metal translation is possible with MoltenVK, transitively proving that translation from DirectX 12 to Metal should be possible. The biggest missing feature in MoltenVK is the SM 6.6 style descriptor heap (Vulkan’s descriptor buffer extension). Metal doesn’t expose the descriptor heap directly to the user. Our new proposed API has no such limitation. Our descriptor heap semantics are a superset to SM 6.6 descriptor heap and a close match to Vulkan’s descriptor buffer extension. Translation is straightforward. Vulkan’s extension also adds a special flag for descriptor invalidate, matching our HAZARD_DESCRIPTORS. DirectX 12 descriptor heap API is easy to translate, as it’s just a thin wrapper over the raw descriptor array in GPU memory.</p><p>To support Metal 4.0, we need to implement Metal’s driver managed texture descriptor heap. This can be implemented using a simple freelist over our texture heap. Metal uses 64-bit texture handles which are implemented as direct heap indices on modern Apple Silicon devices. Metal allows using the texture handles in shaders directly as textures. This is syntactic sugar for textureHeap[uint64(handle)]. A Metal texture handle is translated into uint64 by our shader translator, maintaining identical GPU memory layout.</p><p>Our API doesn’t support vertex buffers. WebGPU doesn’t use hardware vertex buffers either, yet it implements the classic vertex buffer abstraction. WGSL shader translator (Tint or Naga) adds one storage buffer binding per vertex stream and emits vertex load instructions in the beginning of the vertex shader. Custom vertex fetch allows emitting clamp instructions to avoid OOB behavior. A misbehaving website can’t crash the web browser. Our own shader translator adds a 64-bit pointer to the root struct for each vertex stream, generates a struct matching its layout and emits vertex struct load instructions in the beginning of the vertex shader.</p><p>We have shown that it’s possible to write translation layers to run DirectX 12, Vulkan and Metal applications on top of our new API. Since WebGPU is implemented on top of these APIs by browsers, we can run WebGPU applications too.</p><h2>Min spec hardware</h2><p><strong>Nvidia Turing</strong> (RTX 2000 series, 2018) introduced ray-tracing, tensor cores, mesh shaders, low latency raw memory paths, bigger &amp; faster caches, scalar unit, secondary integer pipeline and many other future looking features. Officially PCIe ReBAR support launched with RTX 3000 series, but there exists hacked Turing drivers that support it too, indicating that the hardware is capable of it. This 7 year old GPU supports everything we need. Nvidia just ended GTX 1000 series driver support in fall 2025. All currently supported Nvidia GPUs could be supported by our new API.</p><p><strong>AMD RDNA2</strong> (RX 6000 series, 2020) matched Nvidia’s feature set with ray-tracing and mesh shaders. One year earlier, RDNA 1 introduced coherent L2$, new L1$ level, fast L0$, generic DCC read/write paths, fastpath unfiltered loads and a modern SIMD32 architecture. PCIe ReBAR is officially supported (brand name “Smart Access Memory”). This 5 year old GPU supports everything we need. AMD ended GCN driver support already in 2021. Today RDNA 1 &amp; RDNA 2 only receive bug fixes and security updates, RDNA 3 is the oldest GPU receiving game optimizations. All the currently supported AMD GPUs could be supported by our API.</p><p><strong>Intel Alchemist / Xe1</strong> (2022) were the first Intel chips with SM 6.6 global indexable heap support. These chips also support ray-tracing, mesh shaders, PCIe ReBAR (discrete) and UMA (integrated). These 3 year old Intel GPUs support everything we need.</p><p><strong>Apple M1 / A14</strong> (MacBook M1, iPhone 12, 2020) support Metal 4.0. Metal 4.0 guarantees GPU memory visibility to CPU (UMA on both phones and computers), and allows the user to write 64-bit pointers and 64-bit texture handles directly into GPU memory. Metal 4.0 has a new residency set API, solving a crucial usability issue with bindless resource management in the old useResource/useHeap APIs. iOS 26 still supports iPhone 11. Developers are not allowed to ship apps that require Metal 4.0 just yet. iOS 27 likely deprecates iPhone 11 support next year. On Mac, if you drop Intel Mac support, you have guaranteed Metal 4.0 support. M1-M5 = 5 generations = 5 years.</p><p><strong>ARM Mali-G710</strong> (2021) is ARMs first modern architecture. It introduced their new command stream frontend (CSF), reducing the CPU dependency of draw call building and adding crucial features like multi-draw indirect and compute queues. Non-uniform index texture sampling is significantly faster and the AFBC lossless compressor now supports 16-bit floating point targets. G710 supports Vulkan BDA and descriptor buffer extensions and is capable of supporting the new 2025 unified image layout extension with future drivers. The Mali-G715 (2022) introduced support for ray-tracing.</p><p><strong>Qualcomm Adreno 650 </strong>(2019) supports Vulkan BDA, descriptor buffer and unified image layout extensions, 16-bit storage/math, dynamic rendering and extended dynamic state with the latest Turnip open source drivers. Adreno 740 (2022) introduced support for ray-tracing.</p><p><strong>PowerVR DXT</strong> (Pixel 10, 2025) is PowerVRs first architecture that supports Vulkan descriptor buffer and buffer device address extensions. It also supports 64-bit atomics, 8-bit and 16-bit storage/math, dynamic rendering, extended dynamic state and all the other features we require.</p><h2>Conclusion</h2><p>Modern graphics API have improved gradually in the past 10 years. Six years after DirectX 12 launch, SM 6.6 (2021) introduced the modern global texture heap, allowing fully bindless renderer design. Metal 4.0 (2025) and CUDA have a clean 64-bit pointer based shader architecture with minimal binding API surface. Vulkan has the most restrictive standard, but extensions such as buffer device access (2020), descriptor buffer (2022) and unified image layouts (2025) add support for modern bindless infrastructure, but tools are still lagging behind. As of today, there’s no single API that meets all our requirements, but if we combine their best bits together, we can build the perfect API for modern hardware.</p><p>10 years ago, modern APIs were designed for CPU-driven binding models. New bindless features were presented as optional features and extensions. A clean break would improve the usability and reduce the API bloat and driver complexity significantly. It’s extremely difficult to get the whole industry behind a brand new API. I am hoping that vendors are willing to drop backwards compatibility in their new major API versions (Vulkan 2.0, DirectX 13) to embrace the fully bindless GPU architecture we have today. A new bindless API design would solve the mismatch between the API and the game engine RHI, allowing us to get rid of the hash maps and fine grained resource tracking. Metal 4.0 is close to this goal, but it is still missing the global indexable texture heap. A 64-bit texture handle can’t represent a range of textures.</p><p>HLSL and GLSL shading languages were designed over 20 years ago as a framework of 1:1 elementwise transform functions (vertex, pixel, geometry, hull, domain, etc). Memory access is abstracted and array handling is cumbersome as there’s no support for pointers. Despite 20 years of existence, HLSL and GLSL have failed to accumulate a library ecosystem. CUDA in contrast is a composable language exposing memory directly and new features (such as AI tensor cores) though intrinsics. CUDA has a broad library ecosystem, which has propelled Nvidia into $4T valuation. We should learn from it.</p><p>WebGPU note: WebGPU design is based on 10 year old core Vulkan 1.0 with extra restrictions. WebGPU doesn’t support bindless resources, 64-bit GPU pointers or persistently mapped GPU memory. It feels like a mix between DirectX 11 and Vulkan 1.0. It is a great improvement for web graphics, but doesn’t meet modern bindless API standards. I will discuss WebGPU in a separate blog post.&nbsp;</p><p>My prototype API shows what is achievable with modern GPU architectures today, if we mix the best bits from all the latest APIs. It is possible to build an API that is simpler to use than DirectX 11 and Metal 1.0, yet it offers better performance and flexibility than DirectX 12 and Vulkan. We should embrace the modern bindless hardware.&nbsp;</p><h2>Appendix</h2><p>A simple user land GPU bump allocator used in all example code. We call gpuHostToDevicePointer once in the temp allocator constructor. We can perform standard pointer arithmetic (such as offset) on GPU pointers. Traditional Vulkan/DX12 buffer APIs require a separate offset. This simplifies the API and user code (ptr vs handle+offset pair). A production ready temp allocator would implement overflow handing (grow, flush, etc).&nbsp;</p>
</div><div data-block-type="44" id="block-yui_3_17_2_1_1765887159238_683986"><pre><code>template&lt;typename T&gt;
struct GPUTempAllocation&lt;T&gt;
{
    T* cpu;
    T* gpu;
}

struct GPUBumpAllocator
{
    uint8 *cpu;
    uint8 *gpu;
    uint32 offset = 0;
    uint32 size;

    TempBumpAllocator(uint32 size) : size(size)
    {
        cpu = gpuMalloc(size);
        gpu = gpuHostToDevicePointer(cpu);
    }

    TempAllocation&lt;uint8&gt; alloc(int bytes, int align = 16)
    {
        offset = alignRoundUp(offset, align);
        if (offset + bytes &gt; size) offset = 0; // Simple ring wrap (no overflow detection)
        TempAllocation&lt;uint8&gt; alloc = { .cpu = cpu + offset, . gpu = gpu + offset };
        offset += bytes;
        return alloc;
    }

    template&lt;typename T&gt;&nbsp;
    T* alloc(int count = 1)
    {
        TempAllocation&lt;uint8&gt; mem = alloc(sizeof(T) * count, alignof(T));
        return TempAllocation&lt;T&gt; { .cpu = (T*)mem.cpu, . gpu = (T*)mem.gpu };
    }
};</code></pre>

</div></div>
  
</article>

</div>

  
</article>

          

          

          
            
              

            
          
        
      </div></div>]]></description>
        </item>
        <item>
            <title><![CDATA[Vibe coding creates fatigue? (167 pts)]]></title>
            <link>https://www.tabulamag.com/p/too-fast-to-think-the-hidden-fatigue</link>
            <guid>46292365</guid>
            <pubDate>Tue, 16 Dec 2025 18:32:46 GMT</pubDate>
            <description><![CDATA[<p>URL: <a href="https://www.tabulamag.com/p/too-fast-to-think-the-hidden-fatigue">https://www.tabulamag.com/p/too-fast-to-think-the-hidden-fatigue</a>, See on <a href="https://news.ycombinator.com/item?id=46292365">Hacker News</a></p>
<div id="readability-page-1" class="page"><p><span>After vibe coding for some time, I feel fatigue. I’m coding </span><a href="https://www.marvai.dev/" rel="">Marvai - a package manager for prompts</a><span> on my own, with a combination of Claude Code and Cursor.</span></p><div><li><p><span>I use Claude Code for code generation,</span><a href="https://www.tabulamag.com/p/how-to-use-ai-as-a-developer-today" rel=""> bug fixing</a><span>, test writing, test fixing, security checks etc.</span></p></li><li><p>Claude Code is especially useful to fix linting errors from nilaway or staticcheck - for a developer those are boring and tedious.</p></li><li><p>I use Cursor for augmented coding, generate functions, adapt copy&amp;pasted code, for refactoring, fix error handling, and many other tedious tasks.</p></li><li><p>I have been a coder for 40 years and I have seen many tools for developers that haven’t worked, like Model Driven Development MDD/MDA and executable UML.</p></li><li><p><span>With AI I’m now much faster at generating code and building features than I ever was before. </span><strong>The combination of Claude Code and Cursor is a real speedup.</strong></p></li><li><p><em><strong>I encountered a new phenomenon.</strong></em></p></li><li><p><span>Again and again I feel fatigue. I finish a feature, and another feature, concetrate on  reviewing the code the AI generated, and fix a bug and finish a feature with such velocity and I feel fatigue after some hours - sometimes as soon as one hour. AI working at such speed, finishing things to accept or review, feels too much for my brain to process or keep up with. </span><em><strong>I need to  pause for some time before I can start again.</strong></em></p></li><li><p>I haven’t felt this before as a developer. </p></li><li><p><span>I first encountered the concept of cognitive load in the book</span><a href="https://teamtopologies.com/book" rel=""> Team Toplogies</a><span>. The idea there is to structure teams in a way that the cognitive load for developers is not too small and not to big. The more responsibilities a team and it’s members get, the bigger the cognitive load. And if you put many different topics on a team, the cognitive load for the team becomes too big for the team to work.</span></p></li><li><p><span>As a young adult I was working in a plastic factory, sitting at a machine. The machine produced vacuum cleaner cases, had it’s rhythm, it finished vacuum cleaner cases on it’s own schedule, made a “PING” when finished, opened the door and I had to grab the casing and put it down (and package it in fine paper etc. which took some time). The machine would close while I was finishing the casing. And for some time it was stressful, working to the rhythm of the machine. Then I got accustomed to the speed and rhythm, until my boss increased the frequency. </span><em><strong>Living by machine time is what I sometimes feel with Vibe Coding and Cursor generating code or Claude fixing a bug</strong></em><span>.</span></p></li><li><p><span>I had </span><a href="https://xkcd.com/303/" rel="">waiting times with compiling</a><span> and waited for the machine to finish, but it feels differently, with vibe coding it feels like the machine is in control not me.</span></p></li><li><p>With traditional coding, the speed of your output matches the complexity of the task and the speed of your coding. This gives your brain time to process what is happening. With vibe coding the coding happens so fast, that my brain can’t process what is happening in real time, and thoughts are getting clogged up. Complex tasks are compressed into seconds or minutes.</p></li><li><p>My brain does not get the baking time to mentally process architecture, decisions and edge cases the AI creates - not enough time to put the AI output into one coherent picture. I’m running a marathon at the pace of a sprint - speeds don’t match.</p></li><li><p>One reason developers are developers is the dopamine loop.</p></li><li><p><span>You write code, it doesn’t work, you fix it, it works, great! Dopamine rush. Several dozens or a hundred times a day. Now this loop speeds up. Faster and faster we run around that loop, and get washed with Dopamine - and your brain gets overwhelmed. And stress hormones at the same time! </span><em><strong>You get fatigue - instead of the usually happiness and satisfaction of coding.</strong></em></p></li><li><p><span>With coding there is a limit to context switching. A context switch in coding is like dumping the cache of your brain and reloading the cache of your brain with a new context. This takes time and energy. You need to build a </span><a href="https://leanpub.com/ideaflow/" rel="">mental model of the code</a><span>, to decide what to change and how to change it and then writing the changes out into source code, the essence of coding.</span></p></li><li><p><span>With vibe coding the frequency of content switches speeds up tremendously - with the AI fixing and creating many different things in different packages or modules with one go. Even when I </span><em>&lt;tab&gt;, &lt;tab&gt;, &lt;tab&gt;</em><span> in Cursor, each change is a micro-content switch from function to function.</span></p></li><li><p>Each context switch takes energy, every context switch is heavy lifting for your brain. Normally this materializes as the fact that it takes time to context switch. With AI in the driver seat, context switches are forced on you faster and faster. </p></li><li><p>When each context switch takes energy, fast energy switches from feature delivered to feature delivered, vibe coding drains your energy - fatigue!</p></li><li><p>With AI it seems we all become managers, we all become reviewers. The core of the role is changing from turning requirements into code to managing AI output - more like a team lead manages the output of a team, but on a much deeper level. Your responsibility grows to manage a team of five with vibe coding, while still being a developer being responsible for the code. It’s like being a traffic officer in the middle of a busy intersection - which is a stressful job on it’s own - while also overseeing five intersections in parallel.</p></li><li><p>Reviewing, directing and guiding an AI puts more stress on you than writing code, where your writing matches your thinking and doesn’t jump ahead, with you in a rush to catch up.</p></li><li><p>What can be said:</p><ul><li><p>Me and many more I assume feel fatigue from vibe coding</p></li><li><p>We need deliberate pacing when working with AI tools</p></li><li><p>We need AI-aware retrospectives to understand what is going on - perhaps having a daily retrospective to get the mind and the code in sync again</p></li><li><p>We need to be aware of new mental health challenges for AI coders</p></li><li><p><span>We might need to </span><a href="https://www.tabulamag.com/p/introduction-to-theory-of-control" rel="">let go of micro managing AIs</a><span> and trust the AI more - stop trying to bridge the gap between managing an AI and controlling it’s output</span></p></li></ul></li><li><p>I don’t think we’ve figured out yet where this is going. AI has made us faster than we’ve ever been, but our brains haven’t caught up to the pace. We’re like early pilots flying with autopilot—capable, but drained. We need new rhythms, new boundaries, and new ways of thinking about what it means to “code.”</p></li><li><p><em>Maybe the future of coding isn’t just faster. Maybe it’s also slower in a way, on purpose.</em></p></li></div></div>]]></description>
        </item>
    </channel>
</rss>